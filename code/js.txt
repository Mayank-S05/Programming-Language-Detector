(function(){
    'use strict';

    function isEndOfTag(char){
        return char === '>';
    }

    function isStartOfTag(char){
        return char === '<';
    }

    function isWhitespace(char){
        return /^\s+$/.test(char);
    }

    function isTag(token){
        var match = token.match(/^\s*<([^!>][^>]*)>\s*$/);
        return !!match && match[1].trim().split(' ')[0];
    }

    function isntTag(token){
        return !isTag(token);
    }

    function isStartofHTMLComment(word){
        return /^<!--/.test(word);
    }

    function isEndOfHTMLComment(word){
        return /--\>$/.test(word);
    }

   
    function isStartOfAtomicTag(word){
        var result = /^<(iframe|object|math|svg|script)/.exec(word);
        return result && result[1];
    }

      false otherwise.
   
    function isEndOfAtomicTag(word, tag){
        return word.substring(word.length - tag.length - 2) === ('</' + tag);
    }

   
    function isVoidTag(token){
        return /^\s*<[^>]+\/>\s*$/.test(token);
    }

 
    
    function isWrappable(token){
        return isntTag(token) || isStartOfAtomicTag(token) || isVoidTag(token);
    }

 
    function createToken(currentWord){
        return {
            string: currentWord,
            key: getKeyForToken(currentWord)
        };
    }

    function Match(startInBefore, startInAfter, length, segment){
        this.segment = segment;
        this.length = length;

        this.startInBefore = startInBefore + segment.beforeIndex;
        this.startInAfter = startInAfter + segment.afterIndex;
        this.endInBefore = this.startInBefore + this.length - 1;
        this.endInAfter = this.startInAfter + this.length - 1;

        this.segmentStartInBefore = startInBefore;
        this.segmentStartInAfter = startInAfter;
        this.segmentEndInBefore = (this.segmentStartInBefore + this.length) - 1;
        this.segmentEndInAfter = (this.segmentStartInAfter + this.length) - 1;
    }

    
    function htmlToTokens(html){
        var mode = 'char';
        var currentWord = '';
        var currentAtomicTag = '';
        var words = [];
        for (var i = 0; i < html.length; i++){
            var char = html[i];
            switch (mode){
                case 'tag':
                    var atomicTag = isStartOfAtomicTag(currentWord);
                    if (atomicTag){
                        mode = 'atomic_tag';
                        currentAtomicTag = atomicTag;
                        currentWord += char;
                    } else if (isStartofHTMLComment(currentWord)){
                        mode = 'html_comment';
                        currentWord += char;
                    } else if (isEndOfTag(char)){
                        currentWord += '>';
                        words.push(createToken(currentWord));
                        currentWord = '';
                        if (isWhitespace(char)){
                            mode = 'whitespace';
                        } else {
                            mode = 'char';
                        }
                    } else {
                        currentWord += char;
                    }
                    break;
                case 'atomic_tag':
                    if (isEndOfTag(char) && isEndOfAtomicTag(currentWord, currentAtomicTag)){
                        currentWord += '>';
                        words.push(createToken(currentWord));
                        currentWord = '';
                        currentAtomicTag = '';
                        mode = 'char';
                    } else {
                        currentWord += char;
                    }
                    break;
                case 'html_comment':
                    currentWord += char;
                    if (isEndOfHTMLComment(currentWord)){
                        currentWord = '';
                        mode = 'char';
                    }
                    break;
                case 'char':
                    if (isStartOfTag(char)){
                        if (currentWord){
                            words.push(createToken(currentWord));
                        }
                        currentWord = '<';
                        mode = 'tag';
                    } else if (/\s/.test(char)){
                        if (currentWord){
                            words.push(createToken(currentWord));
                        }
                        currentWord = char;
                        mode = 'whitespace';
                    } else if (/[\w\d\#@]/.test(char)){
                        currentWord += char;
                    } else if (/&/.test(char)){
                        if (currentWord){
                            words.push(createToken(currentWord));
                        }
                        currentWord = char;
                    } else {
                        currentWord += char;
                        words.push(createToken(currentWord));
                        currentWord = '';
                    }
                    break;
                case 'whitespace':
                    if (isStartOfTag(char)){
                        if (currentWord){
                            words.push(createToken(currentWord));
                        }
                        currentWord = '<';
                        mode = 'tag';
                    } else if (isWhitespace(char)){
                        currentWord += char;
                    } else {
                        if (currentWord){
                            words.push(createToken(currentWord));
                        }
                        currentWord = char;
                        mode = 'char';
                    }
                    break;
                default:
                    throw new Error('Unknown mode ' + mode);
            }
        }
        if (currentWord){
            words.push(createToken(currentWord));
        }
        return words;
    }

  
    function getKeyForToken(token){
        var tagName = /<([^\s>]+)[\s>]/.exec(token);
        if (tagName){
            return '<' + (tagName[1].toLowerCase()) + '>';
        }
        return token && token.replace(/(\s+|&nbsp;|&#160;)/g, ' ');
    }

   
    function createMap(tokens){
        return tokens.reduce(function(map, token, index){
            if (map[token.key]){
                map[token.key].push(index);
            } else {
                map[token.key] = [index];
            }
            return map;
        } Object.create(null));
    }

   
    function compareMatches(m1, m2){
        if (m2.endInBefore < m1.startInBefore && m2.endInAfter < m1.startInAfter){
            return -1;
        } else if (m2.startInBefore > m1.endInBefore && m2.startInAfter > m1.endInAfter){
            return 1;
        } else {
            return 0;
        }
    }

        add: function (value){
         
            var node = {
                value: value,
                left: null,
                right: null
            };

            var current = this._root;
            if(current){
                while (true){
                    // Determine if the match value should go to the left or right of the current
                    // node.
                    var position = compareMatches(current.value, value);
                    if (position === -1){
                        // The position of the match is to the left of this node.
                        if (current.left){
                            current = current.left;
                        } else {
                            current.left = node;
                            break;
                        }
                    } else if (position === 1){
                        // The position of the match is to the right of this node.
                        if (current.right){
                            current = current.right;
                        } else {
                            current.right = node;
                            break;
                        }
                    } else {
                        // If 0 was returned from compareMatches, that means the node cannot
                        // be inserted because it overlaps an existing node.
                        break;
                    }
                }
            } else {
                // If no nodes exist in the tree, make this the root node.
                this._root = node;
            }
        }

        
        toArray: function(){
            function inOrder(node, nodes){
                if (node){
                    inOrder(node.left, nodes);
                    nodes.push(node.value);
                    inOrder(node.right, nodes);
                }
                return nodes;
            }

            return inOrder(this._root, []);
        }
    };


   
    function findBestMatch(segment){
        var beforeTokens = segment.beforeTokens;
        var afterMap = segment.afterMap;
        var lastSpace = null;
        var bestMatch = null;

     is longer than the remaining tokens, we can bail because we
            // won't find a better match.
            var remainingTokens = beforeTokens.length - beforeIndex;
            if (bestMatch && remainingTokens < bestMatch.length){
                break;
            }

            var beforeToken = beforeTokens[beforeIndex];
            if (beforeToken.key === ' '){
                lastSpace = beforeIndex;
                continue;
            }

       
            if (lastSpace === beforeIndex - 1){
                lookBehind = true;
            }

            
            var afterTokenLocations = afterMap[beforeToken.key];
            if(!afterTokenLocations){
                continue;
            }
                if (match && match.length > bestMatchLength){
                    bestMatch = match;
                }
            });
        }

        return bestMatch;
    }


    function getFullMatch(segment, beforeStart, afterStart, minLength, lookBehind){
        var beforeTokens = segment.beforeTokens;
        var afterTokens = segment.afterTokens;

        // If we already have a match that goes to the end of the document, no need to keep looking.
        var minBeforeIndex = beforeStart + minLength;
        var minAfterIndex = afterStart + minLength;
        if(minBeforeIndex >= beforeTokens.length || minAfterIndex >= afterTokens.length){
            return;
        }

        if (minLength){
            var nextBeforeWord = beforeTokens[minBeforeIndex].key;
            var nextAfterWord = afterTokens[minAfterIndex].key;
            if (nextBeforeWord !== nextAfterWord){
                return;
            }
        }

        var searching = true;
        var currentLength = 1;
        var beforeIndex = beforeStart + currentLength;
        var afterIndex = afterStart + currentLength;

        while (searching && beforeIndex < beforeTokens.length && afterIndex < afterTokens.length){
            var beforeWord = beforeTokens[beforeIndex].key;
            var afterWord = afterTokens[afterIndex].key;
            if (beforeWord === afterWord){
                currentLength++;
                beforeIndex = beforeStart + currentLength;
                afterIndex = afterStart + currentLength;
            } else {
                searching = false;
            }
        }

        // If we've been asked to look behind, it's because both beforeTokens and afterTokens may
        // have a whitespace token just behind the current match that was previously ignored. If so,
        // we'll expand the current match to include it.
        if (lookBehind && beforeStart > 0 && afterStart > 0){
            var prevBeforeKey = beforeTokens[beforeStart - 1].key;
            var prevAfterKey = afterTokens[afterStart - 1].key;
            if (prevBeforeKey === ' ' && prevAfterKey === ' '){
                beforeStart--;
                afterStart--;
                currentLength++;
            }
        }

        return new Match(beforeStart, afterStart, currentLength, segment);
    }

    function createSegment(beforeTokens, afterTokens, beforeIndex, afterIndex){
        return {
            beforeTokens: beforeTokens,
            afterTokens: afterTokens,
            beforeMap: createMap(beforeTokens),
            afterMap: createMap(afterTokens),
            beforeIndex: beforeIndex,
            afterIndex: afterIndex
        };
    }
    function findMatchingBlocks(segment){
        // Create a binary search tree to hold the matches we find in order.
        var matches = new MatchBinarySearchTree();
        var match;
        var segments = [segment];

        // Each time the best match is found in a segment, zero, one or two new segments may be
        // created from the parts of the original segment not included in the match. We will
        // continue to iterate until all segments have been processed.
        while(segments.length){
            segment = segments.pop();
            match = findBestMatch(segment);

            if (match && match.length){
                // If there's an unmatched area at the start of the segment, create a new segment
                // from that area and throw it into the segments array to get processed.
                if (match.segmentStartInBefore > 0 && match.segmentStartInAfter > 0){
                    var leftBeforeTokens = segment.beforeTokens.slice(
                            0, match.segmentStartInBefore);
                    var leftAfterTokens = segment.afterTokens.slice(0, match.segmentStartInAfter);

                    segments.push(createSegment(leftBeforeTokens, leftAfterTokens,
                            segment.beforeIndex, segment.afterIndex));
                }

                // If there's an unmatched area at the end of the segment, create a new segment from that
                // area and throw it into the segments array to get processed.
                var rightBeforeTokens = segment.beforeTokens.slice(match.segmentEndInBefore + 1);
                var rightAfterTokens = segment.afterTokens.slice(match.segmentEndInAfter + 1);
                var rightBeforeIndex = segment.beforeIndex + match.segmentEndInBefore + 1;
                var rightAfterIndex = segment.afterIndex + match.segmentEndInAfter + 1;

                if (rightBeforeTokens.length && rightAfterTokens.length){
                    segments.push(createSegment(rightBeforeTokens, rightAfterTokens,
                            rightBeforeIndex, rightAfterIndex));
                }

                matches.add(match);
            }
        }

        return matches.toArray();
    }


    function calculateOperations(beforeTokens, afterTokens){
        if (!beforeTokens) throw new Error('Missing beforeTokens');
        if (!afterTokens) throw new Error('Missing afterTokens');

        var positionInBefore = 0;
        var positionInAfter = 0;
        var operations = [];
        var segment = createSegment(beforeTokens, afterTokens, 0, 0);
        var matches = findMatchingBlocks(segment);
        matches.push(new Match(beforeTokens.length, afterTokens.length, 0, segment));

        for (var index = 0; index < matches.length; index++){
            var match = matches[index];
            var actionUpToMatchPositions = 'none';
            if (positionInBefore === match.startInBefore){
                if (positionInAfter !== match.startInAfter){
                    actionUpToMatchPositions = 'insert';
                }
            } else {
                actionUpToMatchPositions = 'delete';
                if (positionInAfter !== match.startInAfter){
                    actionUpToMatchPositions = 'replace';
                }
            }
            if (actionUpToMatchPositions !== 'none'){
                operations.push({
                    action: actionUpToMatchPositions,
                    startInBefore: positionInBefore,
                    endInBefore: (actionUpToMatchPositions !== 'insert' ?
                            match.startInBefore - 1 : null),
                    startInAfter: positionInAfter,
                    endInAfter: (actionUpToMatchPositions !== 'delete' ?
                            match.startInAfter - 1 : null)
                });
            }
            if (match.length !== 0){
                operations.push({
                    action: 'equal',
                    startInBefore: match.startInBefore,
                    endInBefore: match.endInBefore,
                    startInAfter: match.startInAfter,
                    endInAfter: match.endInAfter
                });
            }
            positionInBefore = match.endInBefore + 1;
            positionInAfter = match.endInAfter + 1;
        }

        var postProcessed = [];
        var lastOp = {action: 'none'};

        function isSingleWhitespace(op){
            if (op.action !== 'equal'){
                return false;
            }
            if (op.endInBefore - op.startInBefore !== 0){
                return false;
            }
            return /^\s$/.test(beforeTokens.slice(op.startInBefore, op.endInBefore + 1));
        }

        for (var i = 0; i < operations.length; i++){
            var op = operations[i];

            if ((isSingleWhitespace(op) && lastOp.action === 'replace') ||
                    (op.action === 'replace' && lastOp.action === 'replace')){
                lastOp.endInBefore = op.endInBefore;
                lastOp.endInAfter = op.endInAfter;
            } else {
                postProcessed.push(op);
                lastOp = op;
            }
        }
        return postProcessed;
    }

  
    function TokenWrapper(tokens){
        this.tokens = tokens;
        this.notes = tokens.reduce(function(data, token, index){
            data.notes.push({
                isWrappable: isWrappable(token),
                insertedTag: false
            });

            var tag = !isVoidTag(token) && isTag(token);
            var lastEntry = data.tagStack[data.tagStack.length - 1];
            if (tag){
                if (lastEntry && '/' + lastEntry.tag === tag){
                    data.notes[lastEntry.position].insertedTag = true;
                    data.tagStack.pop();
                } else {
                    data.tagStack.push({
                        tag: tag,
                        position: index
                    });
                }
            }
            return data;
        }, {notes: [], tagStack: []}).notes;
    }

    TokenWrapper.prototype.combine = function(mapFn, tagFn){
        var notes = this.notes;
        var tokens = this.tokens.slice();
        var segments = tokens.reduce(function(data, token, index){
            if (notes[index].insertedTag){
                tokens[index] = tagFn(tokens[index]);
            }
            if (data.status === null){
                data.status = notes[index].isWrappable;
            }
            var status = notes[index].isWrappable;
            if (status !== data.status){
                data.list.push({
                    isWrappable: data.status,
                    tokens: tokens.slice(data.lastIndex, index)
                });
                data.lastIndex = index;
                data.status = status;
            }
            if (index === tokens.length - 1){
                data.list.push({
                    isWrappable: data.status,
                    tokens: tokens.slice(data.lastIndex, index + 1)
                });
            }
            return data;
        }, {list: [], status: null, lastIndex: 0}).list;

        return segments.map(mapFn).join('');
    };

    function wrap(tag, content, opIndex, dataPrefix, className){
        var wrapper = new TokenWrapper(content);
        dataPrefix = dataPrefix ? dataPrefix + '-' : '';
        var attrs = ' data-' + dataPrefix + 'operation-index="' + opIndex + '"';
        if (className){
            attrs += ' class="' + className + '"';
        }

        return wrapper.combine(function(segment){
            if (segment.isWrappable){
                var val = segment.tokens.join('');
                if (val.trim()){
                    return '<' + tag + attrs + '>' + val + '</' + tag + '>';
                }
            } else {
                return segment.tokens.join('');
            }
            return '';
        }, function(openingTag){
            var dataAttrs = ' data-diff-node="' + tag + '"';
            dataAttrs += ' data-' + dataPrefix + 'operation-index="' + opIndex + '"';

            return openingTag.replace(/>\s*$/, dataAttrs + '$&');
        });
    }

    var OPS = {
        'equal': function(op, beforeTokens, afterTokens, opIndex, dataPrefix, className){
            var tokens = afterTokens.slice(op.startInAfter, op.endInAfter + 1);
            return tokens.reduce(function(prev, curr){
                return prev + curr.string;
            }, '');
        },
        'insert': function(op, beforeTokens, afterTokens, opIndex, dataPrefix, className){
            var tokens = afterTokens.slice(op.startInAfter, op.endInAfter + 1);
            var val = tokens.map(function(token){
                return token.string;
            });
            return wrap('ins', val, opIndex, dataPrefix, className);
        },
        'delete': function(op, beforeTokens, afterTokens, opIndex, dataPrefix, className){
            var tokens = beforeTokens.slice(op.startInBefore, op.endInBefore + 1);
            var val = tokens.map(function(token){
                return token.string;
            });
            return wrap('del', val, opIndex, dataPrefix, className);
        },
        'replace': function(){
            return OPS['delete'].apply(null, arguments) + OPS['insert'].apply(null, arguments);
        }
    };

  
    function renderOperations(beforeTokens, afterTokens, operations, dataPrefix, className){
        return operations.reduce(function(rendering, op, index){
            return rendering + OPS[op.action](
                    op, beforeTokens, afterTokens, index, dataPrefix, className);
        }, '');
    }

   
    function diff(before, after, className, dataPrefix){
        if (before === after) return before;

        before = htmlToTokens(before);
        after = htmlToTokens(after);
        var ops = calculateOperations(before, after);
        return renderOperations(before, after, ops, dataPrefix, className);
    }

    diff.htmlToTokens = htmlToTokens;
    diff.findMatchingBlocks = findMatchingBlocks;
    findMatchingBlocks.findBestMatch = findBestMatch;
    findMatchingBlocks.createMap = createMap;
    findMatchingBlocks.createToken = createToken;
    findMatchingBlocks.createSegment = createSegment;
    findMatchingBlocks.getKeyForToken = getKeyForToken;
    diff.calculateOperations = calculateOperations;
    diff.renderOperations = renderOperations;

    if (typeof define === 'function'){
        define([], function(){
          return diff;
        });
    } else if (typeof module !== 'undefined' && module !== null){
        module.exports = diff;
    } else {
        this.htmldiff = diff;
    }
}).call(this);
'use strict';

const fs = require('fs');
const gulp = require('gulp');
const path = require('path');
const glob = require('globule');
const moment = require('moment');
const jsYaml = require('js-yaml');
const wfHelper = require('./wfHelper');
const wfGlossary = require('./wfGlossary');
const runSequence = require('run-sequence');
const wfContributors = require('./wfContributors');
const wfYouTubeShows = require('./wfYouTubeShows');
const wfTemplateHelper = require('./wfTemplateHelper');

gulp.task('build:contributors', function() {
  wfContributors.build();
});

gulp.task('build:announcement', function() {
  const globOpts = {
    srcBase: 'src/content/en/',
    prefixBase: true,
  };
  const dumpYamlOpts = {lineWidth: 1000};
  const projectYamlFiles = glob.find('**/_project.yaml', globOpts);
  const file = 'src/content/en/_wf-announcement.yaml';
  const announcementYaml = jsYaml.safeLoad(fs.readFileSync(file, 'utf8'));
  const startDate = moment(announcementYaml['start']);
  const endDate = moment(announcementYaml['end']);
  const isBetween = moment().isBetween(startDate, endDate);
  projectYamlFiles.forEach((file) => {
    let projYaml = jsYaml.safeLoad(fs.readFileSync(file, 'utf8'));
    if (isBetween) {
      projYaml['announcement'] = announcementYaml;
    } else {
      delete projYaml['announcement'];
    }
    fs.writeFileSync(file, jsYaml.safeDump(projYaml, dumpYamlOpts));
  });
});

gulp.task('build:fundamentals', function() {
  var section = 'fundamentals';
  var baseOutputPath = path.join(GLOBAL.WF.src.content, section);
  var options = {
    title: 'Web Fundamentals',
    description: 'The latest changes to https://developers.google.com/web/fundamentals',
    section: section,
    outputPath: baseOutputPath
  };
  wfGlossary.build();
  var startPath = path.join(GLOBAL.WF.src.content, section);
  var files = wfHelper.getFileList(startPath, ['**/*.md']);
  files.sort(wfHelper.updatedComparator);
  wfTemplateHelper.generateFeeds(files, options);
});

gulp.task('build:showcase', function() {
  var section = 'showcase';
  var baseOutputPath = path.join(GLOBAL.WF.src.content, section);
  var options = {
    title: 'Case Studies',
    description: 'Learn why and how other developers have used the web to create amazing web experiences for their users.',
    section: section,
    outputPath: baseOutputPath
  };
  var startPath = path.join(GLOBAL.WF.src.content, 'showcase');
  var patterns = ['**/*.md', '!tags/*', '!**/index.md'];
  var files = wfHelper.getFileList(startPath, patterns);

  // Generate landing page with featured case studies
  files.sort(wfHelper.featuredComparator);
  options.template = path.join(GLOBAL.WF.src.templates, 'showcase/index.yaml');
  wfTemplateHelper.generateIndex(files, options);

  // Sort case studies by last updated for the rest of the pages
  files.sort(wfHelper.updatedComparator);

  // Generate the listing by region
  options.title = 'Show Cases by Region';
  options.template = path.join(GLOBAL.WF.src.templates, 'showcase/region.md');
  options.outputPath = path.join(baseOutputPath, 'region');
  wfTemplateHelper.generateListPage(files, options);

  // Generate the listing by vertical
  options.title = 'Show Cases by Vertical';
  options.template = path.join(GLOBAL.WF.src.templates, 'showcase/vertical.md');
  options.outputPath = path.join(baseOutputPath, 'vertical');
  wfTemplateHelper.generateListPage(files, options);

  // Generate the listings by tags
  options.title = 'Show Cases by Tag';
  options.outputPath = path.join(baseOutputPath, 'tags');
  wfTemplateHelper.generateTagPages(files, options);

  // Generate the listings by Year
  options.template = null;
  var filesByYear = wfHelper.splitByYear(files);
  Object.keys(filesByYear).forEach(function(year) {
    options.year = year;
    options.outputPath = path.join(baseOutputPath, year);
    options.title = 'Show Cases (' + year + ')';
    wfTemplateHelper.generateListPage(filesByYear[year], options);
    options.title = year;
    wfTemplateHelper.generateTOCbyMonth(filesByYear[year], options);
  });

  // Generate the RSS & ATOM feeds
  options.outputPath = baseOutputPath;
  wfTemplateHelper.generateFeeds(files, options);
});

gulp.task('build:shows', function(cb) {
  wfYouTubeShows.buildFeeds(GLOBAL.WF.options.buildType, cb);
});

gulp.task('build:http203Podcast', function() {
  var src = 'shows/http203/podcast/';
  var baseOutputPath = path.join(GLOBAL.WF.src.content, src);
  var options = {
    title: 'HTTP 203',
    subtitle: 'Where Surma and Jake occasionally talk web.',
    author: {name: 'Surma & Jake', email: 'jaffathecake@gmail.com'},
    summary: 'Surma and Jake talk about whatever\'s going on in the world of web development.',
    image: 'https://developers.google.com/web/shows/http203/podcast/images/surma-and-jake-2.jpg',
    section: 'shows',
    outputPath: baseOutputPath,
    baseUrl: 'https://developers.google.com/web/shows/http203/podcast/'
  };
  var files = wfHelper.getFileList(baseOutputPath, ['*.md', '!index.md']);
  files.sort(wfHelper.updatedComparator);
  wfTemplateHelper.generateListPage(files, options);
  wfTemplateHelper.generatePodcastFeed(files, options);
});

gulp.task('build:DVDPodcast', function() {
  var src = 'shows/designer-vs-developer/podcast/';
  var baseOutputPath = path.join(GLOBAL.WF.src.content, src);
  var options = {
    title: 'Designer Vs Developer',
    subtitle: 'A show that tries to solve the challenges faced in industry by having an open conversation between the two.',
    author: {name: 'Mustafa Kurtuldu', email: 'mustafa.kurtuldu@gmail.com'},
    summary: 'A show that tries to solve the challenges faced in industry by having an open conversation between the two.',
    image: 'https://developers.google.com/web/shows/designer-vs-developer/podcast/images/dvd-series-cover-large.jpg',
    section: 'shows',
    outputPath: baseOutputPath,
    baseUrl: 'https://developers.google.com/web/shows/designer-vs-developer/podcast/'
  };
  var files = wfHelper.getFileList(baseOutputPath, ['*.md', '!index.md']);
  files.sort(wfHelper.updatedComparator);
  wfTemplateHelper.generateListPage(files, options);
  wfTemplateHelper.generatePodcastFeed(files, options);
});

gulp.task('build:tools', function() {
  var section = 'tools';
  var baseOutputPath = path.join(GLOBAL.WF.src.content, section);
  var options = {
    title: 'Tools',
    description: 'The latest changes to https://developers.google.com/web/tools',
    section: section,
    outputPath: baseOutputPath
  };
  var startPath = path.join(GLOBAL.WF.src.content, section);
  var files = wfHelper.getFileList(startPath, ['**/*.md']);
  files.sort(wfHelper.updatedComparator);
  wfTemplateHelper.generateFeeds(files, options);
});

gulp.task('build:updates', function() {
  var section = 'updates';
  var baseOutputPath = path.join(GLOBAL.WF.src.content, section);
  var options = {
    title: 'Updates',
    description: 'The latest and freshest updates from the Web teams at Google. Chrome, V8, tooling, and more.',
    section: section,
    outputPath: baseOutputPath
  };
  var startPath = path.join(GLOBAL.WF.src.content, section);
  var patterns = ['**/*.md', '!tags/*', '!**/index.md'];
  var files = wfHelper.getFileList(startPath, patterns);
  files.sort(wfHelper.publishedComparator);
  wfTemplateHelper.generateIndex(files, options);
  wfTemplateHelper.generateFeeds(files, options);
  options.outputPath = path.join(baseOutputPath, 'tags');
  wfTemplateHelper.generateTagPages(files, options);
  var filesByYear = wfHelper.splitByYear(files);
  Object.keys(filesByYear).forEach(function(year) {
    options.outputPath = path.join(baseOutputPath, year);
    options.year = year;
    options.title = 'Web Updates (' + year + ')';
    wfTemplateHelper.generateListPage(filesByYear[year], options);
    options.title = year;
    wfTemplateHelper.generateTOCbyMonth(filesByYear[year], options);
  });
  options = {
    outputPath: GLOBAL.WF.src.content,
    articlesToShow: 4
  }
  wfTemplateHelper.generateLatestWidget(files, options);
});

gulp.task('build', function(cb) {
  runSequence(
    [
      'build:announcement',
      'build:contributors',
      'build:fundamentals',
      'build:showcase',
      'build:shows',
      'build:http203Podcast',
      'build:DVDPodcast',
      'build:tools',
      'build:updates'
    ],
    cb);
});
use strict';

const gulp = require('gulp');
const path = require('path');
const glob = require('globule');
const wfHelper = require('./wfHelper');
const wfCodeLabHelper = require('./wfCodeLabHelper');

/**
 * Update the files using the claat tool then return a list of files
 *
 * @param {string} srcPath Where to run the claat tool.
 * @return {Promise} The promise with the list of all files updated.
 */
function getCLAATFiles(srcPath) {
  let cmd = '../../../tools/claat update';
  return new Promise(function(resolve, reject) {
    wfHelper.promisedExec(cmd, srcPath)
    .then(function() {
      let opts = {
        srcBase: srcPath,
        prefixBase: true
      };
      let files = glob.find('**/index.md', opts);
      resolve(files);
    });
  });
}

/**
 * Updates files, and copies them to the appropriate directory
 *
 * @param {string} srcPath The source directory to find the files.
 * @param {string} destBase The destination to copy to.
 * @param {Boolean} flatten Whether to flatten the files to one directory.
 * @param {string} bookPath The location of the book.yaml file
 * @param {string} projPath The location of the project.yaml file
 * @return {Promise} The promise that will be resolved on completion.
 */
function exportAndUpdate(srcPath, destBase, flatten, bookPath, projPath) {
  return getCLAATFiles(srcPath)
  .then(function(files) {
    return Promise.all(files.map(function(file) {
      let srcFile = file;
      let srcImgPath = file.replace('index.md', 'img/');
      let destDir = file.replace(srcPath, '').replace('/index.md', '');
      destDir = path.join(destBase, destDir);
      let destFile = path.join(destDir, 'index.md');
      if (flatten === true) {
        destDir = path.resolve(destDir, '..');
        destFile = destFile.replace('/index.md', '.md');
      }
      let destImgPath = path.join(destDir, 'img');
      wfCodeLabHelper.updateCodeLab(srcFile, destFile, bookPath, projPath);
      return wfHelper.promisedRSync(srcImgPath, destImgPath);
    }));
  });
}

gulp.task('claat:codelabs', function() {
  const srcPath = 'src/data/codelabs';
  const destPath = path.join(GLOBAL.WF.src.content, 'fundamentals/codelabs');
  const bookPath = '/web/fundamentals/_book.yaml';
  const projPath = '/web/fundamentals/_project.yaml';
  return exportAndUpdate(srcPath, destPath, false, bookPath, projPath);
});

gulp.task('claat:ilt-pwa', function() {
  const srcPath = 'src/data/ilt-pwa';
  const destPath = path.join(GLOBAL.WF.src.content, 'ilt/pwa');
  const bookPath = '/web/ilt/pwa/_book.yaml';
  const projPath = '/web/_project.yaml';
  return exportAndUpdate(srcPath, destPath, true, bookPath, projPath);
});
const gulp = require('gulp');
const remoteGitTags = require('remote-git-tags');
const semver = require('semver');
const fse = require('fs-extra');
const path = require('path');
const os = require('os');
const spawn = require('child_process').spawn;
const glob = require('glob');

const PREVIOUS_RELEASES = 2;

const getLatestTags = (gitUrl) => {
  return remoteGitTags(gitUrl)
  .then((gitTagsMap) => Array.from(gitTagsMap.keys()))
  .then((allGitTags) => {
    allGitTags.sort(semver.rcompare);
    return allGitTags.splice(0, PREVIOUS_RELEASES);
  });
};

const getSourceCode = (gitUrl, tag, tmpPath) => {
  fse.ensureDirSync(tmpPath);

  return new Promise((resolve, reject) => {
    const gitDownload = spawn('git', [
      'clone',
      '--branch', tag,
      '--depth', '1',
      '--config', 'advice.detachedHead=false',
      gitUrl,
      tmpPath,
    ], {
      stdio: 'inherit',
    });

    gitDownload.on('error', (err) => {
      console.error(`\n\nUnable to retrieve tag '${tag}' from Git.`);
      console.error(err);
      reject(`Unable to retrieve tag '${tag}' from Git.`);
    });

    gitDownload.on('close', (code) => {
      if (code === 0) {
        resolve(tmpPath);
      } else {
        reject(`Error ${code} returned by command: 'git ${params.join(' ')}'`);
      }
    });
  });
};

const buildJSDocs = (srcCodePath, docOutputPath, jsdocConfPath) => {
  console.log(`\n\n    Building JSDocs to '${path.relative(process.cwd(), docOutputPath)}'.`);

  try {
    fse.accessSync(jsdocConfPath, fse.F_OK);
  } catch (err) {
    console.warn(`Unable to find jsdoc Config File @ '${jsdocConfPath}'`);
    console.warn(err);
    return;
  }

  const contentPath = path.join(__dirname, '..', 'src', 'content', 'en');
  const templateBasePath = path.join(
    path.posix.sep,
    'web',
    path.relative(contentPath, docOutputPath)
  );
  console.log(`\n\n    Using JSDoc basepath=${templateBasePath}.`);

  const jsdocConfigContents = fse.readFileSync(jsdocConfPath);
  const jsdocConfig = JSON.parse(jsdocConfigContents);
  if (!jsdocConfig.webFundamentals) {
    console.warn(`In your JSDoc config file you MUST provide a 'webFundamentals' property with:`);
    console.warn(`    projectRoot`);
    console.warn(`    productName`);
    return;
  }

  const queryString = [
    `projectRoot=${jsdocConfig.webFundamentals.projectRoot}`,
    `basepath=${templateBasePath}`,
    `productName=${jsdocConfig.webFundamentals.productName}`,
  ].join('&');
  console.log(`    QueryString: '--query ${queryString}'`);

  const jsDocParams = [
    '--template', path.join(
      __dirname, '..', 'src', 'templates', 'reference-docs', 'jsdoc'
    ),
    '-c', jsdocConfPath,
    '-d', docOutputPath,
    '--query', queryString,
  ];

  const jsdocPath = path.join(__dirname, '..', 'node_modules', 'jsdoc', 'jsdoc.js');

  return new Promise((resolve, reject) => {
    const jsdocProcess = spawn(jsdocPath, jsDocParams, {
      cwd: srcCodePath,
      stdio: 'inherit',
    });

    jsdocProcess.on('error', (err) => {
      console.error('\n\nUnable to run jsdoc.');
      console.error(err);
    });

    jsdocProcess.on('close', (code) => {
      if (code === 0) {
        resolve(docOutputPath);
      } else {
        reject(`Error code: ${code}`);
      }
    });
  })
  .then((docOutputPath) => {
    // jsdoc-baseline copies over these files for it's own template
    // but we don't use them for devsite - so remove these files.
    fse.removeSync(path.join(docOutputPath, 'css'));
    fse.removeSync(path.join(docOutputPath, 'scripts'));

    return docOutputPath;
  })
  .then((docOutputPath) => {
    // Web Fundamentals linting errors on developers.google.com
    const allFiles = glob.sync(path.join(docOutputPath, '**', '*'), {
      absolute: true,
    });
    allFiles.forEach((filePath) => {
      const fileContents = fse.readFileSync(filePath).toString();
      const cleanContents = fileContents
        .split('https://developers.google.com/').join('/');
      fse.writeFileSync(filePath, cleanContents);
    });

    return docOutputPath;
  })
  .catch((err) => {
    // If we error'd, make sure we didn't create a directory that will stop
    // future doc builds.
    fse.removeSync(docOutputPath);

    console.error(`\n\nUnable to build docs for: '${path.relative(process.cwd(), docOutputPath)}'`);
    console.error(err);

    return null;
  });
};

const generateRefDocs = (projectName, gitUrl, docPath, tag, jsdocConfPath, isLatest) => {
  // 1. Check if current tag exists, if so return
  const outputPath = path.join(docPath, tag);
  if (fse.pathExistsSync(outputPath)) {
    return;
  }

  console.log(`\n\nNeed to build docs for '${projectName}: ${tag}'`);

  const tmpDirectory = path.join(os.tmpdir(), Date.now().toString());
  const tmpSrCodePath = path.join(tmpDirectory, tag);
  return getSourceCode(gitUrl, tag, tmpSrCodePath)
  .then(() => {
    return buildJSDocs(tmpSrCodePath, outputPath, jsdocConfPath);
  })
  .then(() => {
    if (isLatest) {
      const outputPath = path.join(docPath, 'latest');
      return buildJSDocs(tmpSrCodePath, outputPath, jsdocConfPath);
    }
  })
  .then(() => {
    fse.removeSync(tmpDirectory);
  }, (err) => {
    fse.removeSync(tmpDirectory);
    throw err;
  });
};

const buildReferenceDocs = (projectName, gitUrl, localPath, jsdocConfPath) => {
  return getLatestTags(gitUrl)
  .then((latestGitTags) => {
    return latestGitTags.reduce(
      (promiseChain, tag) => {
        return promiseChain.then(() => {
          return generateRefDocs(
            projectName,
            gitUrl,
            localPath,
            tag,
            jsdocConfPath,
            tag === latestGitTags[0]
          );
        });
      }, Promise.resolve()
    );
  });
};

gulp.task('reference-docs:workbox', () => {
  return buildReferenceDocs(
    'Workbox',
    'https://github.com/GoogleChrome/workbox.git',
    path.join(__dirname, '..', 'src/content/en/tools/workbox/reference-docs/'),
    path.join(__dirname, '..', 'src/content/en/tools/workbox/_jsdoc.conf')
  );
});

'use strict';

const fs = require('fs');
const path = require('path');
const gulp = require('gulp');
const chalk = require('chalk');
const vfile = require('vfile');
const glob = require('globule');
const moment = require('moment');
const remark = require('remark');
const jsYaml = require('js-yaml');
const gutil = require('gulp-util');
const wfRegEx = require('./wfRegEx');
const wfHelper = require('./wfHelper');
const parseDiff = require('parse-diff');
const remarkLint = require('remark-lint');
const runSequence = require('run-sequence');
const jsonValidator = require('jsonschema').Validator;

/******************************************************************************
 * Constants & Remark Lint Options
 *****************************************************************************/

const MAX_DESCRIPTION_LENGTH = 485;
const MAX_FILE_SIZE_WARN = 500;   // Max file size (in kB) before warning
const MAX_FILE_SIZE_ERROR = 2500; // Max file size (in kB) before error
const MD_FILES = ['.md', '.mdown', '.markdown'];
const EXTENSIONS_TO_SKIP = ['.css', '.vtt', '.xml'];
const MEDIA_FILES = [
  '.gif', '.ico', '.jpg', '.png', '.psd', '.svg',
  '.mov', '.mp3', '.mp4', '.webm',
  '.pdf',
];
const VALID_DATE_FORMATS = [
  'YYYY-MM-DD',
  'YYYY-MM-DDTHH:mm:ssZ',
  'YYYY-MM-DDTHH:mm:ss.sssZ'
];
const REMARK_WARNING_ONLY = [
  'maximum-line-length',
  'code-block-style',
  'heading-style'
];
const RE_SRC_BASE = /src\/content\//;
const RE_DATA_BASE = /src\/data\//;
const COMMON_TAGS_FILE = 'src/data/commonTags.json';
const CONTRIBUTORS_FILE = 'src/data/_contributors.yaml';
const BLINK_COMPONENTS_FILE = 'src/data/blinkComponents.json';
const VALID_REGIONS = [
  'africa', 'asia', 'europe', 'middle-east', 'north-america', 'south-america'
];
const VALID_VERTICALS = [
  'education', 'entertainment', 'media', 'real-estate', 'retail',
  'transportation', 'travel'
];
const PAGE_TYPES = {
  LANDING: 'landing',
  ARTICLE: 'article',
};
const IS_TRAVIS = process.env.TRAVIS === 'true';
const IS_TRAVIS_PUSH = process.env.TRAVIS_EVENT_TYPE === 'push';
const IS_TRAVIS_ON_MASTER = process.env.TRAVIS_BRANCH === 'master';
const TRAVIS_BRANCH = process.env.TRAVIS_BRANCH;
const TRAVIS_EVENT_TYPE = process.env.TRAVIS_EVENT_TYPE;

let remarkLintOptions = {
  external: [
    './gulp-tasks/remark-lint-tests/check-links.js',
    './gulp-tasks/remark-lint-tests/check-headings.js',
    './gulp-tasks/remark-lint-tests/check-html',
    './gulp-tasks/remark-lint-tests/check-images',
  ],

  /* from check-links.js */
  wfLinksDGC: true,
  wfLinksInternal: true,
  wfLinksForcedLang: true,
  wfLinksUnsafeShort: true,

  /* from check-headings.js */
  wfHeadingsTldr: true,
  wfHeadingsBlank: true,
  wfHeadingsInMarkdown: true,
  wfHeadingsNoMarkupInTitle: true,

  /* from check-html.js */
  wfHtmlYouTube: true,
  wfHtmlDgcLinks: true,
  wfHtmlLinkForcedLang: true,
  wfHtmlInternalLinks: true,
  wfHtmlUnsafeShortLinks: true,

  /* from check-images.js */
  wfImagesMd: false,
  wfImagesHtml: false,

  /* from remark */
  firstHeadingLevel: 1,
  headingStyle: 'atx',
  maximumHeadingLength: false,
  maximumLineLength: false,
  noDuplicateDefinitions: true,
  noDuplicateHeadingsInSection: false,
  noEmphasisAsHeading: false,
  noEmptyLinkURL: true,
  noMultipleToplevelHeadings: true,
  noUnusedDefinitions: false,
};


let filesTested = 0;
let allErrors = [];
let allWarnings = [];
let filesWithIssues = {};
tion logMessage(level, filename, position, message, extra) {
  let logMsg = {
    filename: filename,
    position: position,
    message: message,
    extra: extra
  }
  let fileLoc = chalk.cyan(filename);
  level = level.toUpperCase();
  if (position && position.line) {
    fileLoc += chalk.gray('#') + chalk.cyan(position.line);
  }
  if (level === 'ERROR') {
    gutil.log(chalk.red('ERROR:'), fileLoc, message);
    allErrors.push(logMsg);
  } else {
    gutil.log(chalk.yellow('WARNING:'), fileLoc, message);
    allWarnings.push(logMsg);
  }
  if (GLOBAL.WF.options.verbose && extra) {
    console.log(extra);
  }
  filesWithIssues[filename] = true;
}


function logError(filename, position, message, extra) {
  if (GLOBAL.WF.options.testWarnOnly) {
    logWarning(filename, position, message, extra);
    return;
  }
  logMessage('ERROR', filename, position, message, extra);
}


function logWarning(filename, position, message, extra) {
  logMessage('WARNING', filename, position, message, extra);
}


function printSummary() {
  var cFilesWithIssues = Object.keys(filesWithIssues).length;
  gutil.log('');
  gutil.log('Test Completed.');
  gutil.log('Files tested:  ', chalk.cyan(filesTested));
  gutil.log(' - with issues:', chalk.yellow(cFilesWithIssues));
  gutil.log('Errors  : ', chalk.red(allErrors.length));
  gutil.log('Warnings: ', chalk.yellow(allWarnings.length));
  if (IS_TRAVIS) {
    let result = {
      summary: {
        filesTested: filesTested,
        filesWithIssues: cFilesWithIssues,
      },
      errors: allErrors,
      warnings: allWarnings
    };
    result = JSON.stringify(result, null, 2);
    fs.writeFileSync('./test-results.json', result, 'utf8');
  }
}


function throwIfFailed() {
  if (allErrors.length >= 1 && !GLOBAL.WF.options.testWarnOnly) {
    let errorMessage = `There were ${allErrors.length} errors.`;
    throw new Error(errorMessage);
  }
}

function getLineNumber(content, idx) {
  var subStr = content.substring(0, idx);
  var lineNum = subStr.split(/\r\n|\r|\n/).length;
  return lineNum;
}


function readFile(filename) {
  try {
    let contents = fs.readFileSync(filename, 'utf8');
    return contents;
  } catch (ex) {
    logWarning(filename, null, 'Unable to read file, was it deleted?', ex);
    return null;
  }
}

function doesFileExist(filename) {
  if (!filename) {
    return false;
  }
  filename = filename.trim();
  filename = filename.replace(/^\/?web\/(.*)/, 'src/content/en/$1');
  try {
    fs.accessSync(filename, fs.R_OK);
    return true;
  } catch (ex) {
    return false;
  }
}


function parseJSON(filename, contents) {
  try {
    return JSON.parse(contents);
  } catch (ex) {
    let msg = `Unable to parse JSON: ${ex.message}`;
    logError(filename, null, msg, ex);
  }
  return null;
}

return {Object} The parsed YAML object

function parseYAML(filename, contents) {
  try {
    return jsYaml.safeLoad(contents);
  } catch (ex) {
    let msg = 'Unable to parse YAML';
    if (ex.reason) {
      msg = ex.reason;
    }
    let position = ex.mark;
    if (position && position.line) {
      position.line++;
    }
    logError(filename, position, msg, ex);
  }
  return null;
}

tion getFiles() {
  if (GLOBAL.WF.options.testPath || GLOBAL.WF.options.testAll) {
    return new Promise(function(resolve, reject) {
      let globs = [];
      let opts = {
        prefixBase: true,
        filter: 'isFile'
      };
      if (GLOBAL.WF.options.testPath) {
        gutil.log(' ', 'Searching for files in', chalk.cyan(GLOBAL.WF.options.testPath));
        opts.srcBase = GLOBAL.WF.options.testPath;
        globs.push('**/*');
      } else {
        opts.srcBase = './src/content';
        GLOBAL.WF.options.lang.forEach(function(lang) {
          gutil.log(' ', 'Searching for files in', chalk.cyan(`${opts.srcBase}/${lang}`));
          globs.push(`${lang}/**/*`);
        });
      }
      resolve(glob.find(globs, opts));
    });
  } else {
    gutil.log(' ', 'Searching for changed files');
    let cmd = 'git --no-pager diff --name-only ';
    if (IS_TRAVIS) {
      cmd += '$(git merge-base FETCH_HEAD master) FETCH_HEAD';
    } else {
      cmd += '$(git merge-base master HEAD)';
    }
    return wfHelper.promisedExec(cmd, '.')
    .then(function(results) {
      let files = [];
      results.split('\n').forEach(function(filename) {
        if (RE_SRC_BASE.test(filename) ||
            RE_DATA_BASE.test(filename) ||
            filename === 'app.yaml') {
              files.push(filename);
        }
      });
      return files;
    });
  }
}

function testMarkdown(filename, contents, options) {
  return new Promise(function(resolve, reject) {

    let msg;
    let matched;
    let position;
    let isInclude = wfRegEx.RE_MD_INCLUDE.test(contents);

    if (wfRegEx.RE_DEVSITE_TRANSLATION.test(contents)) {
      options.enforceLineLengths = false;
      options.lastUpdateMaxDays = null;
    }

    let pageType = PAGE_TYPES.ARTICLE;
    if (/page_type: landing/.test(contents)) {
      pageType = PAGE_TYPES.LANDING;
    }

    // Verify there are no dots in the filename
    let numDots = filename.split('.');
    if (numDots.length !== 2) {
      logError(filename, null, 'Filename or path should not contain dots.');
    }

    // Verify extension on file is .md
    if (path.extname(filename.toLowerCase()) !== '.md') {
      logError(filename, null, 'File extension must be `.md`');
    }

    // Validate book_path is specified and file exists
    const bookPath = wfRegEx.RE_BOOK_PATH.exec(contents);
    if (!bookPath && !isInclude) {
      msg = 'Attribute `book_path` missing from top of document';
      logError(filename, null, msg);
    }
    if (bookPath && bookPath[1] && !isInclude) {
      msg = 'Unable to find specified `book_path`:'
      if (doesFileExist(bookPath[1]) !== true) {
        logError(filename, null, `${msg} ${bookPath[1]}`);
      }
    }

    // Validate project_path is specified and file exists
    const projectPath = wfRegEx.RE_PROJECT_PATH.exec(contents);
    if (!projectPath && !isInclude) {
      msg = 'Attribute `project_path` missing from top of document';
      logError(filename, null, msg);
    }
    if (projectPath && projectPath[1] && !isInclude) {
      msg = 'Unable to find specified `project_path`:'
      if (doesFileExist(projectPath[1]) !== true) {
        logError(filename, null, `${msg} ${projectPath[1]}`);
      }
    }

    // Validate description
    matched = wfRegEx.RE_DESCRIPTION.exec(contents);
    if (matched) {
      let description = matched[1].trim();
      position = {line: getLineNumber(contents, matched.index)};
      if (isInclude) {
        msg = 'Included files should not include `description` tags.';
        logError(filename, position, msg);
      }
      if (description.length === 0) {
        msg = 'Attribute `description` cannot be empty';
        logError(filename, position, msg);
      } else if (description.length > MAX_DESCRIPTION_LENGTH) {
        msg = `Attribute \`description\` cannot exceed ${MAX_DESCRIPTION_LENGTH}`;
        msg += ` characters, was: ${description.length}`;
        logError(filename, position, msg);
      }
      if (description.indexOf('<') >= 0 || description.indexOf('`') >= 0) {
        msg = 'Attribute `description` cannot contain HTML or markdown, ';
        msg += `found: ${description}`;
        logError(filename, position, msg);
      }
    }

    // Validate wf_updated
    matched = wfRegEx.RE_UPDATED_ON.exec(contents);
    if (!isInclude) {
      if (!matched) {
        msg = 'WF Tag `wf_updated_on` is missing (YYYY-MM-DD)';
        logError(filename, null, msg);
      } else {
        position = {line: getLineNumber(contents, matched.index)};
        let d = moment(matched[1], VALID_DATE_FORMATS, true);
        if (d.isValid() === false) {
          msg = 'WF Tag `wf_updated_on` invalid format (YYYY-MM-DD)';
          msg += `, found: ${matched[1]}`;
          logError(filename, position, msg);
        } else if (options.lastUpdateMaxDays) {
          if (d.isBefore(moment().subtract(options.lastUpdateMaxDays, 'days'))) {
            msg = 'WF Tag `wf_updated_on` must be within the last ';
            msg += options.lastUpdateMaxDays + ' days.';
            logWarning(filename, position, msg);
          }
        }
      }
    }

    // Validate wf_published
    matched = wfRegEx.RE_PUBLISHED_ON.exec(contents);
    if (!isInclude) {
      if (!matched) {
        msg = 'WF Tag `wf_published_on` is missing (YYYY-MM-DD)';
        logError(filename, null, msg);
      } else {
        position = {line: getLineNumber(contents, matched.index)};
        let d = moment(matched[1], VALID_DATE_FORMATS, true);
        if (d.isValid() === false) {
          msg = 'WF Tag `wf_published_on` invalid format (YYYY-MM-DD)';
          msg += `, found: ${matched[1]}`;
          logError(filename, position, msg);
        }
      }
    }

    // Validate featured image path
    matched = wfRegEx.RE_IMAGE.exec(contents);
    if (matched) {
      if (doesFileExist(matched[1]) !== true) {
        position = {line: getLineNumber(contents, matched.index)};
        msg = 'WF Tag `wf_featured_image` found, but couldn\'t find ';
        msg += `image - ${matched[1]}`;
        logError(filename, position, msg);
      }
    }

    // Validate featured square image path
    matched = wfRegEx.RE_IMAGE_SQUARE.exec(contents);
    if (matched) {
      if (doesFileExist(matched[1]) !== true) {
        position = {line: getLineNumber(contents, matched.index)};
        msg = 'WF Tag `wf_featured_image_square` found, but couldn\'t find ';
        msg += `image - ${matched[1]}`;
        logError(filename, position, msg);
      }
    }

    // Check for uncommon tags
    matched = wfRegEx.RE_TAGS.exec(contents);
    if (matched && options.commonTags) {
      position = {line: getLineNumber(contents, matched.index)};
      matched[1].split(',').forEach(function(tag) {
        tag = tag.trim();
        if (options.commonTags.indexOf(tag) === -1) {
          msg = `Uncommon tag (\`${tag}\`) found.`;
          logWarning(filename, position, msg);
        }
      });
    }

    // Check for valid Blink components
    matched = wfRegEx.RE_BLINK_COMPONENTS.exec(contents);
    if (matched && options.blinkComponents) {
      position = {line: getLineNumber(contents, matched.index)};
      matched[1].split(',').forEach(function(component) {
        component = component.trim();
        if (options.blinkComponents.indexOf(component) === -1) {
          msg = `The component (\`${component}\`) is non-standard or misspelled.`
          logError(filename, position, msg);
        }
      })
    } else {
      msg = 'No `wf_blink_components` field found in metadata. Add if appropriate.';
      logWarning(filename, '', msg);
    }

    // Check for valid regions
    matched = wfRegEx.RE_REGION.exec(contents);
    if (matched) {
      let region = matched[1];
      if (VALID_REGIONS.indexOf(region) === -1) {
        position = {line: getLineNumber(contents, matched.index)};
        msg = 'Invalid `wf_region` (' + region + ') provided.';
        logError(filename, position, msg);
      }
    }

    // Check for valid verticals
    matched = wfRegEx.RE_VERTICAL.exec(contents);
    if (matched) {
      let vertical = matched[1];
      if (VALID_VERTICALS.indexOf(vertical) === -1) {
        position = {line: getLineNumber(contents, matched.index)};
        msg = 'Invalid `wf_vertical` (' + vertical + ') provided.';
        logError(filename, position, msg);
      }
    }

    // Check for a single level 1 heading with page title
    matched = wfRegEx.RE_TITLE.exec(contents);
    if (pageType === PAGE_TYPES.ARTICLE && !matched && !isInclude) {
      msg = 'Page is missing page title eg: `# TITLE {: .page-title }`';
      logError(filename, null, msg);
    }
    if (matched && isInclude) {
      msg = 'Include file should not contain a page title!';
      position = {line: getLineNumber(matched.index)};
      logError(filename, position, msg);
    }

    // Check for only a single instance of the {: .page-title } class
    matched = wfRegEx.getMatches(wfRegEx.RE_TITLE_CLASS, contents);
    msg = 'Page can only contain ONE title class `{: .page-title }`';
    let maxMatches = 1;
    if (isInclude) {
      msg = 'Includes should not contain any `{: .page-title }` classes.';
      maxMatches = 0;
    }
    if (matched.length > maxMatches) {
      matched.forEach(function(match) {
        position = {line: getLineNumber(contents, match.index)};
        logError(filename, position, msg);
      });
    }

    // Verify authors/translators are in the contributors file
    if (options.contributors) {
      matched = wfRegEx.getMatches(wfRegEx.RE_AUTHOR_LIST, contents);
      matched.forEach(function(match) {
        let key = match[1];
        if (!options.contributors[key]) {
          position = {line: getLineNumber(contents, match.index)};
          msg = `Unable to find contributor (\`${key}\`) in contributors file.`;
          logError(filename, position, msg);
        }
      });
    }

    // Verify all includes start with web/
    matched = wfRegEx.getMatches(wfRegEx.RE_INCLUDES, contents);
    matched.forEach(function(include) {
      let inclFile = include[1];
      if (inclFile === 'comment-widget.html' ||
          inclFile.indexOf('web/_shared/contributors/') === 0 ||
          inclFile.indexOf('web/_shared/latest_show.html') === 0) {
        return;
      }
      position = {line: getLineNumber(contents, include.index)};
      if (inclFile.indexOf('web/') !== 0) {
        msg = `Include path MUST start with \`web/\` - ${inclFile}`;
        logError(filename, position, msg);
      }
      if (doesFileExist(inclFile) !== true) {
        msg = '`{% include %}` tag found, but couldn\'t find related include'
        logError(filename, position, `${msg}: ${inclFile}`);
      }
    });

    // Verify all {% includecode %} elements work properly
    matched = wfRegEx.getMatches(wfRegEx.RE_INCLUDE_CODE, contents);
    matched.forEach(function(match) {
      const msg = 'IncludeCode widget -';
      const widget = match[0];
      const position = {line: getLineNumber(contents, match.index)};
      const inclFile = wfRegEx.getMatch(wfRegEx.RE_INCLUDE_CODE_PATH, widget, null);
      if (inclFile.indexOf('web/') !== 0) {
        logError(filename, position, `${msg} path must start with 'web/'`);
      }
      if (doesFileExist(inclFile) !== true) {
        logError(filename, position, `${msg} file not found: '${inclFile}'`);
      }
    });

    // Verify all <<include.md>> markdown files are accessible
    matched = wfRegEx.getMatches(wfRegEx.RE_INCLUDE_MD, contents);
    matched.forEach(function(match) {
      let inclFile = path.resolve(path.parse(filename).dir, match[1]);
      if (doesFileExist(inclFile) !== true) {
        position = {line: getLineNumber(contents, match.index)};
        msg = `Markdown include ${match[0]} found, but couldn't find file.`;
        logError(filename, position, msg);
      }
    });

    // Error on single line comments
    matched = wfRegEx.getMatches(wfRegEx.RE_SINGLE_LINE_COMMENT, contents);
    matched.forEach(function(match) {
      position = {line: getLineNumber(contents, match.index)};
      msg = 'Multi-line comment syntax used on single line comment.';
      msg += ' Use single line syntax: `{# this is my comment #}`';
      logError(filename, position, msg);
    });

    // Warn on unescaped template tags
    matched = wfRegEx.getMatches(/\{\{/g, contents);
    matched.forEach(function(match) {
      position = {line: getLineNumber(contents, match.index)};
      msg = 'Template tags (`{{`) should be escaped to `&#123;&#123;`';
      logError(filename, position, msg);
    });

    // Error on bad anchor tags
    matched = wfRegEx.getMatches(/{#\w+}/gm, contents);
    matched.forEach(function(match) {
      position = {line: getLineNumber(contents, match.index)};
      msg = 'Unsupported anchor style used, use `{: #anchor }`, found: ';
      msg += `\`${match[0]}\``;
      logError(filename, position, msg);
    });

    // Error on script blocks in markdown
    matched = wfRegEx.getMatches(/<script/gm, contents);
    matched.forEach(function(match) {
      position = {line: getLineNumber(contents, match.index)};
      msg = `'<script> tags are generally not allowed, please double check.`;
      logWarning(filename, position, msg);
    });

    // Warn on missing comment widgets
    let reComment = /^{%\s?include "comment-widget\.html"\s?%}/m;
    let reUpdatesPath = /src\/content\/.+?\/updates\/\d{4}\//;
    if (reUpdatesPath.test(filename)) {
      if (!reComment.test(contents)) {
        position = {line: getLineNumber(contents, contents.length -1)};
        msg = 'Updates post is missing comment widget: '
        msg += '`{% include "comment-widget.html" %}`';
        logWarning(filename, position, msg);
      }
    }

    remarkLintOptions.firstHeadingLevel = 1;
    if (isInclude) {
      remarkLintOptions.firstHeadingLevel = 2;
    }
    if (pageType === PAGE_TYPES.LANDING) {
      remarkLintOptions.firstHeadingLevel = 2;
    }
    remarkLintOptions.maximumLineLength = false;
    if (options.enforceLineLengths) {
      remarkLintOptions.maximumLineLength = 100;
      contents = contents.replace(wfRegEx.RE_DESCRIPTION, '\n');
      contents = contents.replace(wfRegEx.RE_SNIPPET, '\n\n');
    }

    // Use remark to lint the markdown
    let vFile = vfile({path: filename, extname: '.md', contents: contents});
    remark()
    .use(remarkLint, remarkLintOptions)
    .process(vFile, function(err, vFileResult) {
      if (err) {
        msg = `Critical linting error: ${err.message}`;
        logError(filename, null, msg, err);
      }
      if (vFileResult) {
        vFileResult.messages.forEach(function(vMsg) {
          let position = {
            line: vMsg.line,
            column: vMsg.column
          };
          if (REMARK_WARNING_ONLY.indexOf(vMsg.ruleId) >= 0) {
            logWarning(filename, position, vMsg.message, vMsg);
          } else {
            logError(filename, position, vMsg.message, vMsg);
          }
        });
      }
      resolve(true);
    });
  })
  .catch(function(ex) {
    let msg = `An exception occurred in testMarkdown: ${ex}`;
    logError(filename, null, msg, ex);
    return false;
  });
}


function testYAML(filename, contents) {
  return new Promise(function(resolve, reject) {
    parseYAML(filename, contents);
    resolve(true);
  })
  .catch(function(ex) {
    let msg = `An exception occurred in testYAML: ${ex}`;
    logError(filename, null, msg, ex);
    return false;
  });
}

/**
 * Tests a JSON file
 *   Note: The returned promise always resolves, it will never reject.
 *
 * @param {string} filename The name of the file to be tested
 * @param {string} contents The contents of the file to be tested
 * @return {Promise} A promise that resolves with TRUE if the file was tested
 *  or FALSE if the file was not tested.
 */
function testJSON(filename, contents) {
  return new Promise(function(resolve, reject) {
    parseJSON(filename, contents);
    resolve(true);
  })
  .catch(function(ex) {
    let msg = `An exception occurred in testJSON: ${ex}`;
    logError(filename, null, msg, ex);
    return false;
  });
}


function testJavaScript(filename, contents, options) {
  return new Promise(function(resolve, reject) {
    let isInCodeFolder = filename.indexOf('/_code/') > 0;
    if (options.warnOnJavaScript && !isInCodeFolder) {
      logWarning(filename, null, 'JavaScript files are generally not allowed.');
    }
    resolve(true);
  })
  .catch(function(ex) {
    let msg = `An exception occurred in testJavaScript: ${ex}`;
    logError(filename, null, msg, ex);
    return false;
  });
}

/
function testHTML(filename, contents, options) {
  return new Promise(function(resolve, reject) {

    let isInCodeFolder = filename.indexOf('/_code/') > 0;

    // Throw error on hard coded developers.google.com
    if (!isInCodeFolder) {
      let matched = wfRegEx.getMatches(/developers\.google\.com/g, contents);
      matched.forEach(function(match) {
        let position = {line: getLineNumber(contents, match.index)};
        let msg = 'Do not use hard coded developers.google.com.';
        logError(filename, position, msg);
      });
    }

    resolve(true);
  })
  .catch(function(ex) {
    let msg = `An exception occurred in testHTML: ${ex}`;
    logError(filename, null, msg, ex);
    return false;
  });
}


function testCommonTags(filename, contents) {
  return new Promise(function(resolve, reject) {
    let tags = parseJSON(filename, contents);
    if (Array.isArray(tags) === true) {
      resolve(true);
    } else {
      let msg = `Common tags file must be an array, was ${typeof tags}`
      logError(filename, null, msg);
      resolve(false);
    }
  });
}


function testProject(filename, contents) {
  return new Promise(function(resolve, reject) {
    const project = parseYAML(filename, contents);
    jsonValidator.prototype.customFormats.wfUAString = function(input) {
      return input === 'UA-52746336-1'
    }
    const schemaProject = {
      id: '/Project',
      type: 'object',
      properties: {
        is_family_root: {type: 'boolean'},
        parent_project_metadata_path: {
          type: 'string',
          pattern: /^\/web\/_project.yaml$/
        },
        name: {type: 'string', required: true},
        description: {type: 'string', required: true},
        home_url: {type: 'string', pattern: /^\/web\//i, required: true},
        color: {type: 'string', pattern: /^google-blue$/, required: true},
        buganizer_id: {type: 'number', pattern: /^180451$/, required: true},
        content_license: {
          type: 'string',
          pattern: /^cc3-apache2$/,
          required: true
        },
        footer_path: {type: 'string', required: true},
        icon: {
          type: 'object',
          properties: {
            path: {type: 'string', required: true}
          },
          additionalProperties: false,
          required: true,
        },
        google_analytics_ids: {
          type: 'array',
          items: {type: 'string', format: 'wfUAString'},
          required: true
        },
        tags: {type: 'array'},
        announcement: {
          type: 'object',
          properties: {
            description: {type: 'string', required: true},
            start: {type: 'string', required: true},
            end: {type: 'string', required: true},
          },
          additionalProperties: false
        }
      },
      additionalProperties: false,
    }
    let validator = new jsonValidator();
    validator.validate(project, schemaProject).errors.forEach((err) => {
      let msg = `${err.stack || err.message}`;
      msg = msg.replace('{}', '(' + err.instance + ')');
      logError(filename, null, msg);
    });
    resolve();
  });
}



function testContributors(filename, contents) {
  return new Promise(function(resolve, reject) {
    let msg;
    let contributors = parseYAML(filename, contents);
    const schemaContributors = {
      id: '/Contributors',
      patternProperties: {
        '.*': {$ref: '/Contributor'}
      },
      properties: {
        index: {
          not: 'any'
        },
      }
    };
    const schemaContributor = {
      id: '/Contributor',
      properties: {
        name: {
          type: 'object',
          properties: {
            given: {type: 'string'},
            family: {type: 'string'},
          },
          required: ['given'],
          additionalProperties: false,
        },
        org: {
          type: 'object',
          properties: {
            name: {type: 'string'},
            unit: {type: 'string'},
          },
          additionalProperties: false,
        },
        homepage: {type: 'string', pattern: /^https?:\/\//i},
        google: {type: 'string', pattern: /^(\+[a-z].*$|[0-9].*$)/i},
        twitter: {type: 'string', pattern: /^[a-z0-9_-]+$/i},
        github: {type: 'string', pattern: /^[a-z0-9_-]+$/i},
        lanyrd: {type: 'string', pattern: /^[a-z0-9_-]+$/i},
        description: {
          type: 'object',
          properties: {
            en: {type: 'string'},
          },
          additionalProperties: false,
        },
        role: {type: 'array'},
        country: {type: 'string'},
        email: {type: 'string'}
      },
      required: ['name'],
      additionalProperties: false,
    };
    let validator = new jsonValidator();
    validator.addSchema(schemaContributor, schemaContributor.id);
    validator.validate(contributors, schemaContributors)
      .errors.forEach((err) => {
        let msg = `${err.stack || err.message}`;
        msg = msg.replace('{}', '(' + err.instance + ')');
        logError(filename, null, msg);
      }
    );
    let prevFamilyName = '';
    Object.keys(contributors).forEach((key) => {
      const contributor = contributors[key];
      const familyName = contributor.name.family || contributor.name.given;
      if (prevFamilyName.toLowerCase() > familyName.toLowerCase()) {
        const msg = `${prevFamilyName} came before ${key}`;
        logError(filename, null, msg);
      }
      prevFamilyName = familyName;
    });
    resolve();
  });
}



function testGlossary(filename, contents) {
  return new Promise(function(resolve, reject) {
    const msg = 'Glossary must be sorted alphabetically by term.'; 
    const glossary = parseYAML(filename, contents);
    const schemaGlossary = {
      id: '/Glossary',
      type: 'array',
      items: {$ref: '/GlossaryItem'}
    };
    const schemaGlossaryItem = {
      id: '/GlossaryItem',
      type: 'object',
      properties: {
        term: {type: 'string', required: true},
        description: {type: 'string', required: true},
        acronym: {type: 'string'},
        see: {$ref: '/GlossaryLink'},
        blink_component: {type: 'string'},
        tags: {type: 'array'},
        links: { type: 'array', items: {$ref: '/GlossaryLink'}},
      },
      additionalProperties: false,
    };
    const schemaGlossaryLink = {
      id: '/GlossaryLink',
      properties: {
        title: {type: 'string', required: true},
        link: {type: 'string', required: true},
      },
      additionalProperties: false
    };
    let validator = new jsonValidator();
    validator.addSchema(schemaGlossaryItem, schemaGlossaryItem.id);
    validator.addSchema(schemaGlossaryLink, schemaGlossaryLink.id);
    validator.validate(glossary, schemaGlossary).errors.forEach((err) => {
      let msg = `${err.stack || err.message}`;
      msg = msg.replace('{}', '(' + err.instance + ')');
      if (err.argument === 'description' && err.name === 'required') {
        logWarning(filename, null, msg);
        return;
      }
      logError(filename, null, msg);
    });
    let prevTermName = '';
    glossary.forEach((term) => {
      const termName = term.term.toLowerCase();
      if (prevTermName > termName) {
        const msg = `'${prevTermName}' came before '${termName}'`;
        logError(filename, null, msg);
      }
      prevTermName = termName;
    });
    resolve();
  });
}


function testRedirects(filename, contents) {
  return new Promise(function(resolve, reject) {
    let parsed = parseYAML(filename, contents);
    let fromPattern = path.dirname(filename).split('/').splice(3).join('/');
    fromPattern = path.join('/', 'web', fromPattern, '/');
    const schemaRedirects = {
      id: '/Redirects',
      type: 'object',
      properties: {
        redirects: {type: 'array', items: {$ref: '/RedirectItem'}}
      },
      additionalProperties: false,
      required: ['redirects']
    };
    const schemaRedirectItem = {
      id: '/RedirectItem',
      type: 'object',
      properties: {
        to: {type: 'string', required: true},
        from: {
          type: 'string',
          pattern: new RegExp('^' + fromPattern.replace(/\//g, '\\/')),
          required: true
        },
        temporary: {type: 'boolean'},
      },
      additionalProperties: false,
    };
    let validator = new jsonValidator();
    validator.addSchema(schemaRedirectItem, schemaRedirectItem.id);
    validator.validate(parsed, schemaRedirects).errors.forEach((err) => {
      let msg = err.stack || err.message;
      msg = msg.replace('{}', '(' + err.instance + ')');
      logError(filename, null, msg);
    });
    resolve();
  });
}



function testFile(filename, opts) {
  return new Promise(function(resolve, reject) {
    let msg;
    let testPromise;
    let filenameObj = path.parse(filename.toLowerCase());

    // Check if the file is an extension we skip
    if (EXTENSIONS_TO_SKIP.indexOf(filenameObj.ext) >= 0) {
      if (GLOBAL.WF.options.verbose) {
        msg = 'Skipped (extension).';
        gutil.log(chalk.gray('SKIP:'), chalk.cyan(filename), msg);
      }
      resolve(false);
      return;
    }

    // Check media files & verify they're not too big
    if (MEDIA_FILES.indexOf(filenameObj.ext) >= 0) {
      let fsOK = true;
      try {
        // Read the file size and check if it exceeds the known limits
        const stats = fs.statSync(filename);
        const fileSize = Math.round(parseInt(stats.size, 10) / 1024);
        if (fileSize > MAX_FILE_SIZE_ERROR) {
          fsOK = false;
          msg = `Exceeds maximum files size (${MAX_FILE_SIZE_ERROR}K)`;
          // For builds of master on Travis, warn only, do not error.
          if (IS_TRAVIS && IS_TRAVIS_PUSH && IS_TRAVIS_ON_MASTER) {
            logWarning(filename, null, `${msg} - was ${fileSize}K`);
          } else {
            logError(filename, null, `${msg} - was ${fileSize}K`);
          }
        } else if (fileSize > MAX_FILE_SIZE_WARN) {
          fsOK = false;
          msg = `Try to keep files below (${MAX_FILE_SIZE_WARN}K)`;
          logWarning(filename, null, `${msg} - was ${fileSize}K`);
        }
      } catch (ex) {
        fsOK = false;
        logWarning(filename, null, `Unable to read file stats: ${ex.message}`);
      }
      resolve(fsOK);
      return;
    }

    // Attempt to read the file contents
    let contents = readFile(filename);
    if (!contents) {
      resolve(false);
      return;
    }

    // Check if the file is auto-generated, if it is, ignore it
    if (wfRegEx.RE_AUTO_GENERATED.test(contents)) {
      if (GLOBAL.WF.options.verbose) {
        msg = 'Skipped (auto-generated).';
        gutil.log(chalk.gray('SKIP:'), chalk.cyan(filename), msg);
      }
      resolve(false);
      return;
    }

    if (GLOBAL.WF.options.verbose) {
      gutil.log('TEST:', chalk.cyan(filename));
    }

    if (filenameObj.base === 'app.yaml') {
      let msg = 'app.yaml was changed, was that intentional?';
      logWarning(filename, null, msg);
      testPromise = testYAML(filename, contents);
    } else if (filenameObj.base === '_contributors.yaml') {
      testPromise = testContributors(filename, contents);
    } else if (filenameObj.base === 'glossary.yaml') {
      testPromise = testGlossary(filename, contents);
    } else if (filenameObj.base === '_redirects.yaml') {
      testPromise = testRedirects(filename, contents);
    } else if (filenameObj.base === '_project.yaml') {
      testPromise = testProject(filename, contents);
    } else if (filenameObj.base === 'commontags.json') {
      testPromise = testCommonTags(filename, contents);
    } else if (MD_FILES.indexOf(filenameObj.ext) >= 0) {
      testPromise = testMarkdown(filename, contents, opts);
    } else if (filenameObj.ext === '.html') {
      testPromise = testHTML(filename, contents);
    } else if (filenameObj.ext === '.yaml') {
      testPromise = testYAML(filename, contents);
    } else if (filenameObj.ext === '.json') {
      testPromise = testJSON(filename, contents);
    } else if (filenameObj.ext === '.js') {
      testPromise = testJavaScript(filename, contents, opts);
    } else if (filenameObj.ext === '.txt') {
      // Text files are allowed and don't need to be tested.
      resolve(true);
      return;
    } else {
      let msg = 'No tests found for file type, was not tested.';
      logWarning(filename, null, msg);
      resolve(false);
      return;
    }
    testPromise.then(function() {
      resolve(true);
    });
  })
  .catch(function(ex) {
    let msg = `A critical test exception occurred: ${ex.message}`;
    logError(filename, null, msg, ex);
  })
  .then(function(wasTested) {
    if (wasTested) {
      filesTested++;
    }
  });
}


gulp.task('test', function() {
  if (IS_TRAVIS && IS_TRAVIS_PUSH && IS_TRAVIS_ON_MASTER) {
    GLOBAL.WF.options.testAll = true;
  }
  let opts = {
    enforceLineLengths: true,
    lastUpdateMaxDays: 7,
    warnOnJavaScript: true,
    commonTags: parseJSON(COMMON_TAGS_FILE, readFile(COMMON_TAGS_FILE)),
    contributors: parseYAML(CONTRIBUTORS_FILE, readFile(CONTRIBUTORS_FILE)),
    blinkComponents: parseJSON(BLINK_COMPONENTS_FILE, readFile(BLINK_COMPONENTS_FILE))
  }
  if (GLOBAL.WF.options.testTests) {
    GLOBAL.WF.options.testPath = './src/tests';
    opts.lastUpdateMaxDays = false;
  }
  if (GLOBAL.WF.options.testAll) {
    opts.enforceLineLengths = false;
    opts.lastUpdateMaxDays = false;
  }
  return getFiles()
  .then(function(files) {
    return Promise.all(files.map(function(filename) {
      return testFile(filename, opts);
    }));
  })
  .catch(function(ex) {
    let msg = `A critical gulp task exception occurred: ${ex.message}`;
    logError('gulp-tasks/test.js', null, msg, ex);
  })
  .then(printSummary)
  .then(throwIfFailed);
});
window.Modernizr = (function( window, document, undefined ) {

    var version = '2.7.2',

    Modernizr = {},

    /*>>cssclasses*/
    // option for enabling the HTML classes to be added
    enableClasses = true,
    /*>>cssclasses*/

    docElement = document.documentElement,

    /**
     * Create our "modernizr" element that we do most feature tests on.
     */
    mod = 'modernizr',
    modElem = document.createElement(mod),
    mStyle = modElem.style,

    /**
     * Create the input element for various Web Forms feature tests.
     */
    inputElem /*>>inputelem*/ = document.createElement('input') /*>>inputelem*/ ,

    /*>>smile*/
    smile = ':)',
    /*>>smile*/

    toString = {}.toString,

    // TODO :: make the prefixes more granular
    /*>>prefixes*/
    // List of property values to set for css tests. See ticket #21
    prefixes = ' -webkit- -moz- -o- -ms- '.split(' '),
    /*>>prefixes*/

    /*>>domprefixes*/
    // Following spec is to expose vendor-specific style properties as:
    //   elem.style.WebkitBorderRadius
    // and the following would be incorrect:
    //   elem.style.webkitBorderRadius

    // Webkit ghosts their properties in lowercase but Opera & Moz do not.
    // Microsoft uses a lowercase `ms` instead of the correct `Ms` in IE8+
    //   erik.eae.net/archives/2008/03/10/21.48.10/

    // More here: github.com/Modernizr/Modernizr/issues/issue/21
    omPrefixes = 'Webkit Moz O ms',

    cssomPrefixes = omPrefixes.split(' '),

    domPrefixes = omPrefixes.toLowerCase().split(' '),
    /*>>domprefixes*/

    /*>>ns*/
    ns = {'svg': 'http://www.w3.org/2000/svg'},
    /*>>ns*/

    tests = {},
    inputs = {},
    attrs = {},

    classes = [],

    slice = classes.slice,

    featureName, // used in testing loop


    /*>>teststyles*/
    // Inject element with style element and some CSS rules
    injectElementWithStyles = function( rule, callback, nodes, testnames ) {

      var style, ret, node, docOverflow,
          div = document.createElement('div'),
         
          fakeBody = body || document.createElement('body');

      if ( parseInt(nodes, 10) ) {
          // In order not to give false positives we create a node for each test
          // This also allows the method to scale for unspecified uses
          while ( nodes-- ) {
              node = document.createElement('div');
              node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
              div.appendChild(node);
          }
      }

    
          fakeBody.style.overflow = 'hidden';
          docOverflow = docElement.style.overflow;
          docElement.style.overflow = 'hidden';
          docElement.appendChild(fakeBody);
      }

      ret = callback(div, rule);
      // If this is done after page load we don't want to remove the body so check if body exists
      if ( !body ) {
          fakeBody.parentNode.removeChild(fakeBody);
          docElement.style.overflow = docOverflow;
      } else {
          div.parentNode.removeChild(div);
      }

      return !!ret;

    },
    /*>>teststyles*/

    /*>>mq*/
    // adapted from matchMedia polyfill
    // by Scott Jehl and Paul Irish
    // gist.github.com/786768
    testMediaQuery = function( mq ) {

      var matchMedia = window.matchMedia || window.msMatchMedia;
      if ( matchMedia ) {
        return matchMedia(mq).matches;
      }

      var bool;

      injectElementWithStyles('@media ' + mq + ' { #' + mod + ' { position: absolute; } }', function( node ) {
        bool = (window.getComputedStyle ?
                  getComputedStyle(node, null) :
                  node.currentStyle)['position'] == 'absolute';
      });

      return bool;

     },
     /*>>mq*/


    /*>>hasevent*/
    //
    // isEventSupported determines if a given element supports the given event
    // kangax.github.com/iseventsupported/
    //
    // The following results are known incorrects:
    //   Modernizr.hasEvent("webkitTransitionEnd", elem) // false negative
    //   Modernizr.hasEvent("textInput") // in Webkit. github.com/Modernizr/Modernizr/issues/333
    //   ...
    isEventSupported = (function() {

      var TAGNAMES = {
        'select': 'input', 'change': 'input',
        'submit': 'form', 'reset': 'form',
        'error': 'img', 'load': 'img', 'abort': 'img'
      };

      function isEventSupported( eventName, element ) {

        element = element || document.createElement(TAGNAMES[eventName] || 'div');
        eventName = 'on' + eventName;

        // When using `setAttribute`, IE skips "unload", WebKit skips "unload" and "resize", whereas `in` "catches" those
        var isSupported = eventName in element;

        if ( !isSupported ) {
          // If it has no `setAttribute` (i.e. doesn't implement Node interface), try generic element
          if ( !element.setAttribute ) {
            element = document.createElement('div');
          }
          if ( element.setAttribute && element.removeAttribute ) {
            element.setAttribute(eventName, '');
            isSupported = is(element[eventName], 'function');

            // If property was created, "remove it" (by setting value to `undefined`)
            if ( !is(element[eventName], 'undefined') ) {
              element[eventName] = undefined;
            }
            element.removeAttribute(eventName);
          }
        }

        element = null;
        return isSupported;
      }
      return isEventSupported;
    })(),
    /*>>hasevent*/

    // TODO :: Add flag for hasownprop ? didn't last time

    // hasOwnProperty shim by kangax needed for Safari 2.0 support
    _hasOwnProperty = ({}).hasOwnProperty, hasOwnProp;

    if ( !is(_hasOwnProperty, 'undefined') && !is(_hasOwnProperty.call, 'undefined') ) {
      hasOwnProp = function (object, property) {
        return _hasOwnProperty.call(object, property);
      };
    }
    else {
      hasOwnProp = function (object, property) { /* yes, this can give false positives/negatives, but most of the time we don't care about those */
        return ((property in object) && is(object.constructor.prototype[property], 'undefined'));
      };
    }

    // Adapted from ES5-shim https://github.com/kriskowal/es5-shim/blob/master/es5-shim.js
    // es5.github.com/#x15.3.4.5

    if (!Function.prototype.bind) {
      Function.prototype.bind = function bind(that) {

        var target = this;

        if (typeof target != "function") {
            throw new TypeError();
        }

        var args = slice.call(arguments, 1),
            bound = function () {

            if (this instanceof bound) {

              var F = function(){};
              F.prototype = target.prototype;
              var self = new F();

              var result = target.apply(
                  self,
                  args.concat(slice.call(arguments))
              );
              if (Object(result) === result) {
                  return result;
              }
              return self;

            } else {

              return target.apply(
                  that,
                  args.concat(slice.call(arguments))
              );

            }

        };

        return bound;
      };
    }

    /**
     * setCss applies given styles to the Modernizr DOM node.
     */
    function setCss( str ) {
        mStyle.cssText = str;
    }

    /**
     * setCssAll extrapolates all vendor-specific css strings.
     */
    function setCssAll( str1, str2 ) {
        return setCss(prefixes.join(str1 + ';') + ( str2 || '' ));
    }

    /**
     * is returns a boolean for if typeof obj is exactly type.
     */
    function is( obj, type ) {
        return typeof obj === type;
    }

    /**
     * contains returns a boolean for if substr is found within str.
     */
    function contains( str, substr ) {
        return !!~('' + str).indexOf(substr);
    }

    /*>>testprop*/

    // testProps is a generic CSS / DOM property test.

    // In testing support for a given CSS property, it's legit to test:
    //    `elem.style[styleName] !== undefined`
    // If the property is supported it will return an empty string,
    // if unsupported it will return undefined.

    // We'll take advantage of this quick test and skip setting a style
    // on our modernizr element, but instead just testing undefined vs
    // empty string.

    // Because the testing of the CSS property names (with "-", as
    // opposed to the camelCase DOM properties) is non-portable and
    // non-standard but works in WebKit and IE (but not Gecko or Opera),
    // we explicitly reject properties with dashes so that authors
    // developing in WebKit or IE first don't end up with
    // browser-specific content by accident.

    function testProps( props, prefixed ) {
        for ( var i in props ) {
            var prop = props[i];
            if ( !contains(prop, "-") && mStyle[prop] !== undefined ) {
                return prefixed == 'pfx' ? prop : true;
            }
        }
        return false;
    }
    /*>>testprop*/

    // TODO :: add testDOMProps
    /**
     * testDOMProps is a generic DOM property test; if a browser supports
     *   a certain property, it won't return undefined for it.
     */
    function testDOMProps( props, obj, elem ) {
        for ( var i in props ) {
            var item = obj[props[i]];
            if ( item !== undefined) {

                // return the property name as a string
                if (elem === false) return props[i];

                // let's bind a function
                if (is(item, 'function')){
                  // default to autobind unless override
                  return item.bind(elem || obj);
                }

                // return the unbound function or obj or value
                return item;
            }
        }
        return false;
    }

    /*>>testallprops*/
    /**
     * testPropsAll tests a list of DOM properties we want to check against.
     *   We specify literally ALL possible (known and/or likely) properties on
     *   the element including the non-vendor prefixed one, for forward-
     *   compatibility.
     */
    function testPropsAll( prop, prefixed, elem ) {

        var ucProp  = prop.charAt(0).toUpperCase() + prop.slice(1),
            props   = (prop + ' ' + cssomPrefixes.join(ucProp + ' ') + ucProp).split(' ');

        // did they call .prefixed('boxSizing') or are we just testing a prop?
        if(is(prefixed, "string") || is(prefixed, "undefined")) {
          return testProps(props, prefixed);

        // otherwise, they called .prefixed('requestAnimationFrame', window[, elem])
        } else {
          props = (prop + ' ' + (domPrefixes).join(ucProp + ' ') + ucProp).split(' ');
          return testDOMProps(props, prefixed, elem);
        }
    }
    /*>>testallprops*/


    /**
     * Tests
     * -----
     */

    // The *new* flexbox
    // dev.w3.org/csswg/css3-flexbox

    tests['flexbox'] = function() {
      return testPropsAll('flexWrap');
    };

    // The *old* flexbox
    // www.w3.org/TR/2009/WD-css3-flexbox-20090723/

    tests['flexboxlegacy'] = function() {
        return testPropsAll('boxDirection');
    };

    // On the S60 and BB Storm, getContext exists, but always returns undefined
    // so we actually have to call getContext() to verify
    // github.com/Modernizr/Modernizr/issues/issue/97/

    tests['canvas'] = function() {
        var elem = document.createElement('canvas');
        return !!(elem.getContext && elem.getContext('2d'));
    };

    tests['canvastext'] = function() {
        return !!(Modernizr['canvas'] && is(document.createElement('canvas').getContext('2d').fillText, 'function'));
    };

    // webk.it/70117 is tracking a legit WebGL feature detect proposal

    // We do a soft detect which may false positive in order to avoid
    // an expensive context creation: bugzil.la/732441

    tests['webgl'] = function() {
        return !!window.WebGLRenderingContext;
    };

    /*
     * The Modernizr.touch test only indicates if the browser supports
     *    touch events, which does not necessarily reflect a touchscreen
     *    device, as evidenced by tablets running Windows 7 or, alas,
     *    the Palm Pre / WebOS (touch) phones.
     *
     * Additionally, Chrome (desktop) used to lie about its support on this,
     *    but that has since been rectified: crbug.com/36415
     *
     * We also test for Firefox 4 Multitouch Support.
     *
     * For more info, see: modernizr.github.com/Modernizr/touch.html
     */

    tests['touch'] = function() {
        var bool;

        if(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {
          bool = true;
        } else {
          injectElementWithStyles(['@media (',prefixes.join('touch-enabled),('),mod,')','{#modernizr{top:9px;position:absolute}}'].join(''), function( node ) {
            bool = node.offsetTop === 9;
          });
        }

        return bool;
    };


    // geolocation is often considered a trivial feature detect...
    // Turns out, it's quite tricky to get right:
    //
    // Using !!navigator.geolocation does two things we don't want. It:
    //   1. Leaks memory in IE9: github.com/Modernizr/Modernizr/issues/513
    //   2. Disables page caching in WebKit: webk.it/43956
    //
    // Meanwhile, in Firefox < 8, an about:config setting could expose
    // a false positive that would throw an exception: bugzil.la/688158

    tests['geolocation'] = function() {
        return 'geolocation' in navigator;
    };


    tests['postmessage'] = function() {
      return !!window.postMessage;
    };


    // Chrome incognito mode used to throw an exception when using openDatabase
    // It doesn't anymore.
    tests['websqldatabase'] = function() {
      return !!window.openDatabase;
    };

    // Vendors had inconsistent prefixing with the experimental Indexed DB:
    // - Webkit's implementation is accessible through webkitIndexedDB
    // - Firefox shipped moz_indexedDB before FF4b9, but since then has been mozIndexedDB
    // For speed, we don't test the legacy (and beta-only) indexedDB
    tests['indexedDB'] = function() {
      return !!testPropsAll("indexedDB", window);
    };

    // documentMode logic from YUI to filter out IE8 Compat Mode
    //   which false positives.
    tests['hashchange'] = function() {
      return isEventSupported('hashchange', window) && (document.documentMode === undefined || document.documentMode > 7);
    };

    // Per 1.6:
    // This used to be Modernizr.historymanagement but the longer
    // name has been deprecated in favor of a shorter and property-matching one.
    // The old API is still available in 1.6, but as of 2.0 will throw a warning,
    // and in the first release thereafter disappear entirely.
    tests['history'] = function() {
      return !!(window.history && history.pushState);
    };

    tests['draganddrop'] = function() {
        var div = document.createElement('div');
        return ('draggable' in div) || ('ondragstart' in div && 'ondrop' in div);
    };

    // FF3.6 was EOL'ed on 4/24/12, but the ESR version of FF10
    // will be supported until FF19 (2/12/13), at which time, ESR becomes FF17.
    // FF10 still uses prefixes, so check for it until then.
    // for more ESR info, see: mozilla.org/en-US/firefox/organizations/faq/
    tests['websockets'] = function() {
        return 'WebSocket' in window || 'MozWebSocket' in window;
    };


    // css-tricks.com/rgba-browser-support/
    tests['rgba'] = function() {
        // Set an rgba() color and check the returned value

        setCss('background-color:rgba(150,255,150,.5)');

        return contains(mStyle.backgroundColor, 'rgba');
    };

    tests['hsla'] = function() {
        // Same as rgba(), in fact, browsers re-map hsla() to rgba() internally,
        //   except IE9 who retains it as hsla

        setCss('background-color:hsla(120,40%,100%,.5)');

        return contains(mStyle.backgroundColor, 'rgba') || contains(mStyle.backgroundColor, 'hsla');
    };

    tests['multiplebgs'] = function() {
        // Setting multiple images AND a color on the background shorthand property
        //  and then querying the style.background property value for the number of
        //  occurrences of "url(" is a reliable method for detecting ACTUAL support for this!

        setCss('background:url(https://),url(https://),red url(https://)');

        // If the UA supports multiple backgrounds, there should be three occurrences
        //   of the string "url(" in the return value for elemStyle.background

        return (/(url\s*\(.*?){3}/).test(mStyle.background);
    };



    // this will false positive in Opera Mini
    //   github.com/Modernizr/Modernizr/issues/396

    tests['backgroundsize'] = function() {
        return testPropsAll('backgroundSize');
    };

    tests['borderimage'] = function() {
        return testPropsAll('borderImage');
    };


    // Super comprehensive table about all the unique implementations of
    // border-radius: muddledramblings.com/table-of-css3-border-radius-compliance

    tests['borderradius'] = function() {
        return testPropsAll('borderRadius');
    };

    // WebOS unfortunately false positives on this test.
    tests['boxshadow'] = function() {
        return testPropsAll('boxShadow');
    };

    // FF3.0 will false positive on this test
    tests['textshadow'] = function() {
        return document.createElement('div').style.textShadow === '';
    };


    tests['opacity'] = function() {
        // Browsers that actually have CSS Opacity implemented have done so
        //  according to spec, which means their return values are within the
        //  range of [0.0,1.0] - including the leading zero.

        setCssAll('opacity:.55');

        // The non-literal . in this regex is intentional:
        //   German Chrome returns this value as 0,55
        // github.com/Modernizr/Modernizr/issues/#issue/59/comment/516632
        return (/^0.55$/).test(mStyle.opacity);
    };


    // Note, Android < 4 will pass this test, but can only animate
    //   a single property at a time
    //   goo.gl/v3V4Gp
    tests['cssanimations'] = function() {
        return testPropsAll('animationName');
    };


    tests['csscolumns'] = function() {
        return testPropsAll('columnCount');
    };


    tests['cssgradients'] = function() {
        /**
         * For CSS Gradients syntax, please see:
         * webkit.org/blog/175/introducing-css-gradients/
         * developer.mozilla.org/en/CSS/-moz-linear-gradient
         * developer.mozilla.org/en/CSS/-moz-radial-gradient
         * dev.w3.org/csswg/css3-images/#gradients-
         */

        var str1 = 'background-image:',
            str2 = 'gradient(linear,left top,right bottom,from(#9f9),to(white));',
            str3 = 'linear-gradient(left top,#9f9, white);';

        setCss(
             // legacy webkit syntax (FIXME: remove when syntax not in use anymore)
              (str1 + '-webkit- '.split(' ').join(str2 + str1) +
             // standard syntax             // trailing 'background-image:'
              prefixes.join(str3 + str1)).slice(0, -str1.length)
        );

        return contains(mStyle.backgroundImage, 'gradient');
    };


    tests['cssreflections'] = function() {
        return testPropsAll('boxReflect');
    };


    tests['csstransforms'] = function() {
        return !!testPropsAll('transform');
    };


    tests['csstransforms3d'] = function() {

        var ret = !!testPropsAll('perspective');

        // Webkit's 3D transforms are passed off to the browser's own graphics renderer.
        //   It works fine in Safari on Leopard and Snow Leopard, but not in Chrome in
        //   some conditions. As a result, Webkit typically recognizes the syntax but
        //   will sometimes throw a false positive, thus we must do a more thorough check:
        if ( ret && 'webkitPerspective' in docElement.style ) {

          // Webkit allows this media query to succeed only if the feature is enabled.
          // `@media (transform-3d),(-webkit-transform-3d){ ... }`
          injectElementWithStyles('@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}', function( node, rule ) {
            ret = node.offsetLeft === 9 && node.offsetHeight === 3;
          });
        }
        return ret;
    };


    tests['csstransitions'] = function() {
        return testPropsAll('transition');
    };


    /*>>fontface*/
    // @font-face detection routine by Diego Perini
    // javascript.nwbox.com/CSSSupport/

    // false positives:
    //   WebOS github.com/Modernizr/Modernizr/issues/342
    //   WP7   github.com/Modernizr/Modernizr/issues/538
    tests['fontface'] = function() {
        var bool;

        injectElementWithStyles('@font-face {font-family:"font";src:url("https://")}', function( node, rule ) {
          var style = document.getElementById('smodernizr'),
              sheet = style.sheet || style.styleSheet,
              cssText = sheet ? (sheet.cssRules && sheet.cssRules[0] ? sheet.cssRules[0].cssText : sheet.cssText || '') : '';

          bool = /src/i.test(cssText) && cssText.indexOf(rule.split(' ')[0]) === 0;
        });

        return bool;
    };
    /*>>fontface*/

    // CSS generated content detection
    tests['generatedcontent'] = function() {
        var bool;

        injectElementWithStyles(['#',mod,'{font:0/0 a}#',mod,':after{content:"',smile,'";visibility:hidden;font:3px/1 a}'].join(''), function( node ) {
          bool = node.offsetHeight >= 3;
        });

        return bool;
    };



    // These tests evaluate support of the video/audio elements, as well as
    // testing what types of content they support.
    //
    // We're using the Boolean constructor here, so that we can extend the value
    // e.g.  Modernizr.video     // true
    //       Modernizr.video.ogg // 'probably'
    //
    // Codec values from : github.com/NielsLeenheer/html5test/blob/9106a8/index.html#L845
    //                     thx to NielsLeenheer and zcorpan

    // Note: in some older browsers, "no" was a return value instead of empty string.
    //   It was live in FF3.5.0 and 3.5.1, but fixed in 3.5.2
    //   It was also live in Safari 4.0.0 - 4.0.4, but fixed in 4.0.5

    tests['video'] = function() {
        var elem = document.createElement('video'),
            bool = false;

        // IE9 Running on Windows Server SKU can cause an exception to be thrown, bug #224
        try {
            if ( bool = !!elem.canPlayType ) {
                bool      = new Boolean(bool);
                bool.ogg  = elem.canPlayType('video/ogg; codecs="theora"')      .replace(/^no$/,'');

                // Without QuickTime, this value will be `undefined`. github.com/Modernizr/Modernizr/issues/546
                bool.h264 = elem.canPlayType('video/mp4; codecs="avc1.42E01E"') .replace(/^no$/,'');

                bool.webm = elem.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/,'');
            }

        } catch(e) { }

        return bool;
    };

    tests['audio'] = function() {
        var elem = document.createElement('audio'),
            bool = false;

        try {
            if ( bool = !!elem.canPlayType ) {
                bool      = new Boolean(bool);
                bool.ogg  = elem.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,'');
                bool.mp3  = elem.canPlayType('audio/mpeg;')               .replace(/^no$/,'');

                // Mimetypes accepted:
                //   developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements
                //   bit.ly/iphoneoscodecs
                bool.wav  = elem.canPlayType('audio/wav; codecs="1"')     .replace(/^no$/,'');
                bool.m4a  = ( elem.canPlayType('audio/x-m4a;')            ||
                              elem.canPlayType('audio/aac;'))             .replace(/^no$/,'');
            }
        } catch(e) { }

        return bool;
    };


    // In FF4, if disabled, window.localStorage should === null.

    // Normally, we could not test that directly and need to do a
    //   `('localStorage' in window) && ` test first because otherwise Firefox will
    //   throw bugzil.la/365772 if cookies are disabled

    // Also in iOS5 Private Browsing mode, attempting to use localStorage.setItem
    // will throw the exception:
    //   QUOTA_EXCEEDED_ERRROR DOM Exception 22.
    // Peculiarly, getItem and removeItem calls do not throw.

    // Because we are forced to try/catch this, we'll go aggressive.

    // Just FWIW: IE8 Compat mode supports these features completely:
    //   www.quirksmode.org/dom/html5.html
    // But IE8 doesn't support either with local files

    tests['localstorage'] = function() {
        try {
            localStorage.setItem(mod, mod);
            localStorage.removeItem(mod);
            return true;
        } catch(e) {
            return false;
        }
    };

    tests['sessionstorage'] = function() {
        try {
            sessionStorage.setItem(mod, mod);
            sessionStorage.removeItem(mod);
            return true;
        } catch(e) {
            return false;
        }
    };


    tests['webworkers'] = function() {
        return !!window.Worker;
    };


    tests['applicationcache'] = function() {
        return !!window.applicationCache;
    };


    // Thanks to Erik Dahlstrom
    tests['svg'] = function() {
        return !!document.createElementNS && !!document.createElementNS(ns.svg, 'svg').createSVGRect;
    };

    // specifically for SVG inline in HTML, not within XHTML
    // test page: paulirish.com/demo/inline-svg
    tests['inlinesvg'] = function() {
      var div = document.createElement('div');
      div.innerHTML = '<svg/>';
      return (div.firstChild && div.firstChild.namespaceURI) == ns.svg;
    };

    // SVG SMIL animation
    tests['smil'] = function() {
        return !!document.createElementNS && /SVGAnimate/.test(toString.call(document.createElementNS(ns.svg, 'animate')));
    };

    // This test is only for clip paths in SVG proper, not clip paths on HTML content
    // demo: srufaculty.sru.edu/david.dailey/svg/newstuff/clipPath4.svg

    // However read the comments to dig into applying SVG clippaths to HTML content here:
    //   github.com/Modernizr/Modernizr/issues/213#issuecomment-1149491
    tests['svgclippaths'] = function() {
        return !!document.createElementNS && /SVGClipPath/.test(toString.call(document.createElementNS(ns.svg, 'clipPath')));
    };

    /*>>webforms*/
    // input features and input types go directly onto the ret object, bypassing the tests loop.
    // Hold this guy to execute in a moment.
    function webforms() {
        /*>>input*/
        // Run through HTML5's new input attributes to see if the UA understands any.
        // We're using f which is the <input> element created early on
        // Mike Taylr has created a comprehensive resource for testing these attributes
        //   when applied to all input types:
        //   miketaylr.com/code/input-type-attr.html
        // spec: www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary

        // Only input placeholder is tested while textarea's placeholder is not.
        // Currently Safari 4 and Opera 11 have support only for the input placeholder
        // Both tests are available in feature-detects/forms-placeholder.js
        Modernizr['input'] = (function( props ) {
            for ( var i = 0, len = props.length; i < len; i++ ) {
                attrs[ props[i] ] = !!(props[i] in inputElem);
            }
            if (attrs.list){
              // safari false positive's on datalist: webk.it/74252
              // see also github.com/Modernizr/Modernizr/issues/146
              attrs.list = !!(document.createElement('datalist') && window.HTMLDataListElement);
            }
            return attrs;
        })('autocomplete autofocus list placeholder max min multiple pattern required step'.split(' '));
        /*>>input*/

        /*>>inputtypes*/
        // Run through HTML5's new input types to see if the UA understands any.
        //   This is put behind the tests runloop because it doesn't return a
        //   true/false like all the other tests; instead, it returns an object
        //   containing each input type with its corresponding true/false value

        // Big thanks to @miketaylr for the html5 forms expertise. miketaylr.com/
        Modernizr['inputtypes'] = (function(props) {

            for ( var i = 0, bool, inputElemType, defaultView, len = props.length; i < len; i++ ) {

                inputElem.setAttribute('type', inputElemType = props[i]);
                bool = inputElem.type !== 'text';

                // We first check to see if the type we give it sticks..
                // If the type does, we feed it a textual value, which shouldn't be valid.
                // If the value doesn't stick, we know there's input sanitization which infers a custom UI
                if ( bool ) {

                    inputElem.value         = smile;
                    inputElem.style.cssText = 'position:absolute;visibility:hidden;';

                    if ( /^range$/.test(inputElemType) && inputElem.style.WebkitAppearance !== undefined ) {

                      docElement.appendChild(inputElem);
                      defaultView = document.defaultView;

                      // Safari 2-4 allows the smiley as a value, despite making a slider
                      bool =  defaultView.getComputedStyle &&
                              defaultView.getComputedStyle(inputElem, null).WebkitAppearance !== 'textfield' &&
                              // Mobile android web browser has false positive, so must
                              // check the height to see if the widget is actually there.
                              (inputElem.offsetHeight !== 0);

                      docElement.removeChild(inputElem);

                    } else if ( /^(search|tel)$/.test(inputElemType) ){
                      // Spec doesn't define any special parsing or detectable UI
                      //   behaviors so we pass these through as true

                      // Interestingly, opera fails the earlier test, so it doesn't
                      //  even make it here.

                    } else if ( /^(url|email)$/.test(inputElemType) ) {
                      // Real url and email support comes with prebaked validation.
                      bool = inputElem.checkValidity && inputElem.checkValidity() === false;

                    } else {
                      // If the upgraded input compontent rejects the :) text, we got a winner
                      bool = inputElem.value != smile;
                    }
                }

                inputs[ props[i] ] = !!bool;
            }
            return inputs;
        })('search tel url email datetime date month week time datetime-local number range color'.split(' '));
        /*>>inputtypes*/
    }
    /*>>webforms*/


    // End of test definitions
    // -----------------------



    // Run through all tests and detect their support in the current UA.
    // todo: hypothetically we could be doing an array of tests and use a basic loop here.
    for ( var feature in tests ) {
        if ( hasOwnProp(tests, feature) ) {
            // run the test, throw the return value into the Modernizr,
            //   then based on that boolean, define an appropriate className
            //   and push it into an array of classes we'll join later.
            featureName  = feature.toLowerCase();
            Modernizr[featureName] = tests[feature]();

            classes.push((Modernizr[featureName] ? '' : 'no-') + featureName);
        }
    }

    /*>>webforms*/
    // input tests need to run.
    Modernizr.input || webforms();
    /*>>webforms*/


    /**
     * addTest allows the user to define their own feature tests
     * the result will be added onto the Modernizr object,
     * as well as an appropriate className set on the html element
     *
     * @param feature - String naming the feature
     * @param test - Function returning true if feature is supported, false if not
     */
     Modernizr.addTest = function ( feature, test ) {
       if ( typeof feature == 'object' ) {
         for ( var key in feature ) {
           if ( hasOwnProp( feature, key ) ) {
             Modernizr.addTest( key, feature[ key ] );
           }
         }
       } else {

         feature = feature.toLowerCase();

         if ( Modernizr[feature] !== undefined ) {
           // we're going to quit if you're trying to overwrite an existing test
           // if we were to allow it, we'd do this:
           //   var re = new RegExp("\\b(no-)?" + feature + "\\b");
           //   docElement.className = docElement.className.replace( re, '' );
           // but, no rly, stuff 'em.
           return Modernizr;
         }

         test = typeof test == 'function' ? test() : test;

         if (typeof enableClasses !== "undefined" && enableClasses) {
           docElement.className += ' ' + (test ? '' : 'no-') + feature;
         }
         Modernizr[feature] = test;

       }

       return Modernizr; // allow chaining.
     };


    // Reset modElem.cssText to nothing to reduce memory footprint.
    setCss('');
    modElem = inputElem = null;

    /*>>shiv*/
    /**
     * @preserve HTML5 Shiv prev3.7.1 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed
     */
    ;(function(window, document) {
        /*jshint evil:true */
        /** version */
        var version = '3.7.0';

        /** Preset options */
        var options = window.html5 || {};

        /** Used to skip problem elements */
        var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;

        /** Not all elements can be cloned in IE **/
        var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;

        /** Detect whether the browser supports default html5 styles */
        var supportsHtml5Styles;

        /** Name of the expando, to work with multiple documents or to re-shiv one document */
        var expando = '_html5shiv';

        /** The id for the the documents expando */
        var expanID = 0;

        /** Cached data for each document */
        var expandoData = {};

        /** Detect whether the browser supports unknown elements */
        var supportsUnknownElements;

        (function() {
          try {
            var a = document.createElement('a');
            a.innerHTML = '<xyz></xyz>';
            //if the hidden property is implemented we can assume, that the browser supports basic HTML5 Styles
            supportsHtml5Styles = ('hidden' in a);

            supportsUnknownElements = a.childNodes.length == 1 || (function() {
              // assign a false positive if unable to shiv
              (document.createElement)('a');
              var frag = document.createDocumentFragment();
              return (
                typeof frag.cloneNode == 'undefined' ||
                typeof frag.createDocumentFragment == 'undefined' ||
                typeof frag.createElement == 'undefined'
              );
            }());
          } catch(e) {
            // assign a false positive if detection fails => unable to shiv
            supportsHtml5Styles = true;
            supportsUnknownElements = true;
          }

        }());

        /*--------------------------------------------------------------------------*/

        /**
         * Creates a style sheet with the given CSS text and adds it to the document.
         * @private
         * @param {Document} ownerDocument The document.
         * @param {String} cssText The CSS text.
         * @returns {StyleSheet} The style element.
         */
        function addStyleSheet(ownerDocument, cssText) {
          var p = ownerDocument.createElement('p'),
          parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;

          p.innerHTML = 'x<style>' + cssText + '</style>';
          return parent.insertBefore(p.lastChild, parent.firstChild);
        }

        /**
         * Returns the value of `html5.elements` as an array.
         * @private
         * @returns {Array} An array of shived element node names.
         */
        function getElements() {
          var elements = html5.elements;
          return typeof elements == 'string' ? elements.split(' ') : elements;
        }

        /**
         * Returns the data associated to the given document
         * @private
         * @param {Document} ownerDocument The document.
         * @returns {Object} An object of data.
         */
        function getExpandoData(ownerDocument) {
          var data = expandoData[ownerDocument[expando]];
          if (!data) {
            data = {};
            expanID++;
            ownerDocument[expando] = expanID;
            expandoData[expanID] = data;
          }
          return data;
        }

        /**
         * returns a shived element for the given nodeName and document
         * @memberOf html5
         * @param {String} nodeName name of the element
         * @param {Document} ownerDocument The context document.
         * @returns {Object} The shived element.
         */
        function createElement(nodeName, ownerDocument, data){
          if (!ownerDocument) {
            ownerDocument = document;
          }
          if(supportsUnknownElements){
            return ownerDocument.createElement(nodeName);
          }
          if (!data) {
            data = getExpandoData(ownerDocument);
          }
          var node;

          if (data.cache[nodeName]) {
            node = data.cache[nodeName].cloneNode();
          } else if (saveClones.test(nodeName)) {
            node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
          } else {
            node = data.createElem(nodeName);
          }

          // Avoid adding some elements to fragments in IE < 9 because
          // * Attributes like `name` or `type` cannot be set/changed once an element
          //   is inserted into a document/fragment
          // * Link elements with `src` attributes that are inaccessible, as with
          //   a 403 response, will cause the tab/window to crash
          // * Script elements appended to fragments will execute when their `src`
          //   or `text` property is set
          return node.canHaveChildren && !reSkip.test(nodeName) && !node.tagUrn ? data.frag.appendChild(node) : node;
        }

        /**
         * returns a shived DocumentFragment for the given document
         * @memberOf html5
         * @param {Document} ownerDocument The context document.
         * @returns {Object} The shived DocumentFragment.
         */
        function createDocumentFragment(ownerDocument, data){
          if (!ownerDocument) {
            ownerDocument = document;
          }
          if(supportsUnknownElements){
            return ownerDocument.createDocumentFragment();
          }
          data = data || getExpandoData(ownerDocument);
          var clone = data.frag.cloneNode(),
          i = 0,
          elems = getElements(),
          l = elems.length;
          for(;i<l;i++){
            clone.createElement(elems[i]);
          }
          return clone;
        }

        /**
         * Shivs the `createElement` and `createDocumentFragment` methods of the document.
         * @private
         * @param {Document|DocumentFragment} ownerDocument The document.
         * @param {Object} data of the document.
         */
        function shivMethods(ownerDocument, data) {
          if (!data.cache) {
            data.cache = {};
            data.createElem = ownerDocument.createElement;
            data.createFrag = ownerDocument.createDocumentFragment;
            data.frag = data.createFrag();
          }


          ownerDocument.createElement = function(nodeName) {
            //abort shiv
            if (!html5.shivMethods) {
              return data.createElem(nodeName);
            }
            return createElement(nodeName, ownerDocument, data);
          };

          ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' +
                                                          'var n=f.cloneNode(),c=n.createElement;' +
                                                          'h.shivMethods&&(' +
                                                          // unroll the `createElement` calls
                                                          getElements().join().replace(/[\w\-]+/g, function(nodeName) {
            data.createElem(nodeName);
            data.frag.createElement(nodeName);
            return 'c("' + nodeName + '")';
          }) +
            ');return n}'
                                                         )(html5, data.frag);
        }

        /*--------------------------------------------------------------------------*/

        /**
         * Shivs the given document.
         * @memberOf html5
         * @param {Document} ownerDocument The document to shiv.
         * @returns {Document} The shived document.
         */
        function shivDocument(ownerDocument) {
          if (!ownerDocument) {
            ownerDocument = document;
          }
          var data = getExpandoData(ownerDocument);

          if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {
            data.hasCSS = !!addStyleSheet(ownerDocument,
                                          // corrects block display not defined in IE6/7/8/9
                                          'article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}' +
                                            // adds styling not present in IE6/7/8/9
                                            'mark{background:#FF0;color:#000}' +
                                            // hides non-rendered elements
                                            'template{display:none}'
                                         );
          }
          if (!supportsUnknownElements) {
            shivMethods(ownerDocument, data);
          }
          return ownerDocument;
        }

        /*--------------------------------------------------------------------------*/

        /**
         * The `html5` object is exposed so that more elements can be shived and
         * existing shiving can be detected on iframes.
         * @type Object
         * @example
         *
         * // options can be changed before the script is included
         * html5 = { 'elements': 'mark section', 'shivCSS': false, 'shivMethods': false };
         */
        var html5 = {

          /**
           * An array or space separated string of node names of the elements to shiv.
           * @memberOf html5
           * @type Array|String
           */
          'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video',

          /**
           * current version of html5shiv
           */
          'version': version,

          /**
           * A flag to indicate that the HTML5 style sheet should be inserted.
           * @memberOf html5
           * @type Boolean
           */
          'shivCSS': (options.shivCSS !== false),

          /**
           * Is equal to true if a browser supports creating unknown/HTML5 elements
           * @memberOf html5
           * @type boolean
           */
          'supportsUnknownElements': supportsUnknownElements,

          /**
           * A flag to indicate that the document's `createElement` and `createDocumentFragment`
           * methods should be overwritten.
           * @memberOf html5
           * @type Boolean
           */
          'shivMethods': (options.shivMethods !== false),

          /**
           * A string to describe the type of `html5` object ("default" or "default print").
           * @memberOf html5
           * @type String
           */
          'type': 'default',

          // shivs the document according to the specified `html5` object options
          'shivDocument': shivDocument,

          //creates a shived element
          createElement: createElement,

          //creates a shived documentFragment
          createDocumentFragment: createDocumentFragment
        };

        /*--------------------------------------------------------------------------*/

        // expose html5
        window.html5 = html5;

        // shiv the document
        shivDocument(document);

    }(this, document));
    /*>>shiv*/

    // Assign private properties to the return object with prefix
    Modernizr._version      = version;

    // expose these for the plugin API. Look in the source for how to join() them against your input
    /*>>prefixes*/
    Modernizr._prefixes     = prefixes;
    /*>>prefixes*/
    /*>>domprefixes*/
    Modernizr._domPrefixes  = domPrefixes;
    Modernizr._cssomPrefixes  = cssomPrefixes;
    /*>>domprefixes*/

    /*>>mq*/
    // Modernizr.mq tests a given media query, live against the current state of the window
    // A few important notes:
    //   * If a browser does not support media queries at all (eg. oldIE) the mq() will always return false
    //   * A max-width or orientation query will be evaluated against the current state, which may change later.
    //   * You must specify values. Eg. If you are testing support for the min-width media query use:
    //       Modernizr.mq('(min-width:0)')
    // usage:
    // Modernizr.mq('only screen and (max-width:768)')
    Modernizr.mq            = testMediaQuery;
    /*>>mq*/

    /*>>hasevent*/
    // Modernizr.hasEvent() detects support for a given event, with an optional element to test on
    // Modernizr.hasEvent('gesturestart', elem)
    Modernizr.hasEvent      = isEventSupported;
    /*>>hasevent*/

    /*>>testprop*/
    // Modernizr.testProp() investigates whether a given style property is recognized
    // Note that the property names must be provided in the camelCase variant.
    // Modernizr.testProp('pointerEvents')
    Modernizr.testProp      = function(prop){
        return testProps([prop]);
    };
    /*>>testprop*/

    /*>>testallprops*/
    // Modernizr.testAllProps() investigates whether a given style property,
    //   or any of its vendor-prefixed variants, is recognized
    // Note that the property names must be provided in the camelCase variant.
    // Modernizr.testAllProps('boxSizing')
    Modernizr.testAllProps  = testPropsAll;
    /*>>testallprops*/


    /*>>teststyles*/
    // Modernizr.testStyles() allows you to add custom styles to the document and test an element afterwards
    // Modernizr.testStyles('#modernizr { position:absolute }', function(elem, rule){ ... })
    Modernizr.testStyles    = injectElementWithStyles;
    /*>>teststyles*/


    /*>>prefixed*/
    // Modernizr.prefixed() returns the prefixed or nonprefixed property name variant of your input
    // Modernizr.prefixed('boxSizing') // 'MozBoxSizing'

    // Properties must be passed as dom-style camelcase, rather than `box-sizing` hypentated style.
    // Return values will also be the camelCase variant, if you need to translate that to hypenated style use:
    //
    //     str.replace(/([A-Z])/g, function(str,m1){ return '-' + m1.toLowerCase(); }).replace(/^ms-/,'-ms-');

    // If you're trying to ascertain which transition end event to bind to, you might do something like...
    //
    //     var transEndEventNames = {
    //       'WebkitTransition' : 'webkitTransitionEnd',
    //       'MozTransition'    : 'transitionend',
    //       'OTransition'      : 'oTransitionEnd',
    //       'msTransition'     : 'MSTransitionEnd',
    //       'transition'       : 'transitionend'
    //     },
    //     transEndEventName = transEndEventNames[ Modernizr.prefixed('transition') ];

    Modernizr.prefixed      = function(prop, obj, elem){
      if(!obj) {
        return testPropsAll(prop, 'pfx');
      } else {
        // Testing DOM property e.g. Modernizr.prefixed('requestAnimationFrame', window) // 'mozRequestAnimationFrame'
        return testPropsAll(prop, obj, elem);
      }
    };
    /*>>prefixed*/


    /*>>cssclasses*/
    // Remove "no-js" class from <html> element, if it exists:
    docElement.className = docElement.className.replace(/(^|\s)no-js(\s|$)/, '$1$2') +

                            // Add the new classes to the <html> element.
                            (enableClasses ? ' js ' + classes.join(' ') : '');
    /*>>cssclasses*/

    return Modernizr;

})(this, this.document);
var _allTests = [
  'closure/goog/a11y/aria/announcer_test.html',
  'closure/goog/a11y/aria/aria_test.html',
  'closure/goog/array/array_test.html',
  'closure/goog/asserts/asserts_test.html',
  'closure/goog/async/animationdelay_test.html',
  'closure/goog/async/conditionaldelay_test.html',
  'closure/goog/async/debouncer_test.html',
  'closure/goog/async/delay_test.html',
  'closure/goog/async/freelist_test.html',
  'closure/goog/async/nexttick_test.html',
  'closure/goog/async/run_test.html',
  'closure/goog/async/throttle_test.html',
  'closure/goog/async/workqueue_test.html',
  'closure/goog/base_module_test.html',
  'closure/goog/base_test.html',
  'closure/goog/color/alpha_test.html',
  'closure/goog/color/color_test.html',
  'closure/goog/crypt/aes_test.html',
  'closure/goog/crypt/arc4_test.html',
  'closure/goog/crypt/base64_test.html',
  'closure/goog/crypt/basen_test.html',
  'closure/goog/crypt/blobhasher_test.html',
  'closure/goog/crypt/cbc_test.html',
  'closure/goog/crypt/crypt_test.html',
  'closure/goog/crypt/ctr_test.html',
  'closure/goog/crypt/hash32_test.html',
  'closure/goog/crypt/hmac_test.html',
  'closure/goog/crypt/md5_test.html',
  'closure/goog/crypt/pbkdf2_test.html',
  'closure/goog/crypt/sha1_test.html',
  'closure/goog/crypt/sha224_test.html',
  'closure/goog/crypt/sha256_test.html',
  'closure/goog/crypt/sha2_64bit_test.html',
  'closure/goog/cssom/cssom_test.html',
  'closure/goog/cssom/iframe/style_test.html',
  'closure/goog/datasource/datasource_test.html',
  'closure/goog/datasource/expr_test.html',
  'closure/goog/datasource/fastdatanode_test.html',
  'closure/goog/datasource/jsxmlhttpdatasource_test.html',
  'closure/goog/date/daterange_test.html',
  'closure/goog/date/date_test.html',
  'closure/goog/date/duration_test.html',
  'closure/goog/date/relative_test.html',
  'closure/goog/date/relativewithplurals_test.html',
  'closure/goog/date/utcdatetime_test.html',
  'closure/goog/debug/console_test.html',
  'closure/goog/debug/debug_test.html',
  'closure/goog/debug/debugwindow_test.html',
  'closure/goog/debug/devcss/devcss_test.html',
  'closure/goog/debug/enhanceerror_test.html',
  'closure/goog/debug/entrypointregistry_test.html',
  'closure/goog/debug/errorcontext_test.html',
  'closure/goog/debug/errorhandler_async_test.html',
  'closure/goog/debug/errorhandler_test.html',
  'closure/goog/debug/errorreporter_test.html',
  'closure/goog/debug/error_test.html',
  'closure/goog/debug/formatter_test.html',
  'closure/goog/debug/fpsdisplay_test.html',
  'closure/goog/debug/logbuffer_test.html',
  'closure/goog/debug/logger_test.html',
  'closure/goog/debug/logrecordserializer_test.html',
  'closure/goog/debug/tracer_test.html',
  'closure/goog/defineclass_test.html',
  'closure/goog/disposable/disposable_test.html',
  'closure/goog/dom/abstractrange_test.html',
  'closure/goog/dom/animationframe/animationframe_test.html',
  'closure/goog/dom/annotate_test.html',
  'closure/goog/dom/asserts_test.html',
  'closure/goog/dom/browserrange/browserrange_test.html',
  'closure/goog/dom/bufferedviewportsizemonitor_test.html',
  'closure/goog/dom/classes_test.html',
  'closure/goog/dom/classlist_test.html',
  'closure/goog/dom/controlrange_test.html',
  'closure/goog/dom/dataset_test.html',
  'closure/goog/dom/dom_compile_test.html',
  'closure/goog/dom/dom_test.html',
  'closure/goog/dom/fontsizemonitor_test.html',
  'closure/goog/dom/forms_test.html',
  'closure/goog/dom/fullscreen_test.html',
  'closure/goog/dom/iframe_test.html',
  'closure/goog/dom/inputtype_test.html',
  'closure/goog/dom/iter_test.html',
  'closure/goog/dom/multirange_test.html',
  'closure/goog/dom/nodeiterator_test.html',
  'closure/goog/dom/nodeoffset_test.html',
  'closure/goog/dom/pattern/matcher_test.html',
  'closure/goog/dom/pattern/pattern_test.html',
  'closure/goog/dom/range_test.html',
  'closure/goog/dom/safe_test.html',
  'closure/goog/dom/savedcaretrange_test.html',
  'closure/goog/dom/savedrange_test.html',
  'closure/goog/dom/selection_test.html',
  'closure/goog/dom/tagiterator_test.html',
  'closure/goog/dom/tagname_test.html',
  'closure/goog/dom/tags_test.html',
  'closure/goog/dom/textrangeiterator_test.html',
  'closure/goog/dom/textrange_test.html',
  'closure/goog/dom/uri_test.html',
  'closure/goog/dom/vendor_test.html',
  'closure/goog/dom/viewportsizemonitor_test.html',
  'closure/goog/dom/xml_test.html',
  'closure/goog/editor/clicktoeditwrapper_test.html',
  'closure/goog/editor/contenteditablefield_test.html',
  'closure/goog/editor/field_test.html',
  'closure/goog/editor/focus_test.html',
  'closure/goog/editor/icontent_test.html',
  'closure/goog/editor/link_test.html',
  'closure/goog/editor/node_test.html',
  'closure/goog/editor/plugins/abstractbubbleplugin_test.html',
  'closure/goog/editor/plugins/abstractdialogplugin_test.html',
  'closure/goog/editor/plugins/abstracttabhandler_test.html',
  'closure/goog/editor/plugins/basictextformatter_test.html',
  'closure/goog/editor/plugins/blockquote_test.html',
  'closure/goog/editor/plugins/emoticons_test.html',
  'closure/goog/editor/plugins/enterhandler_test.html',
  'closure/goog/editor/plugins/firststrong_test.html',
  'closure/goog/editor/plugins/headerformatter_test.html',
  'closure/goog/editor/plugins/linkbubble_test.html',
  'closure/goog/editor/plugins/linkdialogplugin_test.html',
  'closure/goog/editor/plugins/linkshortcutplugin_test.html',
  'closure/goog/editor/plugins/listtabhandler_test.html',
  'closure/goog/editor/plugins/loremipsum_test.html',
  'closure/goog/editor/plugins/removeformatting_test.html',
  'closure/goog/editor/plugins/spacestabhandler_test.html',
  'closure/goog/editor/plugins/tableeditor_test.html',
  'closure/goog/editor/plugins/tagonenterhandler_test.html',
  'closure/goog/editor/plugins/undoredomanager_test.html',
  'closure/goog/editor/plugins/undoredostate_test.html',
  'closure/goog/editor/plugins/undoredo_test.html',
  'closure/goog/editor/plugin_test.html',
  'closure/goog/editor/range_test.html',
  'closure/goog/editor/seamlessfield_test.html',
  'closure/goog/editor/style_test.html',
  'closure/goog/editor/table_test.html',
  'closure/goog/events/actioneventwrapper_test.html',
  'closure/goog/events/actionhandler_test.html',
  'closure/goog/events/browserevent_test.html',
  'closure/goog/events/eventhandler_test.html',
  'closure/goog/events/events_test.html',
  'closure/goog/events/eventtarget_test.html',
  'closure/goog/events/eventtarget_via_googevents_test.html',
  'closure/goog/events/eventtarget_via_w3cinterface_test.html',
  'closure/goog/events/event_test.html',
  'closure/goog/events/eventtype_test.html',
  'closure/goog/events/filedrophandler_test.html',
  'closure/goog/events/imehandler_test.html',
  'closure/goog/events/inputhandler_test.html',
  'closure/goog/events/keycodes_test.html',
  'closure/goog/events/keyhandler_test.html',
  'closure/goog/events/listenable_test.html',
  'closure/goog/events/listenermap_test.html',
  'closure/goog/events/mousewheelhandler_test.html',
  'closure/goog/events/onlinelistener_test.html',
  'closure/goog/events/pastehandler_test.html',
  'closure/goog/events/wheelhandler_test.html',
  'closure/goog/format/emailaddress_test.html',
  'closure/goog/format/format_test.html',
  'closure/goog/format/htmlprettyprinter_test.html',
  'closure/goog/format/internationalizedemailaddress_test.html',
  'closure/goog/format/jsonprettyprinter_test.html',
  'closure/goog/fs/fs_test.html',
  'closure/goog/fs/url_test.html',
  'closure/goog/functions/functions_test.html',
  'closure/goog/fx/abstractdragdrop_test.html',
  'closure/goog/fx/anim/anim_test.html',
  'closure/goog/fx/animationqueue_test.html',
  'closure/goog/fx/animation_test.html',
  'closure/goog/fx/css3/transition_test.html',
  'closure/goog/fx/cssspriteanimation_test.html',
  'closure/goog/fx/dragdropgroup_test.html',
  'closure/goog/fx/dragger_test.html',
  'closure/goog/fx/draglistgroup_test.html',
  'closure/goog/fx/dragscrollsupport_test.html',
  'closure/goog/fx/easing_test.html',
  'closure/goog/fx/fx_test.html',
  'closure/goog/graphics/affinetransform_test.html',
  'closure/goog/graphics/canvasgraphics_test.html',
  'closure/goog/graphics/ext/coordinates_test.html',
  'closure/goog/graphics/ext/element_test.html',
  'closure/goog/graphics/ext/path_test.html',
  'closure/goog/graphics/paths_test.html',
  'closure/goog/graphics/path_test.html',
  'closure/goog/graphics/solidfill_test.html',
  'closure/goog/graphics/svggraphics_test.html',
  'closure/goog/history/history_test.html',
  'closure/goog/history/html5history_test.html',
  'closure/goog/html/cssspecificity_test.html',
  'closure/goog/html/flash_test.html',
  'closure/goog/html/legacyconversions_test.html',
  'closure/goog/html/safehtmlformatter_test.html',
  'closure/goog/html/safehtml_test.html',
  'closure/goog/html/safescript_test.html',
  'closure/goog/html/safestylesheet_test.html',
  'closure/goog/html/safestyle_test.html',
  'closure/goog/html/safeurl_test.html',
  'closure/goog/html/sanitizer/csssanitizer_test.html',
  'closure/goog/html/sanitizer/htmlsanitizer_test.html',
  'closure/goog/html/sanitizer/unsafe_test.html',
  'closure/goog/html/silverlight_test.html',
  'closure/goog/html/textextractor_test.html',
  'closure/goog/html/trustedresourceurl_test.html',
  'closure/goog/html/uncheckedconversions_test.html',
  'closure/goog/html/utils_test.html',
  'closure/goog/i18n/bidiformatter_test.html',
  'closure/goog/i18n/bidi_test.html',
  'closure/goog/i18n/charlistdecompressor_test.html',
  'closure/goog/i18n/collation_test.html',
  'closure/goog/i18n/currency_test.html',
  'closure/goog/i18n/dateintervalformat_test.html',
  'closure/goog/i18n/datetimeformat_test.html',
  'closure/goog/i18n/datetimeparse_test.html',
  'closure/goog/i18n/graphemebreak_test.html',
  'closure/goog/i18n/messageformat_test.html',
  'closure/goog/i18n/mime_test.html',
  'closure/goog/i18n/numberformat_test.html',
  'closure/goog/i18n/pluralrules_test.html',
  'closure/goog/i18n/timezone_test.html',
  'closure/goog/i18n/uchar/localnamefetcher_test.html',
  'closure/goog/i18n/ucharnames_test.html',
  'closure/goog/i18n/uchar/remotenamefetcher_test.html',
  'closure/goog/i18n/uchar_test.html',
  'closure/goog/iter/es6_test.html',
  'closure/goog/iter/iter_test.html',
  'closure/goog/json/hybrid_test.html',
  'closure/goog/json/json_test.html',
  'closure/goog/json/processor_test.html',
  'closure/goog/labs/dom/pagevisibilitymonitor_test.html',
  'closure/goog/labs/events/nondisposableeventtarget_test.html',
  'closure/goog/labs/events/nondisposableeventtarget_via_googevents_test.html',
  'closure/goog/labs/events/touch_test.html',
  'closure/goog/labs/format/csv_test.html',
  'closure/goog/labs/i18n/listformat_test.html',
  'closure/goog/labs/iterable/iterable_test.html',
  'closure/goog/labs/mock/mock_test.html',
  'closure/goog/labs/mock/verificationmode_test.html',
  'closure/goog/labs/net/image_test.html',
  'closure/goog/labs/net/webchannel/channelrequest_test.html',
  'closure/goog/labs/net/webchannel/forwardchannelrequestpool_test.html',
  'closure/goog/labs/net/webchannel/webchannelbase_test.html',
  'closure/goog/labs/net/webchannel/webchannelbasetransport_test.html',
  'closure/goog/labs/net/webchannel/wirev8_test.html',
  'closure/goog/labs/net/xhr_test.html',
  'closure/goog/labs/promise/promise_test.html',
  'closure/goog/labs/pubsub/broadcastpubsub_test.html',
  'closure/goog/labs/storage/boundedcollectablestorage_test.html',
  'closure/goog/labs/structs/map_test.html',
  'closure/goog/labs/structs/multimap_test.html',
  'closure/goog/labs/style/pixeldensitymonitor_test.html',
  'closure/goog/labs/testing/assertthat_test.html',
  'closure/goog/labs/testing/decoratormatcher_test.html',
  'closure/goog/labs/testing/dictionarymatcher_test.html',
  'closure/goog/labs/testing/environment_test.html',
  'closure/goog/labs/testing/environment_usage_test.html',
  'closure/goog/labs/testing/json_fuzzing_test.html',
  'closure/goog/labs/testing/logicmatcher_test.html',
  'closure/goog/labs/testing/numbermatcher_test.html',
  'closure/goog/labs/testing/objectmatcher_test.html',
  'closure/goog/labs/testing/stringmatcher_test.html',
  'closure/goog/labs/useragent/browser_test.html',
  'closure/goog/labs/useragent/device_test.html',
  'closure/goog/labs/useragent/engine_test.html',
  'closure/goog/labs/useragent/platform_test.html',
  'closure/goog/labs/useragent/util_test.html',
  'closure/goog/labs/useragent/verifier_test.html',
  'closure/goog/locale/countrylanguagenames_test.html',
  'closure/goog/locale/genericfontnames_test.html',
  'closure/goog/locale/timezonedetection_test.html',
  'closure/goog/locale/timezonelist_test.html',
  'closure/goog/log/log_test.html',
  'closure/goog/math/affinetransform_test.html',
  'closure/goog/math/bezier_test.html',
  'closure/goog/math/box_test.html',
  'closure/goog/math/coordinate3_test.html',
  'closure/goog/math/coordinate_test.html',
  'closure/goog/math/exponentialbackoff_test.html',
  'closure/goog/math/integer_test.html',
  'closure/goog/math/interpolator/linear1_test.html',
  'closure/goog/math/interpolator/pchip1_test.html',
  'closure/goog/math/interpolator/spline1_test.html',
  'closure/goog/math/line_test.html',
  'closure/goog/math/long_test.html',
  'closure/goog/math/math_test.html',
  'closure/goog/math/matrix_test.html',
  'closure/goog/math/paths_test.html',
  'closure/goog/math/path_test.html',
  'closure/goog/math/rangeset_test.html',
  'closure/goog/math/range_test.html',
  'closure/goog/math/rect_test.html',
  'closure/goog/math/size_test.html',
  'closure/goog/math/tdma_test.html',
  'closure/goog/math/vec2_test.html',
  'closure/goog/math/vec3_test.html',
  'closure/goog/memoize/memoize_test.html',
  'closure/goog/messaging/abstractchannel_test.html',
  'closure/goog/messaging/bufferedchannel_test.html',
  'closure/goog/messaging/deferredchannel_test.html',
  'closure/goog/messaging/loggerclient_test.html',
  'closure/goog/messaging/loggerserver_test.html',
  'closure/goog/messaging/messaging_test.html',
  'closure/goog/messaging/multichannel_test.html',
  'closure/goog/messaging/portcaller_test.html',
  'closure/goog/messaging/portchannel_test.html',
  'closure/goog/messaging/portnetwork_test.html',
  'closure/goog/messaging/portoperator_test.html',
  'closure/goog/messaging/respondingchannel_test.html',
  'closure/goog/module/moduleinfo_test.html',
  'closure/goog/module/moduleloadcallback_test.html',
  'closure/goog/module/moduleloader_test.html',
  'closure/goog/module/modulemanager_test.html',
  'closure/goog/net/browserchannel_test.html',
  'closure/goog/net/bulkloader_test.html',
  'closure/goog/net/channelrequest_test.html',
  'closure/goog/net/cookies_test.html',
  'closure/goog/net/corsxmlhttpfactory_test.html',
  'closure/goog/net/crossdomainrpc_test.html',
  'closure/goog/net/fetchxmlhttpfactory_test.html',
  'closure/goog/net/filedownloader_test.html',
  'closure/goog/net/iframeio_different_base_test.html',
  'closure/goog/net/iframeio_test.html',
  'closure/goog/net/iframeloadmonitor_test.html',
  'closure/goog/net/imageloader_test.html',
  'closure/goog/net/ipaddress_test.html',
  'closure/goog/net/jsloader_test.html',
  'closure/goog/net/jsonp_test.html',
  'closure/goog/net/multiiframeloadmonitor_test.html',
  'closure/goog/net/networktester_test.html',
  'closure/goog/net/rpc/httpcors_test.html',
  'closure/goog/net/streams/base64pbstreamparser_test.html',
  'closure/goog/net/streams/base64streamdecoder_test.html',
  'closure/goog/net/streams/jsonstreamparser_test.html',
  'closure/goog/net/streams/pbjsonstreamparser_test.html',
  'closure/goog/net/streams/pbstreamparser_test.html',
  'closure/goog/net/streams/xhrnodereadablestream_test.html',
  'closure/goog/net/streams/xhrstreamreader_test.html',
  'closure/goog/net/websocket_test.html',
  'closure/goog/net/xhriopool_test.html',
  'closure/goog/net/xhrio_test.html',
  'closure/goog/net/xhrmanager_test.html',
  'closure/goog/net/xpc/directtransport_test.html',
  'closure/goog/net/xpc/iframepollingtransport_test.html',
  'closure/goog/net/xpc/nativemessagingtransport_test.html',
  'closure/goog/object/object_test.html',
  'closure/goog/positioning/anchoredposition_test.html',
  'closure/goog/positioning/anchoredviewportposition_test.html',
  'closure/goog/positioning/clientposition_test.html',
  'closure/goog/positioning/menuanchoredposition_test.html',
  'closure/goog/positioning/positioning_test.html',
  'closure/goog/positioning/viewportclientposition_test.html',
  'closure/goog/promise/promise_test.html',
  'closure/goog/proto2/descriptor_test.html',
  'closure/goog/proto2/fielddescriptor_test.html',
  'closure/goog/proto2/message_test.html',
  'closure/goog/proto2/objectserializer_test.html',
  'closure/goog/proto2/pbliteserializer_test.html',
  'closure/goog/proto2/proto_test.html',
  'closure/goog/proto2/textformatserializer_test.html',
  'closure/goog/proto/serializer_test.html',
  'closure/goog/pubsub/pubsub_test.html',
  'closure/goog/pubsub/typedpubsub_test.html',
  'closure/goog/reflect/reflect_test.html',
  'closure/goog/result/chain_test.html',
  'closure/goog/result/combine_test.html',
  'closure/goog/result/deferredadaptor_test.html',
  'closure/goog/result/resultutil_test.html',
  'closure/goog/result/simpleresult_test.html',
  'closure/goog/result/transform_test.html',
  'closure/goog/result/wait_test.html',
  'closure/goog/soy/data_test.html',
  'closure/goog/soy/renderer_test.html',
  'closure/goog/soy/soy_test.html',
  'closure/goog/spell/spellcheck_test.html',
  'closure/goog/stats/basicstat_test.html',
  'closure/goog/storage/collectablestorage_test.html',
  'closure/goog/storage/encryptedstorage_test.html',
  'closure/goog/storage/expiringstorage_test.html',
  'closure/goog/storage/mechanism/errorhandlingmechanism_test.html',
  'closure/goog/storage/mechanism/html5localstorage_test.html',
  'closure/goog/storage/mechanism/html5sessionstorage_test.html',
  'closure/goog/storage/mechanism/html5webstorage_test.html',
  'closure/goog/storage/mechanism/ieuserdata_test.html',
  'closure/goog/storage/mechanism/mechanismfactory_test.html',
  'closure/goog/storage/mechanism/prefixedmechanism_test.html',
  'closure/goog/storage/richstorage_test.html',
  'closure/goog/storage/storage_test.html',
  'closure/goog/string/const_test.html',
  'closure/goog/string/linkify_test.html',
  'closure/goog/string/newlines_test.html',
  'closure/goog/string/path_test.html',
  'closure/goog/string/stringbuffer_test.html',
  'closure/goog/string/stringformat_test.html',
  'closure/goog/string/string_test.html',
  'closure/goog/structs/avltree_test.html',
  'closure/goog/structs/circularbuffer_test.html',
  'closure/goog/structs/collection_test.html',
  'closure/goog/structs/heap_test.html',
  'closure/goog/structs/inversionmap_test.html',
  'closure/goog/structs/linkedmap_test.html',
  'closure/goog/structs/map_test.html',
  'closure/goog/structs/pool_test.html',
  'closure/goog/structs/prioritypool_test.html',
  'closure/goog/structs/priorityqueue_test.html',
  'closure/goog/structs/quadtree_test.html',
  'closure/goog/structs/queue_test.html',
  'closure/goog/structs/set_test.html',
  'closure/goog/structs/stringset_test.html',
  'closure/goog/structs/structs_test.html',
  'closure/goog/structs/treenode_test.html',
  'closure/goog/structs/trie_test.html',
  'closure/goog/style/bidi_test.html',
  'closure/goog/style/cursor_test.html',
  'closure/goog/style/style_document_scroll_test.html',
  'closure/goog/style/style_test.html',
  'closure/goog/style/style_webkit_scrollbars_test.html',
  'closure/goog/style/transform_test.html',
  'closure/goog/style/transition_test.html',
  'closure/goog/testing/asserts_test.html',
  'closure/goog/testing/async/mockcontrol_test.html',
  'closure/goog/testing/asynctestcase_async_test.html',
  'closure/goog/testing/asynctestcase_noasync_test.html',
  'closure/goog/testing/asynctestcase_test.html',
  'closure/goog/testing/continuationtestcase_test.html',
  'closure/goog/testing/deferredtestcase_test.html',
  'closure/goog/testing/dom_test.html',
  'closure/goog/testing/editor/dom_test.html',
  'closure/goog/testing/editor/testhelper_test.html',
  'closure/goog/testing/events/eventobserver_test.html',
  'closure/goog/testing/events/events_test.html',
  'closure/goog/testing/events/matchers_test.html',
  'closure/goog/testing/events/onlinehandler_test.html',
  'closure/goog/testing/expectedfailures_test.html',
  'closure/goog/testing/fs/blob_test.html',
  'closure/goog/testing/fs/directoryentry_test.html',
  'closure/goog/testing/fs/entry_test.html',
  'closure/goog/testing/fs/fileentry_test.html',
  'closure/goog/testing/fs/filereader_test.html',
  'closure/goog/testing/fs/filewriter_test.html',
  'closure/goog/testing/fs/fs_test.html',
  'closure/goog/testing/fs/integration_test.html',
  'closure/goog/testing/functionmock_test.html',
  'closure/goog/testing/i18n/asserts_test.html',
  'closure/goog/testing/loosemock_test.html',
  'closure/goog/testing/mockclassfactory_test.html',
  'closure/goog/testing/mockclock_test.html',
  'closure/goog/testing/mockcontrol_test.html',
  'closure/goog/testing/mockmatchers_test.html',
  'closure/goog/testing/mockrandom_test.html',
  'closure/goog/testing/mockrange_test.html',
  'closure/goog/testing/mockstorage_test.html',
  'closure/goog/testing/mock_test.html',
  'closure/goog/testing/mockuseragent_test.html',
  'closure/goog/testing/multitestrunner_test.html',
  'closure/goog/testing/net/xhrio_test.html',
  'closure/goog/testing/parallel_closure_test_suite_test.html',
  'closure/goog/testing/performancetimer_test.html',
  'closure/goog/testing/propertyreplacer_test.html',
  'closure/goog/testing/proto2/proto2_test.html',
  'closure/goog/testing/pseudorandom_test.html',
  'closure/goog/testing/recordfunction_test.html',
  'closure/goog/testing/shardingtestcase_test.html',
  'closure/goog/testing/singleton_test.html',
  'closure/goog/testing/stacktrace_test.html',
  'closure/goog/testing/strictmock_test.html',
  'closure/goog/testing/style/layoutasserts_test.html',
  'closure/goog/testing/style/style_test.html',
  'closure/goog/testing/testcase_test.html',
  'closure/goog/testing/testrunner_test.html',
  'closure/goog/testing/ui/rendererasserts_test.html',
  'closure/goog/testing/ui/style_test.html',
  'closure/goog/timer/timer_test.html',
  'closure/goog/tweak/entries_test.html',
  'closure/goog/tweak/registry_test.html',
  'closure/goog/tweak/tweakui_test.html',
  'closure/goog/ui/ac/ac_test.html',
  'closure/goog/ui/ac/arraymatcher_test.html',
  'closure/goog/ui/ac/autocomplete_test.html',
  'closure/goog/ui/ac/cachingmatcher_test.html',
  'closure/goog/ui/ac/inputhandler_test.html',
  'closure/goog/ui/ac/remotearraymatcher_test.html',
  'closure/goog/ui/ac/renderer_test.html',
  'closure/goog/ui/ac/richremotearraymatcher_test.html',
  'closure/goog/ui/advancedtooltip_test.html',
  'closure/goog/ui/animatedzippy_test.html',
  'closure/goog/ui/bidiinput_test.html',
  'closure/goog/ui/buttonrenderer_test.html',
  'closure/goog/ui/button_test.html',
  'closure/goog/ui/charcounter_test.html',
  'closure/goog/ui/charpicker_test.html',
  'closure/goog/ui/checkbox_test.html',
  'closure/goog/ui/colormenubuttonrenderer_test.html',
  'closure/goog/ui/colorpalette_test.html',
  'closure/goog/ui/combobox_test.html',
  'closure/goog/ui/component_test.html',
  'closure/goog/ui/containerrenderer_test.html',
  'closure/goog/ui/containerscroller_test.html',
  'closure/goog/ui/container_test.html',
  'closure/goog/ui/controlrenderer_test.html',
  'closure/goog/ui/control_test.html',
  'closure/goog/ui/cookieeditor_test.html',
  'closure/goog/ui/customcolorpalette_test.html',
  'closure/goog/ui/datepicker_test.html',
  'closure/goog/ui/decorate_test.html',
  'closure/goog/ui/dimensionpickerrenderer_test.html',
  'closure/goog/ui/dimensionpicker_test.html',
  'closure/goog/ui/drilldownrow_test.html',
  'closure/goog/ui/editor/abstractdialog_test.html',
  'closure/goog/ui/editor/linkdialog_test.html',
  'closure/goog/ui/editor/toolbarfactory_test.html',
  'closure/goog/ui/emoji/emojipicker_test.html',
  'closure/goog/ui/emoji/popupemojipicker_test.html',
  'closure/goog/ui/emoji/spriteinfo_test.html',
  'closure/goog/ui/filteredmenu_test.html',
  'closure/goog/ui/formpost_test.html',
  'closure/goog/ui/hovercard_test.html',
  'closure/goog/ui/hsvapalette_test.html',
  'closure/goog/ui/hsvpalette_test.html',
  'closure/goog/ui/idletimer_test.html',
  'closure/goog/ui/iframemask_test.html',
  'closure/goog/ui/inputdatepicker_test.html',
  'closure/goog/ui/keyboardshortcuthandler_test.html',
  'closure/goog/ui/media/flashobject_test.html',
  'closure/goog/ui/media/flickr_test.html',
  'closure/goog/ui/media/googlevideo_test.html',
  'closure/goog/ui/media/mediamodel_test.html',
  'closure/goog/ui/media/media_test.html',
  'closure/goog/ui/media/mp3_test.html',
  'closure/goog/ui/media/photo_test.html',
  'closure/goog/ui/media/picasa_test.html',
  'closure/goog/ui/media/vimeo_test.html',
  'closure/goog/ui/media/youtube_test.html',
  'closure/goog/ui/menubuttonrenderer_test.html',
  'closure/goog/ui/menuitemrenderer_test.html',
  'closure/goog/ui/menuitem_test.html',
  'closure/goog/ui/menuseparatorrenderer_test.html',
  'closure/goog/ui/menu_test.html',
  'closure/goog/ui/mockactivitymonitor_test.html',
  'closure/goog/ui/modalariavisibilityhelper_test.html',
  'closure/goog/ui/modalpopup_test.html',
  'closure/goog/ui/nativebuttonrenderer_test.html',
  'closure/goog/ui/paletterenderer_test.html',
  'closure/goog/ui/palette_test.html',
  'closure/goog/ui/plaintextspellchecker_test.html',
  'closure/goog/ui/popupbase_test.html',
  'closure/goog/ui/popupcolorpicker_test.html',
  'closure/goog/ui/popupdatepicker_test.html',
  'closure/goog/ui/popupmenu_test.html',
  'closure/goog/ui/popup_test.html',
  'closure/goog/ui/prompt_test.html',
  'closure/goog/ui/rangemodel_test.html',
  'closure/goog/ui/registry_test.html',
  'closure/goog/ui/richtextspellchecker_test.html',
  'closure/goog/ui/roundedpanel_test.html',
  'closure/goog/ui/scrollfloater_test.html',
  'closure/goog/ui/selectionmenubutton_test.html',
  'closure/goog/ui/selectionmodel_test.html',
  'closure/goog/ui/select_test.html',
  'closure/goog/ui/serverchart_test.html',
  'closure/goog/ui/sliderbase_test.html',
  'closure/goog/ui/splitpane_test.html',
  'closure/goog/ui/style/app/buttonrenderer_test.html',
  'closure/goog/ui/style/app/menubuttonrenderer_test.html',
  'closure/goog/ui/style/app/primaryactionbuttonrenderer_test.html',
  'closure/goog/ui/submenu_test.html',
  'closure/goog/ui/tabbarrenderer_test.html',
  'closure/goog/ui/tabbar_test.html',
  'closure/goog/ui/tablesorter_test.html',
  'closure/goog/ui/tabpane_test.html',
  'closure/goog/ui/tabrenderer_test.html',
  'closure/goog/ui/tab_test.html',
  'closure/goog/ui/textarea_test.html',
  'closure/goog/ui/toolbarcolormenubuttonrenderer_test.html',
  'closure/goog/ui/toolbarseparatorrenderer_test.html',
  'closure/goog/ui/toolbar_test.html',
  'closure/goog/ui/tree/basenode_test.html',
  'closure/goog/ui/tree/treecontrol_test.html',
  'closure/goog/ui/tree/typeahead_test.html',
  'closure/goog/ui/twothumbslider_test.html',
  'closure/goog/ui/zippy_test.html',
  'closure/goog/uri/uri_test.html',
  'closure/goog/uri/utils_test.html',
  'closure/goog/useragent/adobereader_test.html',
  'closure/goog/useragent/flash_test.html',
  'closure/goog/useragent/jscript_test.html',
  'closure/goog/useragent/keyboard_test.html',
  'closure/goog/useragent/platform_test.html',
  'closure/goog/useragent/product_test.html',
  'closure/goog/useragent/useragent_test.html',
  'closure/goog/vec/float32array_test.html',
  'closure/goog/vec/float64array_test.html',
  'closure/goog/vec/mat3d_test.html',
  'closure/goog/vec/mat3f_test.html',
  'closure/goog/vec/mat3_test.html',
  'closure/goog/vec/mat4d_test.html',
  'closure/goog/vec/mat4f_test.html',
  'closure/goog/vec/mat4_test.html',
  'closure/goog/vec/quaternion_test.html',
  'closure/goog/vec/ray_test.html',
  'closure/goog/vec/vec2d_test.html',
  'closure/goog/vec/vec2f_test.html',
  'closure/goog/vec/vec2_test.html',
  'closure/goog/vec/vec3d_test.html',
  'closure/goog/vec/vec3f_test.html',
  'closure/goog/vec/vec3_test.html',
  'closure/goog/vec/vec4d_test.html',
  'closure/goog/vec/vec4f_test.html',
  'closure/goog/vec/vec4_test.html',
  'closure/goog/dom/classes_quirks_test.html',
  'closure/goog/editor/seamlessfield_quirks_test.html',
  'closure/goog/style/style_quirks_test.html',
  'closure/goog/useragent/useragent_quirks_test.html'
];

// If we're running in a nodejs context, export tests. Used when running tests
// externally on Travis.
if (typeof module !== 'undefined' && module.exports) {
  module.exports = _allTests;
}

/**
 * @fileoverview Definitions for node's crypto module. Depends on the buffer module.
 * @see http://nodejs.org/api/crypto.html
 * @see https://github.com/joyent/node/blob/master/lib/crypto.js
 */

var stream = require('stream');

/**
 * @const
 */
var crypto = {};

/**
 * @type {string}
 */
crypto.DEFAULT_ENCODING;

/**
 * @constructor
 */
crypto.Credentials = function () {};

/** @type {string|Buffer} */
crypto.Credentials.prototype.pfx;

/** @type {string|Buffer} */
crypto.Credentials.prototype.key;

/** @type {string} */
crypto.Credentials.prototype.passphrase;

/** @type {string|Buffer} */
crypto.Credentials.prototype.cert;

/** @type {Array.<string|Buffer>} */
crypto.Credentials.prototype.ca;

/** @type {Array.<string>|string} */
crypto.Credentials.prototype.crl;

/** @type {string} */
crypto.Credentials.prototype.ciphers;

/**
 * @param {Object.<string,string>=} details
 * @return {crypto.Credentials}
 */
crypto.createCredentials;

/**
 * @param {string} algorithm
 * @return {crypto.Hash}
 */
crypto.createHash;

/**
 * @param {string} algorithm
 * @param {Object=} options
 * @constructor
 * @extends stream.Transform
 */
crypto.Hash = function(algorithm, options) {};

/**
 * @param {string|Buffer} data
 * @param {string=} input_encoding
 * @return {void}
 */
crypto.Hash.prototype.update;

/**
 * @param {string=} encoding
 * @return {string}
 */
crypto.Hash.prototype.digest;

/**
 * @param {string} algorithm
 * @param {string|Buffer} key
 * @return {crypto.Hmac}
 */
crypto.createHmac;

/**
 * @param {string} hmac
 * @param {string|Buffer} key
 * @param {Object=} options
 * @constructor
 * @extends stream.Transform
 */
crypto.Hmac = function(hmac, key, options) {};

/**
 * @param {string|Buffer} data
 * @return {void}
 */
crypto.Hmac.prototype.update;

/**
 * @param {string} encoding
 * @return {void}
 */
crypto.Hmac.prototype.digest;

/**
 * @param {string} algorithm
 * @param {string|Buffer} password
 * @return {crypto.Cipher}
 */
crypto.createCipher;

/**
 * @param {string} algorithm
 * @param {string|Buffer} key
 * @param {string|Buffer} iv
 * @return {crypto.Cipheriv}
 */
crypto.createCipheriv;

/**
 * @param {string|Buffer} cipher
 * @param {string} password
 * @param {Object=} options
 * @constructor
 * @extends stream.Transform
 */
crypto.Cipher = function(cipher, password, options) {};

/**
 * @param {string|Buffer} data
 * @param {string=} input_encoding
 * @param {string=} output_encoding
 * @return {string|Buffer}
 */
crypto.Cipher.prototype.update;

/**
 * @name crypto.Cipher.prototype.final
 * @param {string=} output_encoding
 * @return {string|Buffer}
 */
crypto.Cipher.prototype.final;

/**
 * @param {boolean=} auto_padding
 * @return {void}
 */
crypto.Cipher.prototype.setAutoPadding;

/**
 * Note:  Cipheriv mixes update, final, and setAutoPadding from Cipher but
 * doesn't inherit directly from Cipher.
 *
 * @param {string} cipher
 * @param {string|Buffer} key
 * @param {string|Buffer} iv
 * @constructor
 * @extends stream.Transform
 */
crypto.Cipheriv = function(cipher, key, iv) {};

/**
 * @param {string|Buffer} data
 * @param {string=} input_encoding
 * @param {string=} output_encoding
 * @return {string|Buffer}
 */
crypto.Cipheriv.prototype.update;

/**
 * @name crypto.Cipheriv.prototype.final
 * @param {string=} output_encoding
 * @return {string|Buffer}
 */
crypto.Cipheriv.prototype.final;

/**
 * @param {boolean=} auto_padding
 * @return {void}
 */
crypto.Cipheriv.prototype.setAutoPadding;

/**
 * @param {string} algorithm
 * @param {string|Buffer} password
 * @return {crypto.Decipher}
 */
crypto.createDecipher;

/**
 * @param {string} algorithm
 * @param {string|Buffer} key
 * @param {string|Buffer} iv
 * @return {crypto.Decipheriv}
 */
crypto.createDecipheriv;

/**
 * Note:  Decipher mixes update, final, and setAutoPadding from Cipher but
 * doesn't inherit directly from Cipher.
 *
 * @param {string|Buffer} cipher
 * @param {string|Buffer} password
 * @param {Object=} options
 * @constructor
 * @extends stream.Transform
 */
crypto.Decipher = function(cipher, password, options) {}

/**
 * @param {string|Buffer} data
 * @param {string=} input_encoding
 * @param {string=} output_encoding
 * @return {string|Buffer}
 */
crypto.Decipher.prototype.update;

/**
 * @name crypto.Decipher.prototype.final
 * @param {string=} output_encoding
 * @return {string|Buffer}
 */
crypto.Decipher.prototype.final;

/**
 * @param {string=} output_encoding
 * @return {string|Buffer}
 */
crypto.Decipher.prototype.finaltol;

/**
 * @param {boolean=} auto_padding
 * @return {void}
 */
crypto.Decipher.prototype.setAutoPadding;

/**
 * Note:  Decipheriv mixes update, final, and setAutoPadding from Cipher but
 * doesn't inherit directly from Cipher.
 *
 * @param {string|Buffer|crypto.Decipheriv} cipher
 * @param {string|Buffer} key
 * @param {string|Buffer} iv
 * @param {Object=} options
 * @constructor
 * @extends stream.Transform
 */
crypto.Decipheriv = function(cipher, key, iv, options) {};

/**
 * @param {string|Buffer} data
 * @param {string=} input_encoding
 * @param {string=} output_encoding
 * @return {string|Buffer}
 */
crypto.Decipheriv.prototype.update;

/**
 * @name crypto.Decipheriv.prototype.final
 * @param {string=} output_encoding
 * @return {string|Buffer}
 */
crypto.Decipheriv.prototype.final;

/**
 * @param {string=} output_encoding
 * @return {string|Buffer}
 */
crypto.Decipheriv.prototype.finaltol;

/**
 * @param {boolean=} auto_padding
 * @return {void}
 */
crypto.Decipheriv.prototype.setAutoPadding;

/**
 * @param {string} algorithm
 * @return {crypto.Sign}
 */
crypto.createSign;

/**
 * @param {string} algorithm
 * @param {Object=} options
 * @constructor
 * @extends stream.Writable
 */
crypto.Sign = function(algorithm, options) {};

/**
 * @param {string|Buffer} data
 * @return {void}
 */
crypto.Sign.prototype.update;

/**
 * @param {string} private_key
 * @param {string=} output_format
 * @return {string|Buffer}
 */
crypto.Sign.prototype.sign;

/**
 * @param {string} algorithm
 * @return crypto.Verify
 */
crypto.createVerify;

/**
 * @param {string} algorithm
 * @param {Object=} options
 * @constructor
 * @extends stream.Writable
 */
crypto.Verify = function(algorithm, options) {};

/**
 * @param {string|Buffer} data
 * @return {void}
 */
crypto.Verify.prototype.update;

/**
 * @param {string} object
 * @param {string|Buffer} signature
 * @param {string=} signature_format
 * @return {boolean}
 */
crypto.Verify.prototype.verify;

/**
 * @param {number} prime
 * @param {string=} encoding
 * @return {crypto.DiffieHellman}
 */
crypto.createDiffieHellman;

/**
 * @param {number} sizeOrKey
 * @param {string=} encoding
 * @constructor
 */
crypto.DiffieHellman = function(sizeOrKey, encoding) {};

/**
 * @param {string=} encoding
 * @return {string|Buffer}
 */
crypto.DiffieHellman.prototype.generateKeys;

/**
 * @param {string|Buffer} key
 * @param {string=} inEnc
 * @param {string=} outEnc
 * @return {string|Buffer}
 */
crypto.DiffieHellman.prototype.computeSecret;

/**
 * @param {string=} encoding
 * @return {string|Buffer}
 */
crypto.DiffieHellman.prototype.getPrime;

/**
 * @param {string=} encoding
 * @return {string|Buffer}
 */
crypto.DiffieHellman.prototype.getGenerator;

/**
 * @param {string=} encoding
 * @return {string|Buffer}
 */
crypto.DiffieHellman.prototype.getPublicKey;

/**
 * @param {string} encoding
 * @return {string|Buffer}
 */
crypto.DiffieHellman.prototype.getPrivateKey = function(encoding) {}

/**
 * @param {string|Buffer} key
 * @param {string=} encoding
 * @return {crypto.DiffieHellman}
 */
crypto.DiffieHellman.prototype.setPublicKey;

/**
 * @param {string|Buffer} key
 * @param {string=} encoding
 * @return {crypto.DiffieHellman}
 */
crypto.DiffieHellman.prototype.setPrivateKey;

/**
 * Note:  DiffieHellmanGroup mixes DiffieHellman but doesn't inherit directly.
 *
 * @param {string} name
 * @constructor
 */
crypto.DiffieHellmanGroup = function(name) {};

/**
 * @param {string=} encoding
 * @return {string|Buffer}
 */
crypto.DiffieHellmanGroup.prototype.generateKeys;

/**
 * @param {string|Buffer} key
 * @param {string=} inEnc
 * @param {string=} outEnc
 * @return {string|Buffer}
 */
crypto.DiffieHellmanGroup.prototype.computeSecret;

/**
 * @param {string=} encoding
 * @return {string|Buffer}
 */
crypto.DiffieHellmanGroup.prototype.getPrime;

/**
 * @param {string=} encoding
 * @return {string|Buffer}
 */
crypto.DiffieHellmanGroup.prototype.getGenerator;

/**
 * @param {string=} encoding
 * @return {string|Buffer}
 */
crypto.DiffieHellmanGroup.prototype.getPublicKey;

/**
 * @param {string} encoding
 * @return {string|Buffer}
 */
crypto.DiffieHellmanGroup.prototype.getPrivateKey = function(encoding) {}

/**
 * @param {string|Buffer} key
 * @param {string=} encoding
 * @return {crypto.DiffieHellmanGroup}
 */
crypto.DiffieHellmanGroup.prototype.setPublicKey;

/**
 * @param {string|Buffer} key
 * @param {string=} encoding
 * @return {crypto.DiffieHellmanGroup}
 */
crypto.DiffieHellmanGroup.prototype.setPrivateKey;

/**
 * @param {string} group_name
 * @return {crypto.DiffieHellmanGroup}
 */
crypto.getDiffieHellman;

/**
 * @param {string|Buffer} password
 * @param {string|Buffer} salt
 * @param {number} iterations
 * @param {number} keylen
 * @param {function(*, string)} callback
 * @return {void}
 */
crypto.pbkdf2;

/**
 * @param {string|Buffer} password
 * @param {string|Buffer} salt
 * @param {number} iterations
 * @param {number} keylen
 * @return {void}
 */
crypto.pbkdf2Sync;

/**
 * @param {number} size
 * @param {function(Error, Buffer)=} callback
 * @return {void}
 */
crypto.randomBytes;

/**
 * @param {number} size
 * @param {function(Error, Buffer)=} callback
 * @return {void}
 */
crypto.pseudoRandomBytes;

/**
 * @param {number} size
 * @param {function(Error, Buffer)=} callback
 * @return {void}
 */
crypto.rng;

/**
 * @param {number} size
 * @param {function(Error, Buffer)=} callback
 * @return {void}
 */
crypto.prng;

/**
 * @return {Array.<string>}
 */
crypto.getCiphers;

/**
 * @return {Array.<string>}
 */
crypto.getHashes;

module.exports = crypto;
**
 * @fileoverview Definitions for node's fs module. Depends on the stream and events module.
 * @see http://nodejs.org/api/fs.html
 * @see https://github.com/joyent/node/blob/master/lib/fs.js
 */

var events = require('events');
var stream = require('stream');

/** @const */
var fs = {};

/**
 * @param {string} oldPath
 * @param {string} newPath
 * @param {function(...)=} callback
 * @return {void}
 */
fs.rename;

/**
 * @param {string} oldPath
 * @param {string} newPath
 * @return {void}
 */
fs.renameSync;

/**
 * @param {*} fd
 * @param {number} len
 * @param {function(...)=} callback
 * @return {void}
 */
fs.truncate;

/**
 * @param {*} fd
 * @param {number} len
 * @return {void}
 */
fs.truncateSync;

/**
 * @param {string} path
 * @param {number} uid
 * @param {number} gid
 * @param {function(...)=} callback
 * @return {void}
 */
fs.chown;

/**
 * @param {string} path
 * @param {number} uid
 * @param {number} gid
 * @return {void}
 */
fs.chownSync;

/**
 * @param {*} fd
 * @param {number} uid
 * @param {number} gid
 * @param {function(...)=} callback
 * @return {void}
 */
fs.fchown;

/**
 * @param {*} fd
 * @param {number} uid
 * @param {number} gid
 * @return {void}
 */
fs.fchownSync;

/**
 * @param {string} path
 * @param {number} uid
 * @param {number} gid
 * @param {function(...)=} callback
 * @return {void}
 */
fs.lchown;

/**
 * @param {string} path
 * @param {number} uid
 * @param {number} gid
 * @return {void}
 */
fs.lchownSync;

/**
 * @param {string} path
 * @param {number} mode
 * @param {function(...)=} callback
 * @return {void}
 */
fs.chmod;

/**
 * @param {string} path
 * @param {number} mode
 * @return {void}
 */
fs.chmodSync;

/**
 * @param {*} fd
 * @param {number} mode
 * @param {function(...)=} callback
 * @return {void}
 */
fs.fchmod;

/**
 * @param {*} fd
 * @param {number} mode
 * @return {void}
 */
fs.fchmodSync;

/**
 * @param {string} path
 * @param {number} mode
 * @param {function(...)=} callback
 * @return {void}
 */
fs.lchmod;

/**
 * @param {string} path
 * @param {number} mode
 * @return {void}
 */
fs.lchmodSync;

/**
 * @param {string} path
 * @param {function(string, fs.Stats)=} callback
 * @return {void}
 */
fs.stat;

/**
 * @param {string} path
 * @return {fs.Stats}
 * @nosideeffects
 */
fs.statSync = function(path) {}

/**
 * @param {*} fd
 * @param {function(string, fs.Stats)=} callback
 * @return {void}
 */
fs.fstat;

/**
 * @param {*} fd
 * @return {fs.Stats}
 * @nosideeffects
 */
fs.fstatSync = function(fd) {}

/**
 * @param {string} path
 * @param {function(string, fs.Stats)=} callback
 * @return {void}
 */
fs.lstat;

/**
 * @param {string} path
 * @return {fs.Stats}
 * @nosideeffects
 */
fs.lstatSync = function(path) {}

/**
 * @param {string} srcpath
 * @param {string} dstpath
 * @param {function(...)=} callback
 * @return {void}
 */
fs.link;

/**
 * @param {string} srcpath
 * @param {string} dstpath
 * @return {void}
 */
fs.linkSync;

/**
 * @param {string} srcpath
 * @param {string} dstpath
 * @param {string=} type
 * @param {function(...)=} callback
 * @return {void}
 */
fs.symlink;

/**
 * @param {string} srcpath
 * @param {string} dstpath
 * @param {string=} type
 * @return {void}
 */
fs.symlinkSync;

/**
 * @param {string} path
 * @param {function(string, string)=} callback
 * @return {void}
 */
fs.readlink;

/**
 * @param {string} path
 * @return {string}
 * @nosideeffects
 */
fs.readlinkSync;

/**
 * @param {string} path
 * @param {Object.<string,string>|function(string, string)=} cache
 * @param {function(string, string)=} callback
 * @return {void}
 */
fs.realpath;

/**
 * @param {string} path
 * @param {Object.<string,string>=} cache
 * @return {string}
 * @nosideeffects
 */
fs.realpathSync;

/**
 * @param {string} path
 * @param {function(...)=} callback
 * @return {void}
 */
fs.unlink;

/**
 * @param {string} path
 * @return {void}
 */
fs.unlinkSync;

/**
 * @param {string} path
 * @param {function(...)=} callback
 * @return {void}
 */
fs.rmdir;

/**
 * @param {string} path
 * @return {void}
 */
fs.rmdirSync;

/**
 * @param {string} path
 * @param {number=} mode
 * @param {function(...)=} callback
 * @return {void}
 */
fs.mkdir;

/**
 * @param {string} path
 * @param {number=} mode
 * @return {void}
 */
fs.mkdirSync;

/**
 * @param {string} path
 * @param {function(string,Array.<string>)=} callback
 * @return {void}
 */
fs.readdir;

/**
 * @param {string} path
 * @return {Array.<string>}
 * @nosideeffects
 */
fs.readdirSync;

/**
 * @param {*} fd
 * @param {function(...)=} callback
 * @return {void}
 */
fs.close;

/**
 * @param {*} fd
 * @return {void}
 */
fs.closeSync;

/**
 * @param {string} path
 * @param {string} flags
 * @param {number=} mode
 * @param {function(string, *)=} callback
 * @return {void}
 */
fs.open;

/**
 * @param {string} path
 * @param {string} flags
 * @param {number=} mode
 * @return {*}
 * @nosideeffects
 */
fs.openSync;

/**
 * @param {string} path
 * @param {number|Date} atime
 * @param {number|Date} mtime
 * @param {function(...)=} callback
 * @return {void}
 */
fs.utimes;

/**
 * @param {string} path
 * @param {number|Date} atime
 * @param {number|Date} mtime
 * @return {void}
 */
fs.utimesSync;

/**
 * @param {*} fd
 * @param {number|Date} atime
 * @param {number|Date} mtime
 * @param {function(...)=} callback
 * @return {void}
 */
fs.futimes;

/**
 * @param {*} fd
 * @param {number|Date} atime
 * @param {number|Date} mtime
 * @return {void}
 */
fs.futimesSync;

/**
 * @param {*} fd
 * @param {function(...)=} callback
 * @return {void}
 */
fs.fsync;

/**
 * @param {*} fd
 * @return {void}
 */
fs.fsyncSync;

/**
 * @param {*} fd
 * @param {*} buffer
 * @param {number} offset
 * @param {number} length
 * @param {number} position
 * @param {function(string, number, *)=} callback
 * @return {void}
 */
fs.write;

/**
 * @param {*} fd
 * @param {*} buffer
 * @param {number} offset
 * @param {number} length
 * @param {number} position
 * @return {number}
 */
fs.writeSync;

/**
 * @param {*} fd
 * @param {*} buffer
 * @param {number} offset
 * @param {number} length
 * @param {number} position
 * @param {function(string, number, *)=} callback
 * @return {void}
 */
fs.read;

/**
 * @param {*} fd
 * @param {*} buffer
 * @param {number} offset
 * @param {number} length
 * @param {number} position
 * @return {number}
 * @nosideeffects
 */
fs.readSync;

/**
 * @param {string} filename
 * @param {string|function(string, *)=}encoding
 * @param {function(string, *)=} callback
 * @return {void}
 */
fs.readFile;

/**
 * @param {string} filename
 * @param {string=} encoding
 * @return {string|Buffer}
 * @nosideeffects
 */
fs.readFileSync;

/**
 * @param {string} filename
 * @param {*} data
 * @param {string|function(string)=} encoding
 * @param {function(string)=} callback
 * @return {void}
 */
fs.writeFile;

/**
 * @param {string} filename
 * @param {*} data
 * @param {string=} encoding
 * @return {void}
 */
fs.writeFileSync;

/**
 * @param {string} filename
 * @param {*} data
 * @param {string|function(string)=} encoding
 * @param {function(string)=} callback
 * @return {void}
 */
fs.appendFile;

/**
 * @param {string} filename
 * @param {*} data
 * @param {string|function(string)=} encoding
 * @return {void}
 */
fs.appendFileSync;

/**
 * @param {string} filename
 * @param {{persistent: boolean, interval: number}|function(*,*)=} options
 * @param {function(*,*)=} listener
 * @return {void}
 */
fs.watchFile;

/**
 * @param {string} filename
 * @param {function(string, string)=} listener
 * @return {void}
 */
fs.unwatchFile;

/**
 *
 * @param {string} filename
 * @param {{persistent: boolean}|function(string, string)=} options
 * @param {function(string, string)=} listener
 * @return {fs.FSWatcher}
 */
fs.watch;

/**
 * @param {string} path
 * @param {function(boolean)} callback
 * @return {void}
 */
fs.exists;

/**
 * @param {string} path
 * @return {boolean}
 * @nosideeffects
 */
fs.existsSync;

/**
 * @constructor
 */
fs.Stats = function () {};

/**
 * @return {boolean}
 * @nosideeffects
 */
fs.Stats.prototype.isFile;

/**
 * @return {boolean}
 * @nosideeffects
 */
fs.Stats.prototype.isDirectory;

/**
 * @return {boolean}
 * @nosideeffects
 */
fs.Stats.prototype.isBlockDevice;

/**
 * @return {boolean}
 * @nosideeffects
 */
fs.Stats.prototype.isCharacterDevice;

/**
 * @return {boolean}
 * @nosideeffects
 */
fs.Stats.prototype.isSymbolicLink;

/**
 * @return {boolean}
 * @nosideeffects
 */
fs.Stats.prototype.isFIFO;

/**
 * @return {boolean}
 * @nosideeffects
 */
fs.Stats.prototype.isSocket;

/**
 * @type {number}
 */
fs.Stats.prototype.dev = 0;

/**
 * @type {number}
 */
fs.Stats.prototype.ino = 0;

/**
 * @type {number}
 */
fs.Stats.prototype.mode = 0;

/**
 * @type {number}
 */
fs.Stats.prototype.nlink = 0;

/**
 * @type {number}
 */
fs.Stats.prototype.uid = 0;

/**
 * @type {number}
 */
fs.Stats.prototype.gid = 0;

/**
 * @type {number}
 */
fs.Stats.prototype.rdev = 0;

/**
 * @type {number}
 */
fs.Stats.prototype.size = 0;

/**
 * @type {number}
 */
fs.Stats.prototype.blkSize = 0;

/**
 * @type {number}
 */
fs.Stats.prototype.blocks = 0;

/**
 * @type {Date}
 */
fs.Stats.prototype.atime;

/**
 * @type {Date}
 */
fs.Stats.prototype.mtime;

/**
 * @type {Date}
 */
fs.Stats.prototype.ctime;

/**
 * @param {string} path
 * @param {{flags: string, encoding: ?string, fd: *, mode: number, bufferSize: number}=} options
 * @return {fs.ReadStream}
 * @nosideeffects
 */
fs.createReadStream;

/**
 * @constructor
 * @extends stream.ReadableStream
 */
fs.ReadStream = function () {};

/**
 * @param {string} path
 * @param {{flags: string, encoding: ?string, mode: number}=} options
 * @return {fs.WriteStream}
 * @nosideeffects
 */
fs.createWriteStream;

/**
 * @constructor
 * @extends stream.WritableStream
 */
fs.WriteStream = function () {};

/**
 * @constructor
 * @extends events.EventEmitter
 */
fs.FSWatcher = function () {};

/**
 * @return {void}
 */
fs.FSWatcher.prototype.close;

/**
 * @fileoverview NodeJS built-ins.
 * @externs
 * @author nicholas.j.santos@gmail.com (Nick Santos)
 */

/** @const {string} */
var __filename;

/** @const {string} */
var __dirname;

/**
 * @param {string} name
 * @return {?}
 */
function require(name) {}

// http://nodejs.org/api/timers.html

/**
 * The ID returned by setTimeout.
 * @constructor
 */
function TimeoutId() {}

/** @see http://nodejs.org/api/timers.html#timers_unref */
TimeoutId.prototype.unref = function() {};

/** @see http://nodejs.org/api/timers.html#timers_ref */
TimeoutId.prototype.ref = function() {};


/**
 * @param {Function} fn
 * @param {number} ms
 * @param {...?} var_args
 * @return {TimeoutId}
 * @see http://nodejs.org/api/timers.html#timers_settimeout_callback_delay_arg
 */
function setTimeout(fn, ms, var_args) {}

/**
 * @param {TimeoutId} id
 * @see http://nodejs.org/api/timers.html#timers_cleartimeout_timeoutid
 */
function clearTimeout(id) {}

/**
 * @param {Function} fn
 * @param {number} ms
 * @param {...?} var_args
 * @return {TimeoutId}
 * @see http://nodejs.org/api/timers.html#timers_setinterval_callback_delay_arg
 */
function setInterval(fn, ms, var_args) {}

/**
 * @param {TimeoutId} id
 * @see http://nodejs.org/api/timers.html#timers_clearinterval_intervalid
 */
function clearInterval(id) {}

/**
 * The ID returned by setImmediate.
 * @constructor
 */
function ImmediateId() {}

/**
 * @param {Function} fn
 * @param {...?} var_args
 * @return {ImmediateId}
 * @see http://nodejs.org/api/timers.html#timers_setimmediate_callback_delay_arg
 */
function setImmediate(fn, var_args) {}

/**
 * @param {ImmediateId} id
 * @see http://nodejs.org/api/timers.html#timers_clearimmediate_immediateid
 */
function clearImmediate(id) {}


// http://nodejs.org/api/process.html

/** @constructor */
function Process() {}

/**
 * @return {void}
 * @see http://nodejs.org/api/process.html#process_process_abort
 */
Process.prototype.abort = function () {};

/**
 * @type {string}
 * @see http://nodejs.org/api/process.html#process_process_arch
 */
Process.prototype.arch;

/**
 * @type {!Array<string>}
 * @see http://nodejs.org/api/process.html#process_process_argv
 */
Process.prototype.argv;

/**
 * @param {string} directory
 * @see http://nodejs.org/api/process.html#process_process_chdir_directory
 */
Process.prototype.chdir = function (directory) {};

/**
 * @type {*}
 * @see http://nodejs.org/api/process.html#process_process_config
 */
Process.prototype.config;

/**
 * @type {boolean}
 * @see http://nodejs.org/api/process.html#process_process_connected
 */
Process.prototype.connected;

/**
 * @return {string}
 * @see http://nodejs.org/api/process.html#process_process_cwd
 */
Process.prototype.cwd = function () {};

/**
 * @return {void}
 * @see http://nodejs.org/api/process.html#process_process_disconnect
 */
Process.prototype.disconnect = function () {};

/**
 * @type {*}
 * @see http://nodejs.org/api/process.html#process_process_env
 */
Process.prototype.env;

/**
 * @param {number=} code
 * @see http://nodejs.org/api/process.html#process_process_exit_code
 */
Process.prototype.exit = function (code) {};

/**
 * @param {number} pid
 * @param {string|number} signal
 * @see http://nodejs.org/api/process.html#process_process_kill_pid_signal
 */
Process.prototype.kill = function (pid, signal) {};

/**
 * @param {!Function} fn
 * @param {...*} var_args
 * @see http://nodejs.org/api/process.html#process_process_nexttick_callback_arg
 */
Process.prototype.nextTick = function (fn, var_args) {};

/**
 * @type {string}
 * @see http://nodejs.org/api/process.html#process_process_pid
 */
Process.prototype.pid;

/**
 * @type {string}
 * @see http://nodejs.org/api/process.html#process_process_platform
 */
Process.prototype.platform;

/**
 * @type {*}
 * @see http://nodejs.org/api/process.html#process_process_release
 */
Process.prototype.release;

/**
 * @return {number}
 * @see http://nodejs.org/api/process.html#process_process_uptime
 */
Process.prototype.uptime = function () {};

/**
 * @type {string}
 * @see http://nodejs.org/api/process.html#process_process_version
 */
Process.prototype.version;

/**
 * @type {*}
 * @see http://nodejs.org/api/process.html#process_process_versions
 */
Process.prototype.versions;

/** @const {Process} */
var process;

/**
 * @constructor
 * @see http://trac.webkit.org/browser/trunk/Source/WebCore/page/Console.idl
 * @see http://trac.webkit.org/browser/trunk/Source/WebCore/page/Console.cpp
 */
function Console() {};

/**
 * @param {*} condition
 * @param {...*} var_args
 */
Console.prototype.assert = function(condition, var_args) {};

/**
 * @param {...*} var_args
 */
Console.prototype.error = function(var_args) {};

/**
 * @param {...*} var_args
 */
Console.prototype.info = function(var_args) {};

/**
 * @param {...*} var_args
 */
Console.prototype.log = function(var_args) {};

/**
 * @param {...*} var_args
 */
Console.prototype.warn = function(var_args) {};

/**
 * @param {...*} var_args
 */
Console.prototype.debug = function(var_args) {};

/**
 * @param {*} value
 */
Console.prototype.dir = function(value) {};

/**
 * @param {...*} var_args
 */
Console.prototype.dirxml = function(var_args) {};

/**
 * @param {!Object} data
 * @param {*=} opt_columns
 */
Console.prototype.table = function(data, opt_columns) {};

/**
 * @return {undefined}
 */
Console.prototype.trace = function() {};

/**
 * @param {*} value
 */
Console.prototype.count = function(value) {};

/**
 * @param {*} value
 */
Console.prototype.markTimeline = function(value) {};

/**
 * @param {string=} opt_title
 */
Console.prototype.profile = function(opt_title) {};

/**
 * @param {string=} opt_title
 */
Console.prototype.profileEnd = function(opt_title) {};

/**
 * @param {string} name
 */
Console.prototype.time = function(name) {};

/**
 * @param {string} name
 */
Console.prototype.timeEnd = function(name) {};

/**
 * @param {*} value
 */
Console.prototype.timeStamp = function(value) {};

/**
 * @param {...*} var_args
 */
Console.prototype.group = function(var_args) {};

/**
 * @param {...*} var_args
 */
Console.prototype.groupCollapsed = function(var_args) {};

/** @return {void} */
Console.prototype.groupEnd = function() {};

/** @return {void} */
Console.prototype.clear = function() {};

/**
 * @type {!Console}
 */
var console;



/**
 * @param {...*} var_args
 * @constructor
 * @nosideeffects
 */
var Buffer = function (var_args) {};

/**
 * @param {string} encoding
 * @return {boolean}
 */
Buffer.isEncoding;

/**
 * @param {*} obj
 * @return {boolean}
 * @nosideeffects
 */
Buffer.isBuffer;

/**
 * @param {string} string
 * @param {string=} encoding
 * @return {number}
 * @nosideeffects
 */
Buffer.byteLength;

/**
 * @param {Array.<Buffer>} list
 * @param {number=} totalLength
 * @return {Buffer}
 * @nosideeffects
 */
Buffer.concat;

/**
 * @param {number} offset
 * @return {*}
 */
Buffer.prototype.get;

/**
 * @param {number} offset
 * @param {*} v
 */
Buffer.prototype.set;

/**
 * @param {string} string
 * @param {number|string=} offset
 * @param {number|string=} length
 * @param {number|string=} encoding
 * @return {*}
 */
Buffer.prototype.write;

/**
 * @return {Array}
 */
Buffer.prototype.toJSON;

/**
 * @type {number}
 */
Buffer.prototype.length;

/**
 * @param {Buffer} targetBuffer
 * @param {number=} targetStart
 * @param {number=} sourceStart
 * @param {number=} sourceEnd
 * @return {Buffer}
 */
Buffer.prototype.copy;

/**
 * @param {number=} start
 * @param {number=} end
 * @return {Buffer}
 * @nosideeffects
 */
Buffer.prototype.slice;

/**
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.readUInt8;

/**
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.readUInt16LE;

/**
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.readUInt16BE;

/**
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.readUInt32LE;

/**
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.readUInt32BE;

/**
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.readInt8;

/**
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.readInt16LE;

/**
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.readInt16BE;

/**
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.readInt32LE;

/**
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.readInt32BE;

/**
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.readFloatLE;

/**
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.readFloatBE;

/**
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.readDoubleLE;

/**
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.readDoubleBE;

/**
 * @param {number} value
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.writeUInt8;

/**
 * @param {number} value
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.writeUInt16LE;

/**
 * @param {number} value
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.writeUInt16BE;

/**
 * @param {number} value
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.writeUInt32LE;

/**
 * @param {number} value
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.writeUInt32BE;

/**
 * @param {number} value
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.writeInt8;

/**
 * @param {number} value
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.writeInt16LE;

/**
 * @param {number} value
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.writeInt16BE;

/**
 * @param {number} value
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.writeInt32LE;

/**
 * @param {number} value
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.writeInt32BE;

/**
 * @param {number} value
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.writeFloatLE;

/**
 * @param {number} value
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.writeFloatBE;

/**
 * @param {number} value
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.writeDoubleLE;

/**
 * @param {number} value
 * @param {number} offset
 * @param {boolean=} noAssert
 * @return {number}
 */
Buffer.prototype.writeDoubleBE;

/**
 * @param {*} value
 * @param {number=} offset
 * @param {number=} end
 * @return {void}
 */
Buffer.prototype.fill;

/**
 * @param {string=} encoding
 * @param {number=} start
 * @param {number=} end
 * @return {string}
 * @nosideeffects
 */
Buffer.prototype.toString;

/**
 * @type {number}
 */
Buffer.INSPECT_MAX_BYTES = 50;

//
// Legacy
//

/**
 * @param {number=} start
 * @param {number=} end
 * @return {Buffer}
 */
Buffer.prototype.utf8Slice;

/**
 * @param {number=} start
 * @param {number=} end
 * @return {Buffer}
 */
Buffer.prototype.binarySlice;

/**
 * @param {number=} start
 * @param {number=} end
 * @return {Buffer}
 */
Buffer.prototype.asciiSlice;

/**
 * @param {string} string
 * @param {number=} offset
 * @return {Buffer}
 */
Buffer.prototype.utf8Write;

/**
 * @param {string} string
 * @param {number=} offset
 * @return {Buffer}
 */
Buffer.prototype.binaryWrite;

/**
 * @param {string} string
 * @param {number=} offset
 * @return {Buffer}
 */


/**
 * @fileoverview Externs for Ace Editor API v. 1.2.3.
 * @see https://ace.c9.io/#nav=api
 * @externs
 */

/**
 * The main class required to set up an Ace instance in the browser.
 * @const
 * @see https://ace.c9.io/#nav=api&api=ace
 */
var ace;

/**
 * Creates a new EditSession, and returns the associated Document.
 * @param {(!ace.Document|string)} text
 * @param {?} mode // TODO: define !ace.Mode.
 * @return {!ace.Document}
 */
ace.createEditSession = function(text, mode) {};

/**
 * Embeds the Ace editor into the DOM, at the element provided by el.
 * @param {(string|!Element)} el
 * @return {!ace.Editor}
 */
ace.edit = function(el) {};

/**
 * Provides access to require in packed noconflict mode.
 * @param {string} moduleName
 * @return {!Object}
 */
ace.require = function(moduleName) {};

/**
 * Creates a new Anchor and associates it with a document.
 * @constructor
 * @param {!ace.Document} doc
 * @param {number} row
 * @param {number} column
 * @see https://ace.c9.io/#nav=api&api=anchor
 */
ace.Anchor = function(doc, row, column) {};

/**
 * Fires whenever the anchor position changes.
 * @param {string} event
 * @param {function(!Object)} fn
 */
ace.Anchor.prototype.on = function(event, fn) {};

/**
 * When called, the 'change' event listener is removed.
 */
ace.Anchor.prototype.detach = function() {};

/**
 * Returns the current document.
 * @return {!ace.Document}
 */
ace.Anchor.prototype.getDocument = function() {};

/**
 * Returns an object identifying the row and column position of the current
 * anchor.
 * @return {!Object}
 */
ace.Anchor.prototype.getPosition = function() {};

/** Undocumented */
ace.Anchor.prototype.onChange = function() {};

/**
 * Sets the anchor position to the specified row and column. If noClip is true,
 * the position is not clipped.
 * @param {number} row
 * @param {number} column
 * @param {boolean} noClip
 */
ace.Anchor.prototype.setPosition = function(row, column, noClip) {};

/**
 * Creates a new BackgroundTokenizer object.
 * @constructor
 * @param {!ace.Tokenizer} tokenizer
 * @param {!ace.Editor} editor
 * @see https://ace.c9.io/#nav=api&api=background_tokenizer
 */
ace.BackgroundTokenizer = function(tokenizer, editor) {};

/**
 * @param {string} event
 * @param {function(!Object)} fn
 */
ace.BackgroundTokenizer.prototype.on = function(event, fn) {};

/**
 * Emits the 'update' event. firstRow and lastRow are used to define the
 * boundaries of the region to be updated.
 * @param {number} firstRow
 * @param {number} lastRow
 */
ace.BackgroundTokenizer.prototype.fireUpdateEvent = function(firstRow, lastRow) {};

/**
 * Returns the state of tokenization at the end of a row.
 * @param {number} row
 * @return {!Object}
 */
ace.BackgroundTokenizer.prototype.getState = function(row) {};

/**
 * Gives list of tokens of the row (tokens are cached).
 * @param {number} row
 */
ace.BackgroundTokenizer.prototype.getTokens = function(row) {};

/**
 * Sets a new document to associate with this object.
 * @param {!ace.Document} doc
 */
ace.BackgroundTokenizer.prototype.setDocument = function(doc) {};

/**
 * Sets a new tokenizer for this object.
 * @param {!ace.Tokenizer} tokenizer
 */
ace.BackgroundTokenizer.prototype.setTokenizer = function(tokenizer) {};

/**
 * Starts tokenizing at the row indicated.
 * @param {number} startRow
 */
ace.BackgroundTokenizer.prototype.start = function(startRow) {};

/**
 * Stops tokenizing.
 */
ace.BackgroundTokenizer.prototype.stop = function() {};

/**
 * Creates a new Document. If text is included, the Document contains those
 * strings; otherwise, it's empty.
 * @constructor
 * @param {(string|!Array<string>)} text
 * @see https://ace.c9.io/#nav=api&api=document
 */
ace.Document = function(text) {};

/**
 * Fires whenever the document changes.
 * @param {string} event
 * @param {function(!Object)} fn
 */
ace.Document.prototype.on = function(event, fn) {};

/**
 * Applies all the changes previously accumulated.
 * These can be either 'includeText', 'insertLines', 'removeText', and
 * 'removeLines'.
 * @param {!Object} deltas
 */
ace.Document.prototype.applyDeltas = function(deltas) {};

/**
 * Creates a new Anchor to define a floating point in the document.
 * @param {number} row
 * @param {number} column
 */
ace.Document.prototype.createAnchor = function(row, column) {};

/**
 * Returns all lines in the document as string array.
 * @return {!Array<string>}
 */
ace.Document.prototype.getAllLines = function() {};

/**
 * Returns the number of rows in the document.
 * @return {number}
 */
ace.Document.prototype.getLength = function() {};

/**
 * Returns a verbatim copy of the given line as it is in the document
 * @param {number} row
 * @return {!Object}
 */
ace.Document.prototype.getLine = function(row) {};

/**
 * Returns an array of strings of the rows between firstRow and lastRow. This
 * function is inclusive of lastRow.
 * @param {number} firstRow
 * @param {number} lastRow
 * @return {!Array<string>}
 */
ace.Document.prototype.getLines = function(firstRow, lastRow) {};

/**
 * Returns the newline character that's being used, depending on the value of
 * newLineMode.
 * @return {string}
 */
ace.Document.prototype.getNewLineCharacter = function() {};

/**
 * Returns the type of newlines being used; either windows, unix, or auto.
 * @return {string}
 */
ace.Document.prototype.getNewLineMode = function() {};

/**
 * Given a range within the document, this function returns all the text within
 * that range as a single string.
 * @param {!ace.Range} range
 * @return {string}
 */
ace.Document.prototype.getTextRange = function(range) {};

/**
 * Returns all the lines in the document as a single string, split by the new
 * line character.
 * @return {string}
 */
ace.Document.prototype.getValue = function() {};

/**
 * Converts an index position in a document to a {row, column} object.
 * @param {number} index
 * @param {number} startRow
 * @return {{row: number, column: number}}
 */
ace.Document.prototype.indexToPosition = function(index, startRow) {};

/**
 * Inserts a block of text and the indicated position.
 * @param {!Object} position
 * @param {string} text
 * @return {!Object}
 */
ace.Document.prototype.insert = function(position, text) {};

/**
 * Inserts text into the position at the current row. This method also triggers
 * the 'change' event.
 * @param {!Object} position
 * @param {string} text
 * @return {!Object}
 */
ace.Document.prototype.insertInLine = function(position, text) {};

/**
 * Inserts the elements in lines into the document, starting at the row index
 * given by row.
 * This method also triggers the 'change' event.
 * @param {number} row
 * @param {!Array<number>} lines
 * @return {!Object}
 */
ace.Document.prototype.insertLines = function(row, lines) {};

/**
 * Inserts a new line into the document at the current row's position.
 * This method also triggers the 'change' event.
 * @param {!Object} position
 * @return {!Object}
 */
ace.Document.prototype.insertNewLine = function(position) {};

/**
 * Returns true if text is a newline character (either \r\n, \r, or \n).
 * @param {string} text
 * @return {boolean}
 */
ace.Document.prototype.isNewLine = function(text) {};

/**
 * Converts the {row, column} position in a document to the character's index.
 * @param {{row: number, column: number}} pos
 * @param {number} startRow
 * @return {number}
 */
ace.Document.prototype.positionToIndex = function(pos, startRow) {};

/**
 * Removes the range from the document.
 * @param {!ace.Range} range
 * @return {!Object}
 */
ace.Document.prototype.remove = function(range) {};

/**
 * Removes the specified columns from the row. This method also triggers the
 * 'change' event.
 * @param {number} row
 * @param {number} startColumn
 * @param {number} endColumn
 * @return {!Object}
 */
ace.Document.prototype.removeInLine = function(row, startColumn, endColumn) {};

/**
 * Removes a range of full lines. This method also triggers the 'change' event.
 * @param {number} firstRow
 * @param {number} lastRow
 * @return {string}
 */
ace.Document.prototype.removeLines = function(firstRow, lastRow) {};

/**
 * Removes the new line between row and the row immediately following it.
 * This method also triggers the 'change' event.
 * @param {number} row
 */
ace.Document.prototype.removeNewLine = function(row) {};

/**
 * Replaces a range in the document with the new text.
 * @param {!ace.Range} range
 * @param {string} text
 * @return {!Object}
 */
ace.Document.prototype.replace = function(range, text) {};

/**
 * Reverts any changes previously applied.
 * These can be either 'includeText', 'insertLines', 'removeText', and
 * 'removeLines'.
 * @param {!Object} deltas
 */
ace.Document.prototype.revertDeltas = function(deltas) {};

/**
 * Sets the new line mode.
 * @param {string} newLineMode
 */
ace.Document.prototype.setNewLineMode = function(newLineMode) {};

/**
 * Replaces all the lines in the current Document with the value of text.
 * @param {string} text
 */
ace.Document.prototype.setValue = function(text) {};

/**
 * Stores all the data about Editor state providing easy way to change editor's
 * state.
 * @constructor
 * @param {(!ace.Document|string)} text
 * @param {?} mode
 * @see https://ace.c9.io/#nav=api&api=edit_session
 */
ace.EditSession = function(text, mode) {};

/**
 * Adds a dynamic marker to the session.
 * @param {!Object} marker
 * @param {boolean} inFront
 * @return {!Object}
 */
ace.EditSession.prototype.addDynamicMarker = function(marker, inFront) {};

/**
 * Adds className to the row, to be used for CSS stylings and whatnot.
 * @param {number} row
 * @param {string} className
 */
ace.EditSession.prototype.addGutterDecoration = function(row, className) {};

/**
 * Adds a new marker to the given Range. If inFront is true, a front marker is
 * defined, and the 'changeFrontMarker' event fires; otherwise, the
 * 'changeBackMarker' event fires.
 * @param {!ace.Range} range
 * @param {string} clazz
 * @param {!Function|string} type
 * @param {boolean} inFront
 * @return {number}
 */
ace.EditSession.prototype.addMarker = function(range, clazz, type, inFront) {};

/**
 * Clears all the annotations for this session. This function also triggers the
 * 'changeAnnotation' event.
 */
ace.EditSession.prototype.clearAnnotations = function() {};

/**
 * Removes a breakpoint on the row number given by rows. This function also
 * emits the 'changeBreakpoint' event.
 * @param {number} row
 */
ace.EditSession.prototype.clearBreakpoint = function(row) {};

/**
 * Removes all breakpoints on the rows. This function also emits the
 * 'changeBreakpoint' event.
 */
ace.EditSession.prototype.clearBreakpoints = function() {};

/**
 * For the given document row and column, returns the screen column.
 * @param {number} row
 * @param {number} docColumn
 * @return {number}
 */
ace.EditSession.prototype.documentToScreenColumn = function(row, docColumn) {};

/**
 * Converts document coordinates to screen coordinates.
 * This takes into account code folding, word wrap, tab size, and any other
 * visual modifications.
 * @param {number} docRow
 * @param {number} docColumn
 * @return {!Object}
 */
ace.EditSession.prototype.documentToScreenPosition = function(docRow, docColumn) {};

/**
 * For the given document row and column, returns the screen row.
 * @param {number} docRow
 * @param {number} docColumn
 * @return {number}
 */
ace.EditSession.prototype.documentToScreenRow = function(docRow, docColumn) {};

/**
 * Duplicates all the text between firstRow and lastRow.
 * @param {number} firstRow
 * @param {number} lastRow
 * @return {number}
 */
ace.EditSession.prototype.duplicateLines = function(firstRow, lastRow) {};

/**
 * Returns the annotations for the EditSession.
 * @return {!Object}
 */
ace.EditSession.prototype.getAnnotations = function() {};

/**
 * Gets the range of a word, including its right whitespace.
 * @param {number} row
 * @param {number} column
 * @return {!ace.Range}
 */
ace.EditSession.prototype.getAWordRange = function(row, column) {};

/**
 * Returns an array of numbers, indicating which rows have breakpoints.
 * @return {number}
 */
ace.EditSession.prototype.getBreakpoints = function() {};

/**
 * Returns the Document associated with this session.
 * @return {!ace.Document}
 */
ace.EditSession.prototype.getDocument = function() {};

/**
 * For the given document row and column, this returns the column position of
 * the last screen row.
 * @param {number} docRow
 * @param {number} docColumn
 * @return {number}
 */
ace.EditSession.prototype.getDocumentLastRowColumn = function(docRow, docColumn) {};

/**
 * For the given document row and column, this returns the document position of
 * the last row.
 * @param {number} docRow
 * @param {number} docColumn
 * @return {!Object}
 */
ace.EditSession.prototype.getDocumentLastRowColumnPosition = function(docRow, docColumn) {};

/**
 * Returns the number of rows in the document.
 * @return {number}
 */
ace.EditSession.prototype.getLength = function() {};

/**
 * Returns a verbatim copy of the given line as it is in the document
 * @param {number} row
 * @return {string}
 */
ace.EditSession.prototype.getLine = function(row) {};

/**
 * Returns an array of strings of the rows between firstRow and lastRow.
 * This function is inclusive of lastRow.
 * @param {number} firstRow
 * @param {number} lastRow
 * @return {string}
 */
ace.EditSession.prototype.getLines = function(firstRow, lastRow) {};

/**
 * Returns an array containing the IDs of all the markers, either front or back.
 * @param {boolean} inFront
 * @return {!Array<string>}
 */
ace.EditSession.prototype.getMarkers = function(inFront) {};

/**
 * Returns the current text mode.
 * @return {!Object}
 */
ace.EditSession.prototype.getMode = function() {};

/**
 * Returns the current new line mode.
 * @return {string}
 */
ace.EditSession.prototype.getNewLineMode = function() {};

/**
 * Returns true if overwrites are enabled; false otherwise.
 * @return {boolean}
 */
ace.EditSession.prototype.getOverwrite = function() {};

/**
 * Returns number of screenrows in a wrapped line.
 * @param {number} row
 * @return {number}
 */
ace.EditSession.prototype.getRowLength = function(row) {};

/**
 * For the given row, this returns the split data.
 * @param {!Object} row
 * @return {string}
 */
ace.EditSession.prototype.getRowSplitData = function(row) {};

/**
 * Returns the position (on screen) for the last character in the provided
 * screen row.
 * @param {number} screenRow
 * @return {number}
 */
ace.EditSession.prototype.getScreenLastRowColumn = function(screenRow) {};

/**
 * Returns the length of the screen.
 * @return {number}
 */
ace.EditSession.prototype.getScreenLength = function() {};

/**
 * The distance to the next tab stop at the specified screen column.
 * @param {number} screenColumn
 * @return {number}
 */
ace.EditSession.prototype.getScreenTabSize = function(screenColumn) {};

/**
 * Returns the width of the screen.
 * @return {number}
 */
ace.EditSession.prototype.getScreenWidth = function() {};

/**
 * Returns the value of the distance between the left of the editor and the
 * leftmost part of the visible content.
 * @return {number}
 */
ace.EditSession.prototype.getScrollLeft = function() {};

/**
 * Returns the value of the distance between the top of the editor and the
 * topmost part of the visible content.
 * @return {number}
 */
ace.EditSession.prototype.getScrollTop = function() {};

/**
 * Returns selection object.
 * @return {!Object}
 */
ace.EditSession.prototype.getSelection = function() {};

/**
 * Returns the state of tokenization at the end of a row.
 * @param {number} row
 * @return {!Object}
 */
ace.EditSession.prototype.getState = function(row) {};

/**
 * Returns the current tab size.
 * @return {number}
 */
ace.EditSession.prototype.getTabSize = function() {};

/**
 * Returns the current value for tabs. If the user is using soft tabs, this
 * will be a series of spaces (defined by getTabSize()); otherwise it's simply
 * '\t'.
 * @return {string}
 */
ace.EditSession.prototype.getTabString = function() {};

/**
 * Given a range within the document, this function returns all the text
 * within that range as a single string.
 * @param {!ace.Range} range
 * @return {string}
 */
ace.EditSession.prototype.getTextRange = function(range) {};

/**
 * Returns an object indicating the token at the current row. The object has
 * two properties: index and start.
 * @param {number} row
 * @param {number} column
 * @return {!Object}
 */
ace.EditSession.prototype.getTokenAt = function(row, column) {};

/**
 * Starts tokenizing at the row indicated. Returns a list of objects of the
 * tokenized rows.
 * @param {number} row
 * @return {!Array<!Object>} row
 */
ace.EditSession.prototype.getTokens = function(row) {};

/**
 * Returns the current undo manager.
 * @return {!ace.UndoManager}
 */
ace.EditSession.prototype.getUndoManager = function() {};

/**
 * Returns true if soft tabs are being used, false otherwise.
 * @return {boolean}
 */
ace.EditSession.prototype.getUseSoftTabs = function() {};

/**
 * Returns true if workers are being used.
 * @return {boolean}
 */
ace.EditSession.prototype.getUseWorker = function() {};

/**
 * Returns true if wrap mode is being used; false otherwise.
 * @return {boolean}
 */
ace.EditSession.prototype.getUseWrapMode = function() {};

/**
 * Returns the current Document as a string.
 * @return {string}
 */
ace.EditSession.prototype.getValue = function() {};

/**
 * Given a starting row and column, this method returns the Range of the first
 * word boundary it finds.
 * @param {number} row
 * @param {number} column
 * @return {!ace.Range}
 */
ace.EditSession.prototype.getWordRange = function(row, column) {};

/**
 * Returns the value of wrap limit.
 * @return {number}
 */
ace.EditSession.prototype.getWrapLimit = function() {};

/**
 * Returns an object that defines the minimum and maximum of the wrap limit.
 * @return {!Object}
 */
ace.EditSession.prototype.getWrapLimitRange = function() {};

/** Undocumented */
ace.EditSession.prototype.highlight = function() {};

/** Undocumented */
ace.EditSession.prototype.highlightLines = function() {};

/**
 * Indents all the rows, from startRow to endRow (inclusive), by prefixing each
 * row with the token in indentString.
 * @param {number} startRow
 * @param {number} endRow
 * @param {string} indentString
 */
ace.EditSession.prototype.indentRows = function(startRow, endRow, indentString) {};

/**
 * Inserts a block of text and the indicated position.
 * @param {!Object} position
 * @param {string} text
 * @return {!Object}
 */
ace.EditSession.prototype.insert = function(position, text) {};

/**
 * Returns true if the character at the position is a soft tab.
 * @param {!Object} position
 * @return {boolean}
 */
ace.EditSession.prototype.isTabStop = function(position) {};

/**
 * Shifts all the lines in the document down one, starting from firstRow and
 * ending at lastRow.
 * @param {number} firstRow
 * @param {number} lastRow
 * @return {number}
 */
ace.EditSession.prototype.moveLinesDown = function(firstRow, lastRow) {};

/**
 * Shifts all the lines in the document up one, starting from firstRow and
 * ending at lastRow.
 * @param {number} firstRow
 * @param {number} lastRow
 * @return {number}
 */
ace.EditSession.prototype.moveLinesUp = function(firstRow, lastRow) {};

/**
 * Moves a range of text from the given range to the given position.toPosition
 * is an object that looks like this:
 * { row: newRowLocation, column: newColumnLocation }
 * @param {!ace.Range} fromRange
 * @param {{row: number, column: number}} toPosition
 * @return {!ace.Range}
 */
ace.EditSession.prototype.moveText = function(fromRange, toPosition) {};

/**
 * @param {string} event
 * @param {function((Object|number|null))} fn
 */
ace.EditSession.prototype.on = function(event, fn) {};

/** Undocumented */
ace.EditSession.prototype.onChange = function() {};

/** Undocumented */
ace.EditSession.prototype.onChangeFold = function() {};

/**
 * Reloads all the tokens on the current session. This function calls
 * BackgroundTokenizer.start() to all the rows;
 * it also emits the 'tokenizerUpdate' event.
 * @param {!Object} e
 */
ace.EditSession.prototype.onReloadTokenizer = function(e) {};

/**
 * Outdents all the rows defined by the start and end properties of range.
 * @param {!ace.Range} range
 */
ace.EditSession.prototype.outdentRows = function(range) {};

/** Undocumented */
ace.EditSession.prototype.redo = function() {};

/**
 * Re-implements a previously undone change to your document.
 * @param {!Array<!Object>} deltas
 * @param {boolean} dontSelect
 * @return {!ace.Range}
 */
ace.EditSession.prototype.redoChanges = function(deltas, dontSelect) {};

/**
 * Removes the range from the document.
 * @param {!ace.Range} range
 * @return {!Object}
 */
ace.EditSession.prototype.remove = function(range) {};

/**
 * Removes className from the row.
 * @param {number} row
 * @param {string} className
 */
ace.EditSession.prototype.removeGutterDecoration = function(row, className) {};

/**
 * Removes the marker with the specified ID. If this marker was in front, the
 * 'changeFrontMarker' event is emitted.
 * If the marker was in the back, the 'changeBackMarker' event is emitted.
 * @param {number} markerId
 */
ace.EditSession.prototype.removeMarker = function(markerId) {};

/**
 * Replaces a range in the document with the new text.
 * @param {!ace.Range} range
 * @param {string} text
 * @return {!Object}
 */
ace.EditSession.prototype.replace = function(range, text) {};

/** Undocumented */
ace.EditSession.prototype.reset = function() {};

/** Undocumented */
ace.EditSession.prototype.resetCaches = function() {};

/** Undocumented */
ace.EditSession.prototype.screenToDocumentColumn = function() {};

/**
 * Converts characters coordinates on the screen to characters coordinates
 * within the document. This takes into account code folding, word wrap, tab
 * size, and any other visual modifications.
 * @param {number} screenRow
 * @param {number} screenColumn
 * @return {!Object}
 */
ace.EditSession.prototype.screenToDocumentPosition = function(screenRow, screenColumn) {};

/** Undocumented */
ace.EditSession.prototype.screenToDocumentRow = function() {};

/**
 * Sets annotations for the EditSession. This functions emits the
 * 'changeAnnotation' event.
 * @param {!Array<!Object>} annotations
 */
ace.EditSession.prototype.setAnnotations = function(annotations) {};

/**
 * Sets a breakpoint on the row number given by rows. This function also emits
 * the 'changeBreakpoint' event.
 * @param {number} row
 * @param {string} className
 */
ace.EditSession.prototype.setBreakpoint = function(row, className) {};

/**
 * Sets a breakpoint on every row number given by rows. This function also
 * emits the 'changeBreakpoint' event.
 * @param {!Array<number>} rows
 */
ace.EditSession.prototype.setBreakpoints = function(rows) {};

/**
 * Sets the EditSession to point to a new Document. If a BackgroundTokenizer
 * exists, it also points to doc.
 * @param {!ace.Document} doc
 */
ace.EditSession.prototype.setDocument = function(doc) {};

/** Undocumented */
ace.EditSession.prototype.setMode = function() {};

/**
 * Sets the new line mode.
 * @param {string} newLineMode
 */
ace.EditSession.prototype.setNewLineMode = function(newLineMode) {};

/**
 * Pass in true to enable overwrites in your session, or false to disable.
 * @param {boolean} overwrite
 */
ace.EditSession.prototype.setOverwrite = function(overwrite) {};

/**
 * Sets the value of the distance between the left of the editor and the
 * leftmost part of the visible content.
 * @param {!Object} scrollLeft
 */
ace.EditSession.prototype.setScrollLeft = function(scrollLeft) {};

/**
 * This function sets the scroll top value. It also emits the 'changeScrollTop'
 * event.
 * @param {number} scrollTop
 */
ace.EditSession.prototype.setScrollTop = function(scrollTop) {};

/**
 * @param {boolean} margin
 */
ace.EditSession.prototype.setShowPrintMargin = function(margin) {};

/**
 * Set the number of spaces that define a soft tab; for example, passing in
 * 4 transforms the soft tabs to be equivalent to four spaces. This function
 * also emits the changeTabSize event.
 * @param {number} tabSize
 */
ace.EditSession.prototype.setTabSize = function(tabSize) {};

/**
 * Sets the undo manager.
 * @param {!ace.UndoManager} undoManager
 */
ace.EditSession.prototype.setUndoManager = function(undoManager) {};

/**
 * Enables or disables highlighting of the range where an undo occured.
 * @param {boolean} enable
 */
ace.EditSession.prototype.setUndoSelect = function(enable) {};

/**
 * Pass true to enable the use of soft tabs. Soft tabs means you're using
 * spaces instead of the tab character ('\t').
 * @param {boolean} useSoftTabs
 */
ace.EditSession.prototype.setUseSoftTabs = function(useSoftTabs) {};

/**
 * Identifies if you want to use a worker for the EditSession.
 * @param {boolean} useWorker
 */
ace.EditSession.prototype.setUseWorker = function(useWorker) {};

/**
 * Sets whether or not line wrapping is enabled. If useWrapMode is different
 * than the current value, the 'changeWrapMode' event is emitted.
 * @param {boolean} useWrapMode
 */
ace.EditSession.prototype.setUseWrapMode = function(useWrapMode) {};

/**
 * Sets the session text.
 * @param {string} text
 */
ace.EditSession.prototype.setValue = function(text) {};

/**
 * Sets the boundaries of wrap. Either value can be null to have an
 * unconstrained wrap, or, they can be the same number to pin the limit. If the
 * wrap limits for min or max are different, this method also emits the
 * 'changeWrapMode' event.
 * @param {?number} min
 * @param {?number} max
 */
ace.EditSession.prototype.setWrapLimitRange = function(min, max) {};

/**
 * Sets the value of overwrite to the opposite of whatever it currently is.
 */
ace.EditSession.prototype.toggleOverwrite = function() {};

/**
 * Returns the current Document as a string.
 * @override
 */
ace.EditSession.prototype.toString = function() {};

/** Undocumented */
ace.EditSession.prototype.undo = function() {};

/**
 * Reverts previous changes to your document.
 * @param {!Array<!Object>} deltas
 * @param {boolean} dontSelect
 * @return {!Object}
 */
ace.EditSession.prototype.undoChanges = function(deltas, dontSelect) {};

/**
 * Creates a new Editor object.
 * @constructor
 * @param {!ace.VirtualRenderer} renderer
 * @param {!ace.EditSession} session
 * @see https://ace.c9.io/#nav=api&api=editor
 */
ace.Editor = function(renderer, session) {};

/**
 * @param {string} event
 * @param {function((Object|string|null))} fn
 */
ace.Editor.prototype.on = function(event, fn) {};

/**
 * Adds the selection and cursor.
 * @param {!ace.Range} orientedRange
 * @return {!ace.Range}
 */
ace.Editor.prototype.addSelectionMarker = function(orientedRange) {};

/**
 * Aligns the cursors or selected text.
 */
ace.Editor.prototype.alignCursors = function() {};

/**
 * Outdents the current line.
 */
ace.Editor.prototype.blockOutdent = function() {};

/**
 * Blurs the current textInput.
 */
ace.Editor.prototype.blur = function() {};

/**
 * Attempts to center the current selection on the screen.
 */
ace.Editor.prototype.centerSelection = function() {};

/**
 * Empties the selection (by de-selecting it). This function also emits the
 * 'changeSelection' event.
 */
ace.Editor.prototype.clearSelection = function() {};

/**
 * Copies all the selected lines down one row.
 * @return {number}
 */
ace.Editor.prototype.copyLinesDown = function() {};

/**
 * Copies all the selected lines up one row.
 * @return {number}
 */
ace.Editor.prototype.copyLinesUp = function() {};

/**
 * Cleans up the entire editor.
 */
ace.Editor.prototype.destroy = function() {};

/** Undocumented */
ace.Editor.prototype.duplicateSelection = function() {};

/** Undocumented */
ace.Editor.prototype.execCommand = function() {};

/**
 * Removes all the selections except the last added one.
 */
ace.Editor.prototype.exitMultiSelectMode = function() {};

/**
 * Attempts to find needle within the document. For more information on
 * options, see Search.
 * @param {string} needle
 * @param {!Object} options
 * @param {boolean} animate
 */
ace.Editor.prototype.find = function(needle, options, animate) {};

/**
 * Finds and selects all the occurences of needle.
 * @param {string} needle
 * @param {!Object} options
 * @param {boolean} keeps
 * @return {number}
 */
ace.Editor.prototype.findAll = function(needle, options, keeps) {};

/**
 * Performs another search for needle in the document. For more information on
 * options, see Search.
 * @param {!Object} options
 * @param {boolean} animate
 */
ace.Editor.prototype.findNext = function(options, animate) {};

/**
 * Performs a search for needle backwards. For more information on options, see
 * Search.
 * @param {!Object} options
 * @param {boolean} animate
 */
ace.Editor.prototype.findPrevious = function(options, animate) {};

/**
 * Brings the current textInput into focus.
 */
ace.Editor.prototype.focus = function() {};

/**
 * Executes a command for each selection range.
 * @param {string} cmd
 * @param {string} args
 */
ace.Editor.prototype.forEachSelection = function(cmd, args) {};

/** Undocumented */
ace.Editor.prototype.getAnimatedScroll = function() {};

/**
 * Returns true if the behaviors are currently enabled.
 * "Behaviors" in this case is the auto-pairing of special characters, like
 * quotation marks, parenthesis, or brackets.
 * @return {boolean}
 */
ace.Editor.prototype.getBehavioursEnabled = function() {};

/**
 * Returns the string of text currently highlighted.
 * @return {string}
 */
ace.Editor.prototype.getCopyText = function() {};

/**
 * Gets the current position of the cursor.
 * @return {!Object}
 */
ace.Editor.prototype.getCursorPosition = function() {};

/**
 * Returns the screen position of the cursor.
 * @return {number}
 */
ace.Editor.prototype.getCursorPositionScreen = function() {};

/** Undocumented */
ace.Editor.prototype.getDisplayIndentGuides = function() {};

/**
 * Returns the current mouse drag delay.
 * @return {number}
 */
ace.Editor.prototype.getDragDelay = function() {};

/** Undocumented */
ace.Editor.prototype.getFadeFoldWidgets = function() {};

/**
 * Returns the index of the first visible row.
 * @return {number}
 */
ace.Editor.prototype.getFirstVisibleRow = function() {};

/**
 * Returns true if current lines are always highlighted.
 * @return {boolean}
 */
ace.Editor.prototype.getHighlightActiveLine = function() {};

/** Undocumented */
ace.Editor.prototype.getHighlightGutterLine = function() {};

/**
 * Returns true if currently highlighted words are to be highlighted.
 * @return {boolean}
 */
ace.Editor.prototype.getHighlightSelectedWord = function() {};

/**
 * Returns the keyboard handler, such as "vim" or "windows".
 * @return {string}
 */
ace.Editor.prototype.getKeyboardHandler = function() {};

/**
 * Returns an object containing all the search options. For more information on
 * options, see Search.
 * @return {!Object}
 */
ace.Editor.prototype.getLastSearchOptions = function() {};

/**
 * Returns the index of the last visible row.
 * @return {number}
 */
ace.Editor.prototype.getLastVisibleRow = function() {};

/**
 * Works like EditSession.getTokenAt(), except it returns a number.
 * @param {!Object} row
 * @param {!Object} column
 * @return {number}
 */
ace.Editor.prototype.getNumberAt = function(row, column) {};

/**
 * Returns true if overwrites are enabled; false otherwise.
 * @return {boolean}
 */
ace.Editor.prototype.getOverwrite = function() {};

/**
 * Returns the column number of where the print margin is.
 * @return {number}
 */
ace.Editor.prototype.getPrintMarginColumn = function() {};

/**
 * Returns true if the editor is set to read-only mode.
 * @return {boolean}
 */
ace.Editor.prototype.getReadOnly = function() {};

/**
 * Returns the value indicating how fast the mouse scroll speed is (in
 * milliseconds).
 * @return {number}
 */
ace.Editor.prototype.getScrollSpeed = function() {};

/**
 * Returns selection object.
 * @return {!ace.Selection}
 */
ace.Editor.prototype.getSelection = function() {};

/**
 * Returns the Range for the selected text.
 * @return {!ace.Range}
 */
ace.Editor.prototype.getSelectionRange = function() {};

/**
 * Returns the current selection style.
 * @return {string}
 */
ace.Editor.prototype.getSelectionStyle = function() {};

/**
 * Returns the current session being used.
 * @return {!ace.EditSession}
 */
ace.Editor.prototype.getSession = function() {};

/**
 * Returns true if the fold widgets are shown.
 * @return {boolean}
 */
ace.Editor.prototype.getShowFoldWidgets = function() {};

/**
 * Returns true if invisible characters are being shown.
 * @return {boolean}
 */
ace.Editor.prototype.getShowInvisibles = function() {};

/**
 * Returns true if the print margin is being shown.
 * @return {boolean}
 */
ace.Editor.prototype.getShowPrintMargin = function() {};

/**
 * Returns the path of the current theme.
 * @return {string}
 */
ace.Editor.prototype.getTheme = function() {};

/**
 * Returns the current session's content.
 * @return {string}
 */
ace.Editor.prototype.getValue = function() {};

/**
 * Returns true if the wrapping behaviors are currently enabled.
 */
ace.Editor.prototype.getWrapBehavioursEnabled = function() {};

/**
 * Moves the cursor to the specified line number, and also into the indiciated
 * column.
 * @param {number} lineNumber
 * @param {number} column
 * @param {boolean} animate
 */
ace.Editor.prototype.gotoLine = function(lineNumber, column, animate) {};

/**
 * Shifts the document to wherever "page down" is, as well as moving the cursor
 * position.
 */
ace.Editor.prototype.gotoPageDown = function() {};

/**
 * Shifts the document to wherever "page up" is, as well as moving the cursor
 * position.
 */
ace.Editor.prototype.gotoPageUp = function() {};

/**
 * Indents the current line.
 */
ace.Editor.prototype.indent = function() {};

/**
 * Inserts text into wherever the cursor is pointing.
 * @param {string} text
 */
ace.Editor.prototype.insert = function(text) {};

/**
 * Returns true if the current textInput is in focus.
 * @return {boolean}
 */
ace.Editor.prototype.isFocused = function() {};

/**
 * Indicates if the entire row is currently visible on the screen.
 * @param {number} row
 * @return {boolean}
 */
ace.Editor.prototype.isRowFullyVisible = function(row) {};

/**
 * Indicates if the row is currently visible on the screen.
 * @param {number} row
 * @return {boolean}
 */
ace.Editor.prototype.isRowVisible = function(row) {};

/**
 * Moves the cursor's row and column to the next matching bracket.
 * @param {!Object} select
 */
ace.Editor.prototype.jumpToMatching = function(select) {};

/**
 * If the character before the cursor is a number, this functions changes its
 * value by amount.
 * @param {number} amount
 */
ace.Editor.prototype.modifyNumber = function(amount) {};

/**
 * Moves the cursor to the specified row and column. Note that this does not
 * de-select the current selection.
 * @param {number} row
 * @param {number} column
 */
ace.Editor.prototype.moveCursorTo = function(row, column) {};

/**
 * Moves the cursor to the position indicated by pos.row and pos.column.
 * @param {{row: number, column: number}} pos
 */
ace.Editor.prototype.moveCursorToPosition = function(pos) {};

/**
 * Shifts all the selected lines down one row.
 * @return {number}
 */
ace.Editor.prototype.moveLinesDown = function() {};

/**
 * Shifts all the selected lines up one row.
 * @return {number}
 */
ace.Editor.prototype.moveLinesUp = function() {};

/** Undocumented */
ace.Editor.prototype.moveText = function() {};

/**
 * Moves the cursor down in the document the specified number of times. Note
 * that this does de-select the current selection.
 * @param {number} times
 */
ace.Editor.prototype.navigateDown = function(times) {};

/**
 * Moves the cursor to the end of the current file. Note that this does
 * de-select the current selection.
 */
ace.Editor.prototype.navigateFileEnd = function() {};

/**
 * Moves the cursor to the start of the current file. Note that this does
 * de-select the current selection.
 */
ace.Editor.prototype.navigateFileStart = function() {};

/**
 * Moves the cursor left in the document the specified number of times. Note
 * that this does de-select the current selection.
 * @param {number} times
 */
ace.Editor.prototype.navigateLeft = function(times) {};

/**
 * Moves the cursor to the end of the current line. Note that this does
 * de-select the current selection.
 */
ace.Editor.prototype.navigateLineEnd = function() {};

/**
 * Moves the cursor to the start of the current line. Note that this does
 * de-select the current selection.
 */
ace.Editor.prototype.navigateLineStart = function() {};

/**
 * Moves the cursor right in the document the specified number of times. Note
 * that this does de-select the current selection.
 * @param {number} times
 */
ace.Editor.prototype.navigateRight = function(times) {};

/**
 * Moves the cursor to the specified row and column. Note that this does
 * de-select the current selection.
 * @param {number} row
 * @param {number} column
 */
ace.Editor.prototype.navigateTo = function(row, column) {};

/**
 * Moves the cursor up in the document the specified number of times. Note that
 * this does de-select the current selection.
 * @param {number} times
 */
ace.Editor.prototype.navigateUp = function(times) {};

/**
 * Moves the cursor to the word immediately to the left of the current
 * position. Note that this does de-select the current selection.
 */
ace.Editor.prototype.navigateWordLeft = function() {};

/**
 * Moves the cursor to the word immediately to the right of the current
 * position. Note that this does de-select the current selection.
 */
/** Undocumented */
ace.Editor.prototype.navigateWordRight = function() {};

/** Undocumented */
ace.Editor.prototype.onBlur = function() {};

/** Undocumented */
ace.Editor.prototype.onChangeAnnotation = function() {};

/** Undocumented */
ace.Editor.prototype.onChangeBackMarker = function() {};

/** Undocumented */
ace.Editor.prototype.onChangeBreakpoint = function() {};

/** Undocumented */
ace.Editor.prototype.onChangeFold = function() {};

/** Undocumented */
ace.Editor.prototype.onChangeFrontMarker = function() {};

/** Undocumented */
ace.Editor.prototype.onChangeMode = function() {};

/** Undocumented */
ace.Editor.prototype.onChangeWrapLimit = function() {};

/** Undocumented */
ace.Editor.prototype.onChangeWrapMode = function() {};

/** Undocumented */
ace.Editor.prototype.onCommandKey = function() {};

/** Undocumented */
ace.Editor.prototype.onCompositionEnd = function() {};

/** Undocumented */
ace.Editor.prototype.onCompositionStart = function() {};

/** Undocumented */
ace.Editor.prototype.onCompositionUpdate = function() {};

/**
 * Called whenever a text "copy" happens.
 */
ace.Editor.prototype.onCopy = function() {};

/**
 * Emitted when the selection changes.
 */
ace.Editor.prototype.onCursorChange = function() {};

/**
 * Called whenever a text "cut" happens.
 */
ace.Editor.prototype.onCut = function() {};

/** Undocumented */
ace.Editor.prototype.onDocumentChange = function() {};

/** Undocumented */
ace.Editor.prototype.onFocus = function() {};

/**
 * Called whenever a text "paste" happens.
 * @param {string} text
 */
ace.Editor.prototype.onPaste = function(text) {};

/** Undocumented */
ace.Editor.prototype.onScrollLeftChange = function() {};

/** Undocumented */
ace.Editor.prototype.onScrollTopChange = function() {};

/** Undocumented */
ace.Editor.prototype.onSelectionChange = function() {};

/** Undocumented */
ace.Editor.prototype.onTextInput = function() {};

/** Undocumented */
ace.Editor.prototype.onTokenizerUpdate = function() {};

/**
 * Perform a redo operation on the document, reimplementing the last change.
 */
ace.Editor.prototype.redo = function() {};

/**
 * Removes words of text from the editor. A "word" is defined as a string of
 * characters bookended by whitespace.
 * @param {string} dir
 */
ace.Editor.prototype.remove = function(dir) {};

/**
 * Removes all the lines in the current selection.
 */
ace.Editor.prototype.removeLines = function() {};

/**
 * Removes the selection marker.
 * @param {!ace.Range} range
 */
ace.Editor.prototype.removeSelectionMarker = function(range) {};

/**
 * Removes all the words to the right of the current selection, until the end
 * of the line.
 */
ace.Editor.prototype.removeToLineEnd = function() {};

/**
 * Removes all the words to the left of the current selection, until the start
 * of the line.
 */
ace.Editor.prototype.removeToLineStart = function() {};

/**
 * Removes the word directly to the left of the current selection.
 */
ace.Editor.prototype.removeWordLeft = function() {};

/**
 * Removes the word directly to the right of the current selection.
 */
ace.Editor.prototype.removeWordRight = function() {};

/**
 * Replaces the first occurance of options.needle with the value in replacement.
 * @param {string} replacement
 * @return {{needle: string}} options
 */
ace.Editor.prototype.replace = function(replacement, options) {};

/**
 * Replaces all occurences of options.needle with the value in replacement.
 * @param {string} replacement
 * @return {{needle: string}} options
 */
ace.Editor.prototype.replaceAll = function(replacement, options) {};

/**
 * Triggers a resize of the editor.
 * @param {boolean} force
 */
ace.Editor.prototype.resize = function(force) {};

/** Undocumented */
ace.Editor.prototype.revealRange = function() {};

/**
 * Scrolls the document to wherever "page down" is, without changing the cursor
 * position.
 */
ace.Editor.prototype.scrollPageDown = function() {};

/**
 * Scrolls the document to wherever "page up" is, without changing the cursor
 * position.
 */
ace.Editor.prototype.scrollPageUp = function() {};

/**
 * Scrolls to a line. If center is true, it puts the line in middle of screen
 * (or attempts to).
 * @param {number} line
 * @param {boolean} center
 * @param {boolean} animate
 * @param {!Function} callback
 */
ace.Editor.prototype.scrollToLine = function(line, center, animate, callback) {};

/**
 * Moves the editor to the specified row.
 * @param {!Object} row
 */
ace.Editor.prototype.scrollToRow = function(row) {};

/**
 * Selects all the text in editor.
 */
ace.Editor.prototype.selectAll = function() {};

/**
 * Finds the next occurence of text in an active selection and adds it to the
 * selections.
 * @param {number} dir
 * @param {boolean} skip
 */
ace.Editor.prototype.selectMore = function(dir, skip) {};

/**
 * Adds a cursor above or below the active cursor.
 * @param {number} dir
 * @param {boolean} skip
 */
ace.Editor.prototype.selectMoreLines = function(dir, skip) {};

/**
 * Selects the text from the current position of the document until where a
 * "page down" finishes.
 */
ace.Editor.prototype.selectPageDown = function() {};

/**
 * Selects the text from the current position of the document until where a
 * "page up" finishes.
 */
ace.Editor.prototype.selectPageUp = function() {};

/** Undocumented */
ace.Editor.prototype.setAnimatedScroll = function() {};

/**
 * Specifies whether to use behaviors or not.
 * "Behaviors" in this case is the auto-pairing of special characters, like
 * quotation marks, parenthesis, or brackets.
 * @param {boolean} enabled
 */
ace.Editor.prototype.setBehavioursEnabled = function(enabled) {};

/** Undocumented */
ace.Editor.prototype.setDisplayIndentGuides = function() {};

/**
 * Sets the delay (in milliseconds) of the mouse drag.
 * @param {number} dragDelay
 */
ace.Editor.prototype.setDragDelay = function(dragDelay) {};

/** Undocumented */
ace.Editor.prototype.setFadeFoldWidgets = function() {};

/**
 * Set a new font size (in pixels) for the editor text.
 * @param {number} size
 */
ace.Editor.prototype.setFontSize = function(size) {};

/**
 * Determines whether or not the current line should be highlighted.
 * @param {boolean} shouldHighlight
 */
ace.Editor.prototype.setHighlightActiveLine = function(shouldHighlight) {};

/** Undocumented */
ace.Editor.prototype.setHighlightGutterLine = function() {};

/**
 * Determines if the currently selected word should be highlighted.
 * @param {boolean} shouldHighlight
 */
ace.Editor.prototype.setHighlightSelectedWord = function(shouldHighlight) {};

/**
 * Sets a new key handler, such as "vim" or "windows".
 * @param {string} keyboardHandler
 */
ace.Editor.prototype.setKeyboardHandler = function(keyboardHandler) {};

/**
 * Pass in true to enable overwrites in your session, or false to disable. If
 * overwrites is enabled, any text you enter will type over any text after it.
 * If the value of overwrite changes, this function also emits the
 * changeOverwrite event.
 * @param {boolean} overwrite
 */
ace.Editor.prototype.setOverwrite = function(overwrite) {};

/**
 * Sets the column defining where the print margin should be.
 * @param {number} showPrintMargin
 */
ace.Editor.prototype.setPrintMarginColumn = function(showPrintMargin) {};

/**
 * If readOnly is true, then the editor is set to read-only mode, and none of
 * the content can change.
 * @param {boolean} readOnly
 */
ace.Editor.prototype.setReadOnly = function(readOnly) {};

/**
 * Sets how fast the mouse scrolling should do.
 * @param {number} speed
 */
ace.Editor.prototype.setScrollSpeed = function(speed) {};

/**
 * Indicates how selections should occur.
 * @param {string} style
 */
ace.Editor.prototype.setSelectionStyle = function(style) {};

/**
 * Sets a new editsession to use. This method also emits the 'changeSession'
 * event.
 * @param {!ace.EditSession} session
 */
ace.Editor.prototype.setSession = function(session) {};

/**
 * Indicates whether the fold widgets are shown or not.
 * @param {boolean} show
 */
ace.Editor.prototype.setShowFoldWidgets = function(show) {};

/**
 * If showInvisibles is set to true, invisible characters—like spaces or new
 * lines—are show in the editor.
 * @param {boolean} showInvisibles
 */
ace.Editor.prototype.setShowInvisibles = function(showInvisibles) {};

/**
 * If showPrintMargin is set to true, the print margin is shown in the editor.
 * @param {boolean} showPrintMargin
 */
ace.Editor.prototype.setShowPrintMargin = function(showPrintMargin) {};

/**
 * Adds a new class, style, to the editor.
 * @param {string} style
 */
ace.Editor.prototype.setStyle = function(style) {};

/**
 * Sets a new theme for the editor. theme should exist, and be a directory
 * path, like ace/theme/textmate.
 * @param {string} theme
 */
ace.Editor.prototype.setTheme = function(theme) {};

/**
 * Sets the current document to val.
 * @param {string} val
 * @param {number} cursorPos
 * @return {string}
 */
ace.Editor.prototype.setValue = function(val, cursorPos) {};

/**
 * Specifies whether to use wrapping behaviors or not, i.e. automatically
 * wrapping the selection with characters such as brackets when such a
 * character is typed in.
 * @param {boolean} enabled
 */
ace.Editor.prototype.setWrapBehavioursEnabled = function(enabled) {};

/** Undocumented */
ace.Editor.prototype.sortLines = function() {};

/**
 * Splits the line at the current selection (by inserting an '\n').
 */
ace.Editor.prototype.splitLine = function() {};

/**
 * Given the currently selected range, this function either comments all the
 * lines, or uncomments all of them.
 */
ace.Editor.prototype.toggleCommentLines = function() {};

/**
 * Sets the value of overwrite to the opposite of whatever it currently is.
 */
ace.Editor.prototype.toggleOverwrite = function() {};

/**
 * Converts the current selection entirely into lowercase.
 */
ace.Editor.prototype.toLowerCase = function() {};

/**
 * Converts the current selection entirely into uppercase.
 */
ace.Editor.prototype.toUpperCase = function() {};

/**
 * Transposes current line.
 */
ace.Editor.prototype.transposeLetters = function() {};

/**
 * Transposes the selected ranges.
 * @param {number} dir
 */
ace.Editor.prototype.transposeSelections = function(dir) {};

/**
 * Perform an undo operation on the document, reverting the last change.
 */
ace.Editor.prototype.undo = function() {};

/**
 * Removes the class style from the editor.
 * @param {!Object} style
 */
ace.Editor.prototype.unsetStyle = function(style) {};

/**
 * Updates the cursor and marker layers.
 */
ace.Editor.prototype.updateSelectionMarkers = function() {};

/**
 * Creates a new Range object with the given starting and ending row and column
 * points.
 * @constructor
 * @param {number} startRow
 * @param {number} startColumn
 * @param {number} endRow
 * @param {number} endColumn
 * @see https://ace.c9.io/#nav=api&api=range
 */
ace.Range = function(startRow, startColumn, endRow, endColumn) {};

/**
 * Returns the part of the current Range that occurs within the boundaries of
 * firstRow and lastRow as a new Range object.
 * @param {number} firstRow
 * @param {number} lastRow
 * @return {!ace.Range}
 */
ace.Range.prototype.clipRows = function(firstRow, lastRow) {};

/**
 * Returns a duplicate of the calling range.
 * @return {!ace.Range}
 */
ace.Range.prototype.clone = function() {};

/**
 * Returns a range containing the starting and ending rows of the original
 * range, but with a column value of 0.
 * @return {!ace.Range}
 */
ace.Range.prototype.collapseRows = function() {};

/**
 * Checks the row and column points with the row and column points of the
 * calling range.
 * @param {number} row
 * @param {number} column
 * @return {number}
 */
ace.Range.prototype.compare = function(row, column) {};

/**
 * Checks the row and column points with the row and column points of the
 * calling range.
 * @param {number} row
 * @param {number} column
 * @return {number}
 */
ace.Range.prototype.compareEnd = function(row, column) {};

/**
 * Checks the row and column points with the row and column points of the
 * calling range.
 * @param {number} row
 * @param {number} column
 * @return {number}
 */
ace.Range.prototype.compareInside = function(row, column) {};

/**
 * Checks the row and column points of p with the row and column points of the
 * calling range.
 * @param {!ace.Range} range
 * @return {number}
 */
ace.Range.prototype.comparePoint = function(range)  {};

/**
 * Compares this range (A) with another range (B).
 * @param {!ace.Range} range
 * @return {number}
 */
ace.Range.prototype.compareRange = function(range) {};

/**
 * Checks the row and column points with the row and column points of the
 * calling range.
 * @param {number} row
 * @param {number} column
 * @return {number}
 */
ace.Range.prototype.compareStart = function(row, column) {};

/**
 * Returns true if the row and column provided are within the given range.
 * This can better be expressed as returning true if:
 *   this.start.row <= row <= this.end.row &&
 *   this.start.column <= column <= this.end.column
 * @param {number} row
 * @param {number} column
 * @return {boolean}
 */
ace.Range.prototype.contains = function(row, column) {};

/**
 * Checks the start and end points of range and compares them to the calling
 * range. Returns true if the range is contained within the caller's range.
 * @param {!ace.Range} range
 * @return {boolean}
 */
ace.Range.prototype.containsRange = function(range) {};

/**
 * Changes the row and column points for the calling range for both the
 * starting and ending points.
 * @param {number} row
 * @param {number} column
 * @return {!ace.Range}
 */
ace.Range.prototype.extend = function(row, column) {};

/**
 * Creates and returns a new Range based on the row and column of the given
 * parameters.
 * @param {!ace.Range} start
 * @param {!ace.Range} end
 * @return {!ace.Range}
 */
ace.Range.prototype.fromPoints = function(start, end) {};

/**
 * Returns true if the row and column are within the given range.
 * @param {number} row
 * @param {number} column
 * @return {boolean}
 */
ace.Range.prototype.inside = function(row, column) {};

/**
 * Returns true if the row and column are within the given range.
 * @param {number} row
 * @param {number} column
 * @return {boolean}
 */
ace.Range.prototype.insideEnd = function(row, column) {};

/**
 * Returns true if the row and column are within the given range's starting
 * points.
 * @param {number} row
 * @param {number} column
 * @return {boolean}
 */
ace.Range.prototype.insideStart = function(row, column) {};

/**
 * Returns true if passed in range intersects with the one calling this method.
 * @param {!ace.Range} range
 * @return {boolean}
 */
ace.Range.prototype.intersects = function(range) {};

/** Undocumented */
ace.Range.prototype.isEmpty = function() {};

/**
 * Returns true if the caller's ending row point is the same as row, and if the
 * caller's ending column is the same as column.
 * @param {number} row
 * @param {number} column
 * @return {boolean}
 */
ace.Range.prototype.isEnd = function(row, column) {};

/**
 * Returns true if and only if the starting row and column, and ending row and
 * column, are equivalent to those given by range.
 * @param {!ace.Range} range
 * @return {boolean}
 */
ace.Range.prototype.isEqual = function(range) {};

/**
 * Returns true if the range spans across multiple lines.
 * @return {boolean}
 */
ace.Range.prototype.isMultiLine = function()  {};

/**
 * Returns true if the caller's starting row point is the same as row, and if
 * the caller's starting column is the same as column.
 * @param {number} row
 * @param {number} column
 * @return {boolean}
 */
ace.Range.prototype.isStart = function(row, column) {};

/**
 * Sets the starting row and column for the range.
 * @param {number} row
 * @param {number} column
 * @return {!Object}
 */
ace.Range.prototype.setEnd = function(row, column) {};

/**
 * Sets the starting row and column for the range.
 * @param {number} row
 * @param {number} column
 * @return {!Object}
 */
ace.Range.prototype.setStart = function(row, column) {};

/**
 * Given the current Range, this function converts those starting and ending
 * points into screen positions,
 * and then returns a new Range object.
 * @param {!ace.EditSession} session
 * @return {!ace.Range}
 */
ace.Range.prototype.toScreenRange = function(session) {};

/**
 * Returns a string containing the range's row and column information, given
 * like this:
 *   [start.row/start.column] -> [end.row/end.column]
 * @override
 */
ace.Range.prototype.toString = function() {};

/**
 * Creates a new ScrollBar. parent is the owner of the scroll bar.
 * @constructor
 * @param {!Element} parent
 * @see https://ace.c9.io/#nav=api&api=scrollbar
 */
ace.ScrollBar = function(parent) {};

/**
 * Emitted when the scroll bar, well, scrolls.
 * @param {string} event
 * @param {function(!Object)} fn
 */
ace.ScrollBar.prototype.on = function(event, fn) {};

/**
 * Returns the width of the scroll bar.
 * @return {number}
 */
ace.ScrollBar.prototype.getWidth = function() {};

/** Undocumented */
ace.ScrollBar.prototype.onScroll = function() {};

/**
 * Sets the height of the scroll bar, in pixels.
 * @param {number} height
 */
ace.ScrollBar.prototype.setHeight = function(height) {};

/**
 * Sets the inner height of the scroll bar, in pixels.
 * @param {number} height
 */
ace.ScrollBar.prototype.setInnerHeight = function(height) {};

/**
 * Sets the scroll top of the scroll bar.
 * @param {number} scrollTop
 */
ace.ScrollBar.prototype.setScrollTop = function(scrollTop) {};

/**
 * Creates a new Search object.
 * @constructor
 * @see https://ace.c9.io/#nav=api&api=search
 */
ace.Search = function() {};

/**
 * Searches for options.needle. If found, this method returns the Range where
 * the text first occurs. If options.backwards is true, the search goes
 * backwards in the session.
 * @param {!ace.EditSession} session
 * @return {!ace.Range}
 */
ace.Search.prototype.find = function(session) {};

/**
 * Searches for all occurances options.needle.
 * If found, this method returns an array of Ranges where the text first occurs.
 * If options.backwards is true, the search goes backwards in the session.
 * @param {!ace.EditSession} session
 * @return {!ace.Range}
 */
ace.Search.prototype.findAll = function(session) {};

/**
 * Returns an object containing all the search options.
 * @return {!Object}
 */
ace.Search.prototype.getOptions = function() {};

/**
 * Searches for options.needle in input, and, if found, replaces it with
 * replacement.
 * @param {string} input
 * @param {string} replacement
 * @return {string}
 */
ace.Search.prototype.replace = function(input, replacement) {};

/**
 * Sets the search options via the options parameter.
 * @param {{needle: string, backwards: boolean}} options
 * @return {!ace.Search}
 */
ace.Search.prototype.set = function(options) {};

/** Undocumented */
ace.Search.prototype.setOptions = function() {};

/**
 * Creates a new Selection object.
 * @constructor
 * @param {!ace.EditSession} session
 * @see https://ace.c9.io/#nav=api&api=selection
 */
ace.Selection = function(session) {};

/**
 * @param {string} event
 * @param {!Function} fn
 */
ace.Selection.prototype.on = function(event, fn) {};

/**
 * Adds a range to a selection by entering multiselect mode, if necessary.
 * @param {!ace.Range} range
 * @param {boolean} $blockChangeEvents
 */
ace.Selection.prototype.addRange = function(range, $blockChangeEvents) {};

/**
 * Empties the selection (by de-selecting it). This function also emits the
 * 'changeSelection' event.
 */
ace.Selection.prototype.clearSelection = function() {};

/** Undocumented */
ace.Selection.prototype.detach = function() {};

/** Undocumented */
ace.Selection.prototype.fromOrientedRange = function() {};

/**
 * Returns a concatenation of all the ranges.
 * @return {!Array<!Object>}
 */
ace.Selection.prototype.getAllRanges = function() {};

/**
 * Gets the current position of the cursor.
 * @return {number}
 */
ace.Selection.prototype.getCursor = function() {};

/** Undocumented */
ace.Selection.prototype.getLineRange = function() {};

/**
 * Returns the Range for the selected text.
 * @return {!ace.Range}
 */
ace.Selection.prototype.getRange = function() {};

/**
 * Returns an object containing the row and column of the calling selection
 * anchor.
 * @return {!Object}
 */
ace.Selection.prototype.getSelectionAnchor = function() {};

/**
 * Returns an object containing the row and column of the calling selection
 * lead.
 * @return {!Object}
 */
ace.Selection.prototype.getSelectionLead = function() {};

/**
 * Moves the selection to highlight the entire word.
 * @param {!Object} row
 * @param {!Object} column
 */
ace.Selection.prototype.getWordRange = function(row, column) {};

/**
 * Returns true if the selection is going backwards in the document.
 * @return {boolean}
 */
ace.Selection.prototype.isBackwards = function() {};

/**
 * Returns true if the selection is empty.
 * @return {boolean}
 */
ace.Selection.prototype.isEmpty = function() {};

/**
 * Returns true if the selection is a multi-line.
 * @return {boolean}
 */
ace.Selection.prototype.isMultiLine = function() {};

/**
 * Merges overlapping ranges ensuring consistency after changes.
 */
ace.Selection.prototype.mergeOverlappingRanges = function() {};

/**
 * Moves the cursor to position indicated by the parameters. Negative numbers
 * move the cursor backwards in the document.
 * @param {number} rows
 * @param {number} chars
 */
ace.Selection.prototype.moveCursorBy = function(rows, chars) {};

/**
 * Moves the cursor down one row.
 */
ace.Selection.prototype.moveCursorDown = function() {};

/**
 * Moves the cursor to the end of the file.
 */
ace.Selection.prototype.moveCursorFileEnd = function() {};

/**
 * Moves the cursor to the start of the file.
 */
ace.Selection.prototype.moveCursorFileStart = function() {};

/**
 * Moves the cursor left one column.
 */
ace.Selection.prototype.moveCursorLeft = function() {};

/**
 * Moves the cursor to the end of the line.
 */
ace.Selection.prototype.moveCursorLineEnd = function() {};

/**
 * Moves the cursor to the start of the line.
 */
ace.Selection.prototype.moveCursorLineStart = function() {};

/**
 * Moves the cursor to the word on the left.
 */
ace.Selection.prototype.moveCursorLongWordLeft = function() {};

/**
 * Moves the cursor to the word on the right.
 */
ace.Selection.prototype.moveCursorLongWordRight = function() {};

/**
 * Moves the cursor right one column.
 */
ace.Selection.prototype.moveCursorRight = function() {};

/** Undocumented */
ace.Selection.prototype.moveCursorShortWordLeft = function() {};

/** Undocumented */
ace.Selection.prototype.moveCursorShortWordRight = function() {};

/**
 * Moves the cursor to the row and column provided.
 * If preventUpdateDesiredColumn is true, then the cursor stays in the same
 * column position as its original point.
 * @param {number} row
 * @param {number} column
 * @param {boolean} keepDesiredColumn
 */
ace.Selection.prototype.moveCursorTo = function(row, column, keepDesiredColumn) {};

/**
 * Moves the selection to the position indicated by its row and column.
 * @param {!Object} position
 */
ace.Selection.prototype.moveCursorToPosition = function(position) {};

/**
 * Moves the cursor to the screen position indicated by row and column.
 * If preventUpdateDesiredColumn is true, then the cursor stays in the same
 * column position as its original point.
 * @param {number} row
 * @param {number} column
 * @param {boolean} keepDesiredColumn
 */
ace.Selection.prototype.moveCursorToScreen = function(row, column, keepDesiredColumn) {};

/**
 * Moves the cursor up one row.
 */
ace.Selection.prototype.moveCursorUp = function() {};

/** Undocumented */
ace.Selection.prototype.moveCursorWordLeft = function() {};

/** Undocumented */
ace.Selection.prototype.moveCursorWordRight = function() {};

/**
 * Gets list of ranges composing rectangular block on the screen.
 * @param {!Object} screenCursor
 * @param {!ace.Anchor} screenAnchor
 * @param {boolean} includeEmptyLines
 * @return {!ace.Range}
 */
ace.Selection.prototype.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {};

/**
 * Selects all the text in the document.
 */
ace.Selection.prototype.selectAll = function() {};

/**
 * Selects a word, including its right whitespace.
 */
ace.Selection.prototype.selectAWord = function() {};

/**
 * Moves the selection down one row.
 */
ace.Selection.prototype.selectDown = function() {};

/**
 * Moves the selection to the end of the file.
 */
ace.Selection.prototype.selectFileEnd = function() {};

/**
 * Moves the selection to the start of the file.
 */
ace.Selection.prototype.selectFileStart = function() {};

/**
 * Moves the selection left one column.
 */
ace.Selection.prototype.selectLeft = function() {};

/**
 * Selects the entire line.
 */
ace.Selection.prototype.selectLine = function() {};

/**
 * Moves the selection to the end of the current line.
 */
ace.Selection.prototype.selectLineEnd = function() {};

/**
 * Moves the selection to the beginning of the current line.
 */
ace.Selection.prototype.selectLineStart = function() {};

/**
 * Moves the selection right one column.
 */
ace.Selection.prototype.selectRight = function() {};

/**
 * Moves the selection cursor to the indicated row and column.
 * @param {number} row
 * @param {number} column
 */
ace.Selection.prototype.selectTo = function(row, column) {};

/**
 * Moves the selection cursor to the row and column indicated by pos.
 * @param {!Object} pos
 */
ace.Selection.prototype.selectToPosition = function(pos) {};

/**
 * Moves the selection up one row.
 */
ace.Selection.prototype.selectUp = function() {};

/**
 * Selects an entire word boundary.
 */
ace.Selection.prototype.selectWord = function() {};

/**
 * Moves the selection to the first word on the left.
 */
ace.Selection.prototype.selectWordLeft = function() {};

/**
 * Moves the selection to the first word on the right.
 */
ace.Selection.prototype.selectWordRight = function() {};

/**
 * Sets the row and column position of the anchor. This function also emits the
 * 'changeSelection' event.
 * @param {number} row
 * @param {number} column
 */
ace.Selection.prototype.setSelectionAnchor = function(row, column) {};

/**
 * Sets the selection to the provided range.
 * @param {!ace.Range} range
 * @param {boolean} reverse
 */
ace.Selection.prototype.setSelectionRange = function(range, reverse) {};

/**
 * Shifts the selection up (or down, if isBackwards() is true) the given number
 * of columns.
 * @param {number} columns
 */
ace.Selection.prototype.shiftSelection = function(columns) {};

/**
 * Splits all the ranges into lines.
 */
ace.Selection.prototype.splitIntoLines = function() {};

/**
 * Removes a Range containing pos (if it exists).
 * @param {!ace.Range} pos
 */
ace.Selection.prototype.substractPoint = function(pos) {};

/** Undocumented */
ace.Selection.prototype.toggleBlockSelection = function() {};

/** Undocumented */
ace.Selection.prototype.toOrientedRange = function() {};

/** Undocumented */
ace.Selection.prototype.toSingleRange = function() {};

/**
 * Creates a new token iterator object. The inital token index is set to the
 * provided row and column coordinates.
 * @constructor
 * @param {!ace.EditSession} session
 * @param {number} initialRow
 * @param {number} initialColumn
 * @see https://ace.c9.io/#nav=api&api=token_iterator
 */
ace.TokenIterator = function(session, initialRow, initialColumn) {};

/**
 * Returns the current tokenized string.
 * @return {string}
 */
ace.TokenIterator.prototype.getCurrentToken = function() {};

/**
 * Returns the current column.
 * @return {number}
 */
ace.TokenIterator.prototype.getCurrentTokenColumn = function() {};

/**
 * Returns the current row.
 * @return {number}
 */
ace.TokenIterator.prototype.getCurrentTokenRow = function() {};

/**
 * Tokenizes all the items from the current point to the row prior in the
 * document.
 * @return {string}
 */
ace.TokenIterator.prototype.stepBackward = function() {};

/**
 * Tokenizes all the items from the current point until the next row in the
 * document. If the current point is at the end of the file, this function
 * returns null. Otherwise, it returns the tokenized string.
 * @return {?string}
 */
ace.TokenIterator.prototype.stepForward = function() {};

/**
 * Constructs a new tokenizer based on the given rules and flags.
 * @constructor
 * @param {!Object} rules
 * @param {string} flag
 * @see https://ace.c9.io/#nav=api&api=tokenizer
 */
ace.Tokenizer = function(rules, flag) {};

/**
 * Returns an object containing two properties: tokens, which contains all the
 * tokens; and state, the current state.
 * @param {!Object} line
 * @param {!Object} startState
 * @return {{tokens: !Array<!Object>, state: !Object}}
 */
ace.Tokenizer.prototype.getLineTokens = function(line, startState) {};

/**
 * Resets the current undo state and creates a new UndoManager.
 * @constructor
 * @see https://ace.c9.io/#nav=api&api=undomanager
 */
ace.UndoManager = function() {};

/**
 * Provides a means for implementing your own undo manager. options has one
 * property, args, an Array, with two elements: deltaSets and doc.
 * @param {{args: !Array<!Object>}} options
 */
ace.UndoManager.prototype.execute = function(options) {};

/**
 * Returns true if there are redo operations left to perform.
 * @return {boolean}
 */
ace.UndoManager.prototype.hasRedo = function() {};

/**
 * Returns true if there are undo operations left to perform.
 * @return {boolean}
 */
ace.UndoManager.prototype.hasUndo = function() {};

/**
 * Perform a redo operation on the document, reimplementing the last change.
 * @param {boolean} dontSelect
 */
ace.UndoManager.prototype.redo = function(dontSelect) {};

/**
 * Destroys the stack of undo and redo redo operations.
 */
ace.UndoManager.prototype.reset = function() {};

/**
 * Perform an undo operation on the document, reverting the last change.
 * @param {boolean} dontSelect
 * @return {!ace.Range}
 */
ace.UndoManager.prototype.undo = function(dontSelect) {};

/**
 * Constructs a new VirtualRenderer within the container specified, applying
 * the given theme.
 * @constructor
 * @param {!Element} container
 * @param {string} theme
 * @see https://ace.c9.io/#nav=api&api=virtual_renderer
 */
ace.VirtualRenderer = function(container, theme) {};

/** Undocumented */
ace.VirtualRenderer.prototype._loadTheme = function() {};

/**
 * Deprecated (moved to EditSession)
 * @deprecated
 * @param {!Object} row
 */
ace.VirtualRenderer.prototype.addGutterDecoration = function(row, className) {};

/**
 * Adjusts the wrap limit, which is the number of characters that can fit
 * within the width of the edit area on screen.
 */
ace.VirtualRenderer.prototype.adjustWrapLimit = function() {};

/** Undocumented */
ace.VirtualRenderer.prototype.alignCursor = function() {};

/** Undocumented */
ace.VirtualRenderer.prototype.animateScrolling = function() {};

/**
 * Destroys the text and cursor layers for this renderer.
 */
ace.VirtualRenderer.prototype.destroy = function() {};

/**
 * Returns whether an animated scroll happens or not.
 * @return {boolean}
 */
ace.VirtualRenderer.prototype.getAnimatedScroll = function() {};

/**
 * Returns the root element containing this renderer.
 * @return {!Element}
 */
ace.VirtualRenderer.prototype.getContainerElement = function() {};

/** Undocumented */
ace.VirtualRenderer.prototype.getDisplayIndentGuides = function() {};

/** Undocumented */
ace.VirtualRenderer.prototype.getFadeFoldWidgets = function() {};

/**
 * Returns the index of the first fully visible row.
 * "Fully" here means that the characters in the row are not truncated; that
 * the top and the bottom of the row are on the screen.
 */
ace.VirtualRenderer.prototype.getFirstFullyVisibleRow = function() {};

/**
 * Returns the index of the first visible row.
 * @return {number}
 */
ace.VirtualRenderer.prototype.getFirstVisibleRow = function() {};

/** Undocumented */
ace.VirtualRenderer.prototype.getHighlightGutterLine = function() {};

/**
 * Returns whether the horizontal scrollbar is set to be always visible.
 * @return {boolean}
 */
ace.VirtualRenderer.prototype.getHScrollBarAlwaysVisible = function() {};

/**
 * Returns the index of the last fully visible row.
 * "Fully" here means that the characters in the row are not truncated; that
 * the top and the bottom of the row are on the screen.
 * @return {number}
 */
ace.VirtualRenderer.prototype.getLastFullyVisibleRow = function() {};

/**
 * Returns the index of the last visible row.
 * @return {number}
 */
ace.VirtualRenderer.prototype.getLastVisibleRow = function() {};

/**
 * Returns the element that the mouse events are attached to.
 * @return {!Element}
 */
ace.VirtualRenderer.prototype.getMouseEventTarget = function() {};

/**
 * Returns whether the print margin column is being shown or not.
 * @return {boolean}
 */
ace.VirtualRenderer.prototype.getPrintMarginColumn = function() {};

/**
 * Returns the last visible row, regardless of whether it's fully visible or
 * not.
 * @return {number}
 */
ace.VirtualRenderer.prototype.getScrollBottomRow = function() {};

/**
 * Returns the value of the distance between the left of the editor and the
 * leftmost part of the visible content.
 * @return {number}
 */
ace.VirtualRenderer.prototype.getScrollLeft = function() {};

/**
 * Returns the value of the distance between the top of the editor and the
 * topmost part of the visible content.
 * @return {number}
 */
ace.VirtualRenderer.prototype.getScrollTop = function() {};

/**
 * Returns the first visible row, regardless of whether it's fully visible or
 * not.
 * @return {number}
 */
ace.VirtualRenderer.prototype.getScrollTopRow = function() {};

/**
 * Returns true if the gutter is being shown.
 * @return {boolean}
 */
ace.VirtualRenderer.prototype.getShowGutter = function() {};

/**
 * Returns whether invisible characters are being shown or not.
 * @return {boolean}
 */
ace.VirtualRenderer.prototype.getShowInvisibles = function() {};

/**
 * Returns whether the print margin is being shown or not.
 * @return {boolean}
 */
ace.VirtualRenderer.prototype.getShowPrintMargin = function() {};

/**
 * Returns the element to which the hidden text area is added.
 * @return {!Element}
 */
ace.VirtualRenderer.prototype.getTextAreaContainer = function() {};

/**
 * Returns the path of the current theme.
 * @return {string}
 */
ace.VirtualRenderer.prototype.getTheme = function() {};

/**
 * Hides the current composition.
 */
ace.VirtualRenderer.prototype.hideComposition = function() {};

/**
 * Hides the cursor icon.
 */
ace.VirtualRenderer.prototype.hideCursor = function() {};

/**
 * Returns true if you can still scroll by either parameter; in other words,
 * you haven't reached the end of the file or line.
 * @param {number} deltaX
 * @param {number} deltaY
 * @return {boolean}
 */
ace.VirtualRenderer.prototype.isScrollableBy = function(deltaX, deltaY) {};

/** Undocumented */
ace.VirtualRenderer.prototype.onChangeTabSize = function() {};

/** Undocumented */
ace.VirtualRenderer.prototype.onGutterResize = function() {};

/**
 * Triggers a resize of the editor.
 * @param {boolean} force
 * @param {number} gutterWidth
 * @param {number} width
 * @param {number} height
 */
ace.VirtualRenderer.prototype.onResize = function(force, gutterWidth, width, height) {};

/** Undocumented */
ace.VirtualRenderer.prototype.pixelToScreenCoordinates = function() {};

/**
 * Deprecated (moved to EditSession)
 * @deprecated
 * @param {!Object} row
 * @param {!Object} className
 */
ace.VirtualRenderer.prototype.removeGutterDecoration = function(row, className) {};

/** Undocumented */
ace.VirtualRenderer.prototype.screenToTextCoordinates = function() {};

/**
 * Scrolls the editor across both x- and y-axes.
 * @param {number} deltaX
 * @param {number} deltaY
 */
ace.VirtualRenderer.prototype.scrollBy = function(deltaX, deltaY) {};

/**
 * Scrolls the cursor into the first visibile area of the editor
 * @param {!Object} cursor
 * @param {!Object} offset
 */
ace.VirtualRenderer.prototype.scrollCursorIntoView = function(cursor, offset) {};

/** Undocumented */
ace.VirtualRenderer.prototype.scrollSelectionIntoView = function() {};

/**
 * Gracefully scrolls the editor to the row indicated.
 * @param {number} line
 * @param {boolean} center
 * @param {boolean} animate
 * @param {!Function} callback
 */
ace.VirtualRenderer.prototype.scrollToLine = function(line, center, animate, callback) {};

/**
 * Gracefully scrolls from the top of the editor to the row indicated.
 * @param {number} row
 */
ace.VirtualRenderer.prototype.scrollToRow = function(row) {};

/**
 * Scrolls the editor across the x-axis to the pixel indicated.
 * @param {number} scrollLeft
 * @return {number}
 */
ace.VirtualRenderer.prototype.scrollToX = function(scrollLeft) {};

/**
 * Scrolls the editor to the y pixel indicated.
 * @param {number} scrollTop
 * @return {number}
 */
ace.VirtualRenderer.prototype.scrollToY = function(scrollTop) {};

/**
 * Identifies whether you want to have an animated scroll or not.
 * @param {boolean} shouldAnimate
 */
ace.VirtualRenderer.prototype.setAnimatedScroll = function(shouldAnimate) {};

/**
 * Sets annotations for the gutter.
 * @param {!Array<!Object>} annotations
 */
ace.VirtualRenderer.prototype.setAnnotations = function(annotations) {};

/**
 * @param {string} text
 */
ace.VirtualRenderer.prototype.setCompositionText = function(text) {};

/** Undocumented */
ace.VirtualRenderer.prototype.setDisplayIndentGuides = function() {};

/** Undocumented */
ace.VirtualRenderer.prototype.setFadeFoldWidgets = function() {};

/** Undocumented */
ace.VirtualRenderer.prototype.setHighlightGutterLine = function() {};

/**
 * Identifies whether you want to show the horizontal scrollbar or not.
 * @param {boolean} alwaysVisible
 */
ace.VirtualRenderer.prototype.setHScrollBarAlwaysVisible = function(alwaysVisible) {};

/**
 * Sets the padding for all the layers.
 * @param {number} padding
 */
ace.VirtualRenderer.prototype.setPadding = function(padding) {};

/**
 * Identifies whether you want to show the print margin column or not.
 * @param {boolean} showPrintMargin
 */
ace.VirtualRenderer.prototype.setPrintMarginColumn = function(showPrintMargin) {};

/**
 * Associates the renderer with an EditSession.
 * @param {!ace.EditSession} session
 */
ace.VirtualRenderer.prototype.setSession = function(session) {};

/**
 * Identifies whether you want to show the gutter or not.
 * @param {boolean} show
 */
ace.VirtualRenderer.prototype.setShowGutter = function(show) {};

/**
 * Identifies whether you want to show invisible characters or not.
 * @param {boolean} showInvisibles
 */
ace.VirtualRenderer.prototype.setShowInvisibles = function(showInvisibles) {};

/**
 * Identifies whether you want to show the print margin or not.
 * @param {boolean} showPrintMargin
 */
ace.VirtualRenderer.prototype.setShowPrintMargin = function(showPrintMargin) {};

/** Undocumented */
ace.VirtualRenderer.prototype.setStyle = function() {};

/**
 * Sets a new theme for the editor. theme should exist, and be a directory
 * path, like ace/theme/textmate.
 * @param {string} theme
 */
ace.VirtualRenderer.prototype.setTheme = function(theme) {};

/**
 * Shows the cursor icon.
 */
ace.VirtualRenderer.prototype.showCursor = function() {};

/**
 * Returns an object containing the pageX and pageY coordinates of the document
 * position.
 * @param {number} row
 * @param {number} column
 * @return {!Object}
 */
ace.VirtualRenderer.prototype.textToScreenCoordinates = function(row, column) {};

/**
 * Removes the class style from the editor.
 * @param {string} style
 */
ace.VirtualRenderer.prototype.unsetStyle = function(style) {};

/**
 * Schedules an update to all the back markers in the document.
 */
ace.VirtualRenderer.prototype.updateBackMarkers = function() {};

/**
 * Redraw breakpoints.
 * @param {!Object} rows
 */
ace.VirtualRenderer.prototype.updateBreakpoints = function(rows) {};

/** Undocumented */
ace.VirtualRenderer.prototype.updateCharacterSize = function() {};

/**
 * Updates the cursor icon.
 */
ace.VirtualRenderer.prototype.updateCursor = function() {};

/**
 * Updates the font size.
 */
ace.VirtualRenderer.prototype.updateFontSize = function() {};

/**
 * Schedules an update to all the front markers in the document.
 */
ace.VirtualRenderer.prototype.updateFrontMarkers = function() {};

/**
 * Triggers a full update of all the layers, for all the rows.
 * @param {boolean} force
 */
ace.VirtualRenderer.prototype.updateFull = function(force) {};

/**
 * Triggers a partial update of the text, from the range given by the two
 * parameters.
 * @param {number} firstRow
 * @param {number} lastRow
 */
ace.VirtualRenderer.prototype.updateLines = function(firstRow, lastRow) {};

/**
 * Triggers a full update of the text, for all the rows.
 */
ace.VirtualRenderer.prototype.updateText = function() {};

/**
 * Blurs the current container.
 */
ace.VirtualRenderer.prototype.visualizeBlur = function() {};

/**
 * Focuses the current container.
 */
 * @see http://angularjs.org/
 * @externs
 */

/**
 * @typedef {(Window|Document|Element|Array.<Element>|string|!angular.JQLite|
 *     NodeList|{length: number})}
 */
var JQLiteSelector;

/**
 * @type {Object}
 * @const
 */
var angular = {};

/**
 * @param {Object} self
 * @param {Function} fn
 * @param {...*} args
 * @return {Function}
 */
angular.bind = function(self, fn, args) {};

/**
 * @param {Element|HTMLDocument} element
 * @param {Array.<string|Function>=} opt_modules
 * @return {!angular.$injector}
 */
angular.bootstrap = function(element, opt_modules) {};

/**
 * @param {T} source
 * @param {(Object|Array)=} opt_dest
 * @return {T}
 * @template T
 */
angular.copy = function(source, opt_dest) {};

/**
 * @param {(JQLiteSelector|Object)} element
 * @param {(JQLiteSelector|Object)=} opt_context
 * @return {!angular.JQLite}
 */
angular.element = function(element, opt_context) {};

/**
 * @param {*} o1
 * @param {*} o2
 * @return {boolean}
 */
angular.equals = function(o1, o2) {};

/**
 * @param {Object} dest
 * @param {...Object} srcs
 */
angular.extend = function(dest, srcs) {};

/**
 * @param {Object|Array} obj
 * @param {Function} iterator
 * @param {Object=} opt_context
 * @return {Object|Array}
 */
angular.forEach = function(obj, iterator, opt_context) {};

/**
 * @param {string|T} json
 * @return {Object|Array|Date|T}
 * @template T
 */
angular.fromJson = function(json) {};

/**
 * @param {*} arg
 * @return {*}
 */
angular.identity = function(arg) {};

/**
 * @param {Array.<string|Function>} modules
 * @return {!angular.$injector}
 */
angular.injector = function(modules) {};

/**
 * @param {*} value
 * @return {boolean}
 */
angular.isArray = function(value) {};

/**
 * @param {*} value
 * @return {boolean}
 */
angular.isDate = function(value) {};

/**
 * @param {*} value
 * @return {boolean}
 */
angular.isDefined = function(value) {};

/**
 * @param {*} value
 * @return {boolean}
 */
angular.isElement = function(value) {};

/**
 * @param {*} value
 * @return {boolean}
 */
angular.isFunction = function(value) {};

/**
 * @param {*} value
 * @return {boolean}
 */
angular.isNumber = function(value) {};

/**
 * @param {*} value
 * @return {boolean}
 */
angular.isObject = function(value) {};

/**
 * @param {*} value
 * @return {boolean}
 */
angular.isString = function(value) {};

/**
 * @param {*} value
 * @return {boolean}
 */
angular.isUndefined = function(value) {};

/**
 * @param {string} s
 * @return {string}
 */
angular.lowercase = function(s) {};

angular.mock = {};

/**
 * @param {string} name
 * @param {Array.<string>=} opt_requires
 * @param {(Function|Array.<string|Function>)=} opt_configFn
 * @return {!angular.Module}
 */
angular.module = function(name, opt_requires, opt_configFn) {};

angular.noop = function() {};

/**
 * @param {Object|Array|Date|string|number} obj
 * @param {boolean=} opt_pretty
 * @return {string}
 */
angular.toJson = function(obj, opt_pretty) {};

/**
 * @param {string} s
 * @return {string}
 */
angular.uppercase = function(s) {};

/**
 * @typedef {{
 *   $attr: Object.<string,string>,
 *   $normalize: function(string): string,
 *   $observe: function(string, function(*)): function(*),
 *   $set: function(string, ?(string|boolean), boolean=, string=)
 *   }}
 */
angular.Attributes;

/**
 * @param {string} name
 * @return {string}
 */
angular.Attributes.$normalize = function(name) {};

/**
 * @param {string} key
 * @param {function(*)} fn
 * @return {function(*)}
 */
angular.Attributes.$observe = function(key, fn) {};

/**
 * @param {string} key
 * @param {?(string|boolean)} value
 * @param {boolean=} opt_writeAttr
 * @param {string=} opt_attrName
 */
angular.Attributes.$set = function(key, value, opt_writeAttr, opt_attrName) {};

/**
 * @typedef {{
 *   pre: (function(
 *       !angular.Scope=, angular.JQLite=, !angular.Attributes=, Object=)|
 *       undefined),
 *   post: (function(
 *       !angular.Scope=, !angular.JQLite=, !angular.Attributes=, Object=)|
 *       undefined)
 *   }}
 */
angular.LinkingFunctions;

/**
 * @param {!angular.Scope=} scope
 * @param {!angular.JQLite=} iElement
 * @param {!angular.Attributes=} iAttrs
 * @param {(Object|Array.<Object>)=} controller
 */
angular.LinkingFunctions.pre = function(scope, iElement, iAttrs, controller) {};

/**
 * @param {!angular.Scope=} scope
 * @param {!angular.JQLite=} iElement
 * @param {!angular.Attributes=} iAttrs
 * @param {(Object|Array.<Object>)=} controller
 */
angular.LinkingFunctions.post = function(scope, iElement, iAttrs, controller) {
};

/**
 * @typedef {{
 *   compile: (function(
 *       !angular.JQLite=, !angular.Attributes=, Function=)|undefined),
 *   controller: (Function|undefined),
 *   controllerAs: (string|undefined),
 *   link: (function(
 *       !angular.Scope=, !angular.JQLite=, !angular.Attributes=,
 *       (Object|Array.<Object>)=)|
 *       undefined),
 *   name: (string|undefined),
 *   priority: (number|undefined),
 *   replace: (boolean|undefined),
 *   require: (string|Array.<string>|undefined),
 *   restrict: (string|undefined),
 *   scope: (boolean|Object.<string, string>|undefined),
 *   template: (string|undefined),
 *   templateUrl: (string|undefined),
 *   terminal: (boolean|undefined),
 *   transclude: (boolean|string|undefined)
 *   }}
 */
angular.Directive;

/**
 * @param {!angular.JQLite=} tElement
 * @param {!angular.Attributes=} tAttrs
 * @param {Function=} transclude
 * @return {Function|angular.LinkingFunctions|undefined}
 */
angular.Directive.compile = function(tElement, tAttrs, transclude) {};

angular.Directive.controller = function() {};

/**
 * @type {string|undefined}
 */
angular.Directive.controllerAs;

/**
 * @param {!angular.Scope=} scope
 * @param {!angular.JQLite=} iElement
 * @param {!angular.Attributes=} iAttrs
 * @param {(Object|Array.<Object>)=} controller
 */
angular.Directive.link = function(scope, iElement, iAttrs, controller) {};

/**
 * @type {(string|undefined)}
 */
angular.Directive.name;

/**
 * @type {(number|undefined)}
 */
angular.Directive.priority;

/**
 * @type {(boolean|undefined)}
 */
angular.Directive.replace;

/**
 * @type {(string|Array.<string>|undefined)}
 */
angular.Directive.require;

/**
 * @type {(string|undefined)}
 */
angular.Directive.restrict;

/**
 * @type {(boolean|Object.<string, string>|undefined)}
 */
angular.Directive.scope;

/**
 * @type {(string|undefined)}
 * TODO: This can also be a function which returns a string.
 */
angular.Directive.template;

/**
 * @type {(string|undefined)}
 */
angular.Directive.templateUrl;

/**
 * @type {(boolean|undefined)}
 */
angular.Directive.terminal;

/**
 * @type {(boolean|string|undefined)}
 */
angular.Directive.transclude;

/**
 * @typedef {{
 *   addClass: function(string): !angular.JQLite,
 *   after: function(JQLiteSelector): !angular.JQLite,
 *   append: function(JQLiteSelector): !angular.JQLite,
 *   attr: function(string, (string|boolean)=):
 *       (!angular.JQLite|string|boolean),
 *   bind: function(string, Function): !angular.JQLite,
 *   children: function(): !angular.JQLite,
 *   clone: function(): !angular.JQLite,
 *   contents: function(): !angular.JQLite,
 *   controller: function(string=): Object,
 *   css: function(string, string=): (!angular.JQLite|string),
 *   data: function(string=, *=): *,
 *   eq: function(number): !angular.JQLite,
 *   find: function(string): !angular.JQLite,
 *   hasClass: function(string): boolean,
 *   html: function(string=): (!angular.JQLite|string),
 *   inheritedData: function(string=, *=): *,
 *   injector: function(): !angular.$injector,
 *   length: number,
 *   next: function(): !angular.JQLite,
 *   parent: function(): !angular.JQLite,
 *   prepend: function(JQLiteSelector): !angular.JQLite,
 *   prop: function(string, *=): *,
 *   ready: function(Function): !angular.JQLite,
 *   remove: function(): !angular.JQLite,
 *   removeAttr: function(string): !angular.JQLite,
 *   removeClass: function(string): !angular.JQLite,
 *   removeData: function(): !angular.JQLite,
 *   replaceWith: function(JQLiteSelector): !angular.JQLite,
 *   scope: function(): !angular.Scope,
 *   text: function(string=): (!angular.JQLite|string),
 *   toggleClass: function(string, boolean=): !angular.JQLite,
 *   unbind: function(string=, Function=): !angular.JQLite,
 *   val: function(string=): (!angular.JQLite|string),
 *   wrap: function(JQLiteSelector): !angular.JQLite
 *   }}
 */
angular.JQLite;

/**
 * @param {string} name
 * @return {!angular.JQLite}
 */
angular.JQLite.addClass = function(name) {};

/**
 * @param {JQLiteSelector} element
 * @return {!angular.JQLite}
 */
angular.JQLite.after = function(element) {};

/**
 * @param {JQLiteSelector} element
 * @return {!angular.JQLite}
 */
angular.JQLite.append = function(element) {};

/**
 * @param {string} name
 * @param {(string|boolean|null)=} opt_value
 * @return {!angular.JQLite|string|boolean}
 */
angular.JQLite.attr = function(name, opt_value) {};

/**
 * @param {string} type
 * @param {Function} fn
 * @return {!angular.JQLite}
 */
angular.JQLite.bind = function(type, fn) {};

/**
 * @return {!angular.JQLite}
 */
angular.JQLite.children = function() {};

/**
 * @return {!angular.JQLite}
 */
angular.JQLite.clone = function() {};

/**
 * @return {!angular.JQLite}
 */
angular.JQLite.contents = function() {};

/**
 * @param {string=} opt_name
 * @return {Object}
 */
angular.JQLite.controller = function(opt_name) {};

/**
 * @param {string} name
 * @param {string=} opt_value
 * @return {!angular.JQLite|string}
 */
angular.JQLite.css = function(name, opt_value) {};

/**
 * @param {string=} opt_key
 * @param {*=} opt_value
 * @return {*}
 */
angular.JQLite.data = function(opt_key, opt_value) {};

/**
 * @param {number} index
 * @return {!angular.JQLite}
 */
angular.JQLite.eq = function(index) {};

/**
 * @param {string} selector
 * @return {!angular.JQLite}
 */
angular.JQLite.find = function(selector) {};

/**
 * @param {string} name
 * @return {boolean}
 */
angular.JQLite.hasClass = function(name) {};

/**
 * @param {string=} opt_value
 * @return {!angular.JQLite|string}
 */
angular.JQLite.html = function(opt_value) {};

/**
 * @param {string=} opt_key
 * @param {*=} opt_value
 * @return {*}
 */
angular.JQLite.inheritedData = function(opt_key, opt_value) {};

/**
 * @return {!angular.$injector}
 */
angular.JQLite.injector = function() {};

/** @type {number} */
angular.JQLite.length;

/**
 * @return {!angular.JQLite}
 */
angular.JQLite.next = function() {};

/**
 * @return {!angular.JQLite}
 */
angular.JQLite.parent = function() {};

/**
 * @param {JQLiteSelector} element
 * @return {!angular.JQLite}
 */
angular.JQLite.prepend = function(element) {};

/**
 * @param {string} name
 * @param {*=} opt_value
 * @return {*}
 */
angular.JQLite.prop = function(name, opt_value) {};

/**
 * @param {Function} fn
 * @return {!angular.JQLite}
 */
angular.JQLite.ready = function(fn) {};

/**
 * @return {!angular.JQLite}
 */
angular.JQLite.remove = function() {};

/**
 * @param {string} name
 * @return {!angular.JQLite}
 */
angular.JQLite.removeAttr = function(name) {};

/**
 * @param {string} name
 * @return {!angular.JQLite}
 */
angular.JQLite.removeClass = function(name) {};

/**
 * @return {!angular.JQLite}
 */
angular.JQLite.removeData = function() {};

/**
 * @param {JQLiteSelector} element
 * @return {!angular.JQLite}
 */
angular.JQLite.replaceWith = function(element) {};

/**
 * @return {!angular.Scope}
 */
angular.JQLite.scope = function() {};

/**
 * @param {string=} opt_value
 * @return {!angular.JQLite|string}
 */
angular.JQLite.text = function(opt_value) {};

/**
 * @param {string} name
 * @param {boolean=} opt_condition
 * @return {!angular.JQLite}
 */
angular.JQLite.toggleClass = function(name, opt_condition) {};

/**
 * @param {string=} opt_type
 * @param {Function=} opt_fn
 * @return {!angular.JQLite}
 */
angular.JQLite.unbind = function(opt_type, opt_fn) {};

/**
 * @param {string=} opt_value
 * @return {!angular.JQLite|string}
 */
angular.JQLite.val = function(opt_value) {};

/**
 * @param {JQLiteSelector} element
 * @return {!angular.JQLite}
 */
angular.JQLite.wrap = function(element) {};

/**
 * @typedef {{
 *   config: function((Function|Array.<string|Function>)):!angular.Module,
 *   constant: function(string, *):!angular.Module,
 *   controller:
 *       (function(string, (Function|Array.<string|Function>)):!angular.Module|
 *       function(!Object.<(Function|Array.<string|Function>)>):
 *           !angular.Module),
 *   directive:
 *       (function(string, (Function|Array.<string|Function>)):!angular.Module|
 *       function(!Object.<(Function|Array.<string|Function>)>):
 *           !angular.Module),
 *   factory:
 *       function(string, (Function|Array.<string|Function>)):!angular.Module,
 *   filter:
 *       function(string, (Function|Array.<string|Function>)):!angular.Module,
 *   name: string,
 *   provider: function(string,
 *       (Object|Function|Array.<string|Function>)):!angular.Module,
 *   requires: Array.<string>,
 *   run: function((Function|Array.<string|Function>)):!angular.Module,
 *   service:
 *       function(string, (Function|Array.<string|Function>)):!angular.Module,
 *   value: function(string, *):!angular.Module
 *   }}
 */
angular.Module;

/**
 * @param {Function|Array.<string|Function>} configFn
 * @return {!angular.Module}
 */
angular.Module.config = function(configFn) {};

/**
 * @param {string} name
 * @param {*} object
 * @return {!angular.Module}
 */
angular.Module.constant = function(name, object) {};

/**
 * @param {string} name
 * @param {Function|Array.<string|Function>} constructor
 * @return {!angular.Module}
 */
angular.Module.controller = function(name, constructor) {};

/**
 * @param {string} name
 * @param {Function|Array.<string|Function>} directiveFactory
 * @return {!angular.Module}
 */
angular.Module.directive = function(name, directiveFactory) {};

/**
 * @param {string} name
 * @param {Function|Array.<string|Function>} providerFunction
 * @return {!angular.Module}
 */
angular.Module.factory = function(name, providerFunction) {};

/**
 * @param {string} name
 * @param {Function|Array.<string|Function>} filterFactory
 * @return {!angular.Module}
 */
angular.Module.filter = function(name, filterFactory) {};

/**
 * @param {string} name
 * @param {Function|Array.<string|Function>} providerType
 * @return {!angular.Module}
 */
angular.Module.provider = function(name, providerType) {};

/**
 * @param {Function|Array.<string|Function>} initializationFn
 * @return {!angular.Module}
 */
angular.Module.run = function(initializationFn) {};

/**
 * @param {string} name
 * @param {Function|Array.<string|Function>} constructor
 * @return {!angular.Module}
 */
angular.Module.service = function(name, constructor) {};

/**
 * @param {string} name
 * @param {*} object
 * @return {!angular.Module}
 */
angular.Module.value = function(name, object) {};

/**
 * @type {string}
 */
angular.Module.name = '';

/**
 * @type {Array.<string>}
 */
angular.Module.requires;

/**
 * @typedef {{
 *   $$phase: string,
 *   $apply: function((string|function(angular.Scope))=):*,
 *   $broadcast: function(string, ...*),
 *   $destroy: function(),
 *   $digest: function(),
 *   $emit: function(string, ...*),
 *   $eval: function((string|function(!angular.Scope))=, Object=):*,
 *   $evalAsync: function((string|function())=),
 *   $id: string,
 *   $new: function(boolean=):!angular.Scope,
 *   $on: function(string, function(!angular.Scope.Event, ...?)):function(),
 *   $parent: !angular.Scope,
 *   $root: !angular.Scope,
 *   $watch: function(
 *       (string|Function), (string|Function)=, boolean=):function()
 *   }}
 */
angular.Scope;

/** @type {string} */
angular.Scope.$$phase;

/**
 * @param {(string|function(!angular.Scope))=} opt_exp
 * @return {*}
 */
angular.Scope.$apply = function(opt_exp) {};

/**
 * @param {string} name
 * @param {...*} args
 */
angular.Scope.$broadcast = function(name, args) {};

angular.Scope.$destroy = function() {};

angular.Scope.$digest = function() {};

/**
 * @param {string} name
 * @param {...*} args
 */
angular.Scope.$emit = function(name, args) {};

/**
 * @param {(string|function())=} opt_exp
 * @param {Object=} opt_locals
 * @return {*}
 */
angular.Scope.$eval = function(opt_exp, opt_locals) {};

/**
 * @param {(string|function())=} opt_exp
 */
angular.Scope.$evalAsync = function(opt_exp) {};

/** @type {string} */
angular.Scope.$id;

/**
 * @param {boolean=} opt_isolate
 * @return {!angular.Scope}
 */
angular.Scope.$new = function(opt_isolate) {};

/**
 * @param {string} name
 * @param {function(!angular.Scope.Event, ...?)} listener
 * @return {function()}
 */
angular.Scope.$on = function(name, listener) {};

/** @type {!angular.Scope} */
angular.Scope.$parent;

/** @type {!angular.Scope} */
angular.Scope.$root;

/**
 * @param {string|Function} exp
 * @param {(string|Function)=} opt_listener
 * @param {boolean=} opt_objectEquality
 * @return {function()}
 */
angular.Scope.$watch = function(exp, opt_listener, opt_objectEquality) {};

/**
 * @typedef {{
 *   currentScope: !angular.Scope,
 *   defaultPrevented: boolean,
 *   name: string,
 *   preventDefault: function(),
 *   stopPropagation: function(),
 *   targetScope: !angular.Scope
 *   }}
 */
angular.Scope.Event;

/** @type {!angular.Scope} */
angular.Scope.Event.currentScope;

/** @type {boolean} */
angular.Scope.Event.defaultPrevented;

/** @type {string} */
angular.Scope.Event.name;

angular.Scope.Event.preventDefault = function() {};

angular.Scope.Event.stopPropagation = function() {};

/** @type {!angular.Scope} */
angular.Scope.Event.targetScope;

/**
 * @type {Object}
 */
angular.version = {};

/**
 * @type {string}
 */
angular.version.full = '';

/**
 * @type {number}
 */
angular.version.major = 0;

/**
 * @type {number}
 */
angular.version.minor = 0;

/**
 * @type {number}
 */
angular.version.dot = 0;

/**
 * @type {string}
 */
angular.version.codeName = '';

/******************************************************************************
 * $anchorScroll Service
 *****************************************************************************/

/**
 * @typedef {function()}
 */
angular.$anchorScroll;

/******************************************************************************
 * $anchorScrollProvider Service
 *****************************************************************************/

/**
 * @typedef {{
 *   disableAutoScrolling: function()
 *   }}
 */
angular.$anchorScrollProvider;

/**
 * @type {function()}
 */
angular.$anchorScrollProvider.disableAutoScrolling = function() {};

/******************************************************************************
 * $compile Service
 *****************************************************************************/

/**
 * @typedef {
 *   function(
 *       (JQLiteSelector|Object),
 *           function(!angular.Scope, Function=)=, number=):
 *               function(!angular.Scope,
 *                   function(Object, !angular.Scope=)=): Object}
 */
angular.$compile;

/******************************************************************************
 * $cacheFactory Service
 *****************************************************************************/

/**
 * @typedef {
 *   function(string, angular.$cacheFactory.Options=):
 *       !angular.$cacheFactory.Cache}
 */
angular.$cacheFactory;

/** @typedef {{capacity: (number|undefined)}} */
angular.$cacheFactory.Options;

/**
 * @typedef {{
 *   info: function():!angular.$cacheFactory.Cache.Info,
 *   put: function(string, *),
 *   get: function(string):*,
 *   remove: function(string),
 *   removeAll: function(),
 *   destroy: function()
 *   }}
 */
angular.$cacheFactory.Cache;

/**
 * @typedef {{
 *   id: string,
 *   size: number,
 *   options: !angular.$cacheFactory.Options
 *   }}
 */
angular.$cacheFactory.Cache.Info;

/******************************************************************************
 * $controller Service
 *****************************************************************************/

/**
 * @typedef {function((Function|string), Object):Object}
 */
angular.$controller;

/******************************************************************************
 * $controllerProvider Service
 *****************************************************************************/

/**
 * @typedef {{
 *   register: function((string|Object), (Function|Array))
 *   }}
 */
angular.$controllerProvider;

/******************************************************************************
 * $exceptionHandler Service
 *****************************************************************************/

/**
 * @typedef {function(Error, string=)}
 */
angular.$exceptionHandler;

/******************************************************************************
 * $filter Service
 *****************************************************************************/

/**
 * @typedef {function(string): !Function}
 */
angular.$filter;

/**
 * The 'orderBy' filter is available through $filterProvider and AngularJS
 * injection; but is not accessed through a documented public API of AngularJS.
 * <p>In current AngularJS version the injection is satisfied by
 * angular.orderByFunction, where the implementation is found.
 * <p>See http://docs.angularjs.org/api/ng.filter:orderBy.
 * @typedef {function(Array,
 *     (string|function(?):*|Array.<(string|function(?):*)>),
 *     boolean=): Array}
 */
angular.$filter.orderBy;

/******************************************************************************
 * $filterProvider Service
 *****************************************************************************/

/**
 * @typedef {{
 *   register: function(string, (Function|Array.<string|Function>))
 *   }}
 */
angular.$filterProvider;

/**
 * @param {string} name
 * @param {(Function|Array.<string|Function>)} fn
 */
angular.$filterProvider.register = function(name, fn) {};

/******************************************************************************
 * $http Service
 *****************************************************************************/

/**
 * This is a typedef because the closure compiler does not allow
 * defining a type that is a function with properties.
 * If you are trying to use the $http service as a function, try
 * using one of the helper functions instead.
 * @typedef {{
 *   delete: function(string, angular.$http.Config=):!angular.$http.HttpPromise,
 *   get: function(string, angular.$http.Config=):!angular.$http.HttpPromise,
 *   head: function(string, angular.$http.Config=):!angular.$http.HttpPromise,
 *   jsonp: function(string, angular.$http.Config=):!angular.$http.HttpPromise,
 *   post: function(string, *, angular.$http.Config=):
 *       !angular.$http.HttpPromise,
 *   put: function(string, *, angular.$http.Config=):!angular.$http.HttpPromise,
 *   defaults: angular.$http.Config,
 *   pendingRequests: Array.<angular.$http.Config>
 *   }}
 */
angular.$http;

/**
 * @typedef {{
 *   cache: (boolean|!angular.$cacheFactory.Cache|undefined),
 *   data: (string|Object|undefined),
 *   headers: (Object|undefined),
 *   method: (string|undefined),
 *   params: (Object.<(string|Object)>|undefined),
 *   timeout: (number|undefined),
 *   transformRequest:
 *       (function((string|Object), Object):(string|Object)|
 *       Array.<function((string|Object), Object):(string|Object)>|undefined),
 *   transformResponse:
 *       (function((string|Object), Object):(string|Object)|
 *       Array.<function((string|Object), Object):(string|Object)>|undefined),
 *   url: (string|undefined),
 *   withCredentials: (boolean|undefined)
 *   }}
 */
angular.$http.Config;

// /**
//  * This extern is currently incomplete as delete is a reserved word.
//  * To use delete, index $http.
//  * Example: $http['delete'](url, opt_config);
//  * @param {string} url
//  * @param {angular.$http.Config=} opt_config
//  * @return {!angular.$http.HttpPromise}
//  */
// angular.$http.delete = function(url, opt_config) {};

/**
 * @param {string} url
 * @param {angular.$http.Config=} opt_config
 * @return {!angular.$http.HttpPromise}
 */
angular.$http.get = function(url, opt_config) {};

/**
 * @param {string} url
 * @param {angular.$http.Config=} opt_config
 * @return {!angular.$http.HttpPromise}
 */
angular.$http.head = function(url, opt_config) {};

/**
 * @param {string} url
 * @param {angular.$http.Config=} opt_config
 * @return {!angular.$http.HttpPromise}
 */
angular.$http.jsonp = function(url, opt_config) {};

/**
 * @param {string} url
 * @param {*} data
 * @param {angular.$http.Config=} opt_config
 * @return {!angular.$http.HttpPromise}
 */
angular.$http.post = function(url, data, opt_config) {};

/**
 * @param {string} url
 * @param {*} data
 * @param {angular.$http.Config=} opt_config
 * @return {!angular.$http.HttpPromise}
 */
angular.$http.put = function(url, data, opt_config) {};

/**
 * @type {angular.$http.Config}
 */
angular.$http.defaults;

/**
 * @type {Array.<angular.$http.Config>}
 * @const
 */
angular.$http.pendingRequests;

/**
 * @typedef {function((string|Object), number,
 *     function(string=): (string|Object|null), angular.$http.Config)}
 */
angular.HttpCallback;

/**
 * @typedef {{
 *   then: function(
 *       ?function(!angular.$http.Response),
 *       ?function(!angular.$http.Response)=): !angular.$http.HttpPromise,
 *   success: function(angular.HttpCallback): !angular.$http.HttpPromise,
 *   error: function(angular.HttpCallback): !angular.$http.HttpPromise
 * }}
 */
angular.$http.HttpPromise;

/**
 * @param {?function(!angular.$http.Response)} successCallback
 * @param {?function(!angular.$http.Response)=} opt_errorCallback
 * @return {!angular.$http.HttpPromise}
 */
angular.$http.HttpPromise.then = function(
    successCallback, opt_errorCallback) {};

/**
 * @param {angular.HttpCallback} callback
 * @return {!angular.$http.HttpPromise} Promise for chaining.
 */
angular.$http.HttpPromise.success = function(callback) {};

/**
 * @param {angular.HttpCallback} callback
 * @return {!angular.$http.HttpPromise} Promise for chaining.
 */
angular.$http.HttpPromise.error = function(callback) {};

/**
 * @typedef {{
 *   data: (string|Object),
 *   status: number,
 *   headers: function(string=): (string|Object),
 *   config: !angular.$http.Config
 *   }}
 */
angular.$http.Response;

/******************************************************************************
 * $injector Service
 *****************************************************************************/

/**
 * @typedef {{
 *   annotate: function((Function|Array.<string|Function>)):Array.<string>,
 *   get: function(string):(?),
 *   instantiate: function(Function, Object=):Object,
 *   invoke: function(
 *       (Function|Array.<string|Function>), Object=, Object=):(?)
 *   }}
 */
angular.$injector;

/**
 * @param {(Function|Array.<string|Function>)} fn
 * @return {Array.<string>}
 */
angular.$injector.annotate = function(fn) {};

/**
 * @param {string} name
 * @return {?}
 */
angular.$injector.get = function(name) {};

/**
 * @param {Function} type
 * @param {Object=} opt_locals
 * @return {Object}
 */
angular.$injector.instantiate = function(type, opt_locals) {};

/**
 * @param {(Function|Array.<string|Function>)} fn
 * @param {Object=} opt_self
 * @param {Object=} opt_locals
 * @return {?}
 */
angular.$injector.invoke = function(fn, opt_self, opt_locals) {};

/******************************************************************************
 * $interpolateProvider Service
 *****************************************************************************/

/**
 * @typedef {{
 *   startSymbol: function(string),
 *   endSymbol: function(string)
 *   }}
 */
angular.$interpolateProvider;

/** @type {function(string)} */
angular.$interpolateProvider.startSymbol;

/** @type {function(string)} */
angular.$interpolateProvider.endSymbol;

/******************************************************************************
 * $interval Service
 *****************************************************************************/

/**
 * @typedef {
 *  function(function(), number=, number=, boolean=):angular.$q.Promise
 * }
 */
angular.$interval;

/**
 * Augment the angular.$interval type definition by reopening the type via an
 * artificial angular.$interval instance.
 *
 * This allows us to define methods on function objects which is something
 * that can't be expressed via typical type annotations.
 *
 * @type {angular.$interval}
 */
angular.$interval_;

/**
 * @type {function(!angular.$q.Promise):boolean}
 */
angular.$interval_.cancel = function(promise) {};

/******************************************************************************
 * $location Service
 *****************************************************************************/

/**
 * @typedef {{
 *   absUrl: function():string,
 *   hash: function(string=):string,
 *   host: function():string,
 *   path: function(string=):(string|!angular.$location),
 *   port: function():number,
 *   protocol: function():string,
 *   replace: function(),
 *   search: function((string|Object.<string, string>)=, ?string=):
 *       (string|!Object.<string, string>),
 *   url: function(string=):string
 *   }}
 */
angular.$location;

/**
 * @return {string}
 */
angular.$location.absUrl = function() {};

/**
 * @param {string=} opt_hash
 * @return {string}
 */
angular.$location.hash = function(opt_hash) {};

/**
 * @return {string}
 */
angular.$location.host = function() {};

/**
 * @param {string=} opt_path
 * @return {string|!angular.$location}
 */
angular.$location.path = function(opt_path) {};

/**
 * @return {number}
 */
angular.$location.port = function() {};

/**
 * @return {string}
 */
angular.$location.protocol = function() {};

/**
 * @type {function()}
 */
angular.$location.replace = function() {};

/**
 * @param {(string|Object.<string, string>)=} opt_search
 * @param {?string=} opt_paramValue
 * @return {string|!Object.<string, string>}
 */
angular.$location.search = function(opt_search, opt_paramValue) {};

/**
 * @param {string=} opt_url
 * @return {string}
 */
angular.$location.url = function(opt_url) {};

/******************************************************************************
 * $locationProvider Service
 *****************************************************************************/

/**
 * @typedef {{
 *   hashPrefix:
 *       function(string=): (string|angular.$locationProvider),
 *   html5Mode:
 *       function(boolean=): (boolean|!angular.$locationProvider)
 *   }}
 */
angular.$locationProvider;

/**
 * @param {string=} opt_prefix
 * @return {string|!angular.$locationProvider}
 */
angular.$locationProvider.hashPrefix = function(opt_prefix) {};

/**
 * @param {boolean=} opt_enabled
 * @return {boolean|!angular.$locationProvider}
 */
angular.$locationProvider.html5Mode = function(opt_enabled) {};

/******************************************************************************
 * $log Service
 *****************************************************************************/

/**
 * @typedef {{
 *   error: function(...*),
 *   info: function(...*),
 *   log: function(...*),
 *   warn: function(...*)
 *   }}
 */
angular.$log;

/**
 * @param {...*} var_args
 */
angular.$log.error = function(var_args) {};

/**
 * @param {...*} var_args
 */
angular.$log.info = function(var_args) {};

/**
 * @param {...*} var_args
 */
angular.$log.log = function(var_args) {};

/**
 * @param {...*} var_args
 */
angular.$log.warn = function(var_args) {};

/******************************************************************************
 * NgModelController
 *****************************************************************************/

/**
 * @constructor
 */
angular.NgModelController = function() {};

/**
 * @type {?}
 */
angular.NgModelController.prototype.$modelValue;

/**
 * @type {boolean}
 */
angular.NgModelController.prototype.$dirty;

/**
 * @type {!Object.<boolean>}
 */
angular.NgModelController.prototype.$error;

/**
 * @type {!Array.<function(?):*>}
 */
angular.NgModelController.prototype.$formatters;

/**
 * @type {boolean}
 */
angular.NgModelController.prototype.$invalid;

/**
 * @type {!Array.<function(?):*>}
 */
angular.NgModelController.prototype.$parsers;

/**
 * @type {boolean}
 */
angular.NgModelController.prototype.$pristine;

angular.NgModelController.prototype.$render = function() {};

/**
 * @param {string} key
 * @param {boolean} isValid
 */
angular.NgModelController.prototype.$setValidity = function(key, isValid) {};

/**
 * @param {?} value
 */
angular.NgModelController.prototype.$setViewValue = function(value) {};

/**
 * @type {boolean}
 */
angular.NgModelController.prototype.$valid;

/**
 * @type {!Array.<function()>}
 */
angular.NgModelController.prototype.$viewChangeListeners;

/**
 * @type {?}
 */
angular.NgModelController.prototype.$viewValue;

/******************************************************************************
 * FormController
 *****************************************************************************/

/**
 * @constructor
 */
angular.FormController = function() {};

/**
 * @type {boolean}
 */
angular.FormController.prototype.$dirty;

/**
 * @type {!Object.<boolean>}
 */
angular.FormController.prototype.$error;

/**
 * @type {boolean}
 */
angular.FormController.prototype.$invalid;

/**
 * @type {boolean}
 */
angular.FormController.prototype.$pristine;

/**
 * @type {boolean}
 */
angular.FormController.prototype.$valid;

/******************************************************************************
 * $parse Service
 *****************************************************************************/

/**
 * @typedef {function(string):!angular.$parse.Expression}
 */
angular.$parse;

/**
 * @typedef {function((!angular.Scope|!Object), Object=):*}
 */
angular.$parse.Expression;

/**
 * Augment the angular.$parse.Expression type definition by reopening the type
 * via an artificial angular.$parse instance.
 *
 * This allows us to define methods on function objects which is something
 * that can't be expressed via typical type annotations.
 *
 * @type {angular.$parse.Expression}
 */
angular.$parse_;

/**
 * @type {function((!angular.Scope|!Object), *)}
 */
angular.$parse_.assign = function(scope, newValue) {};

/******************************************************************************
 * $provide Service
 *****************************************************************************/

/**
 * @typedef {{
 *   constant: function(string, *): Object,
 *   decorator: function(string, (Function|Array.<string|Function>)),
 *   factory: function(string, (Function|Array.<string|Function>)): Object,
 *   provider: function(string, (Function|Array.<string|Function>)): Object,
 *   service: function(string, (Function|Array.<string|Function>)): Object,
 *   value: function(string, *): Object
 *   }}
 */
angular.$provide;

/**
 * @param {string} name
 * @param {*} object
 * @return {Object}
 */
angular.$provide.constant = function(name, object) {};

/**
 * @param {string} name
 * @param {Function|Array.<string|Function>} decorator
 */
angular.$provide.decorator = function(name, decorator) {};

/**
 * @param {string} name
 * @param {Function|Array.<string|Function>} providerFunction
 * @return {Object}
 */
angular.$provide.factory = function(name, providerFunction) {};

/**
 * @param {string} name
 * @param {Function|Array.<string|Function>} providerType
 * @return {Object}
 */
angular.$provide.provider = function(name, providerType) {};

/**
 * @param {string} name
 * @param {Function|Array.<string|Function>} constructor
 * @return {Object}
 */
angular.$provide.service = function(name, constructor) {};

/**
 * @param {string} name
 * @param {*} object
 * @return {Object}
 */
angular.$provide.value = function(name, object) {};

/******************************************************************************
 * $q Service
 *****************************************************************************/

/**
 * @typedef {{
 *   all: function(!Array.<!angular.$q.Promise>): !angular.$q.Promise,
 *   defer: function():!angular.$q.Deferred,
 *   reject: function(*):!angular.$q.Promise,
 *   when: function(*):!angular.$q.Promise
 *   }}
 */
angular.$q;

/**
 * @param {Array.<!angular.$q.Promise>} promises
 * @return {!angular.$q.Promise}
 */
angular.$q.all = function(promises) {};

/**
 * @return {!angular.$q.Deferred}
 */
angular.$q.defer = function() {};

/**
 * @param {*} reason
 * @return {!angular.$q.Promise}
 */
angular.$q.reject = function(reason) {};

/**
 * @param {*} value
 * @return {!angular.$q.Promise}
 */
angular.$q.when = function(value) {};

/**
 * @typedef {{
 *   resolve: function(*=),
 *   reject: function(*=),
 *   promise: !angular.$q.Promise
 *   }}
 */
angular.$q.Deferred;

/** @param {*=} opt_value */
angular.$q.Deferred.resolve = function(opt_value) {};

/** @param {*=} opt_reason */
angular.$q.Deferred.reject = function(opt_reason) {};

/** @type {!angular.$q.Promise} */
angular.$q.Deferred.promise;

/**
 * @typedef {{then: function(?function(?), ?function(?)=): !angular.$q.Promise}}
 */
angular.$q.Promise;

/**
 * @param {?function(?)} successCallback
 * @param {?function(?)=} opt_errorCallback
 * @return {!angular.$q.Promise}
 */
angular.$q.Promise.then = function(successCallback, opt_errorCallback) {};

/******************************************************************************
 * $route Service
 *****************************************************************************/

/**
 * @typedef {{
 *   reload: function(),
 *   current: angular.$route.Route,
 *   routes: Array.<!angular.$route.Route>
 * }}
 */
angular.$route;

/** @type {function()} */
angular.$route.reload = function() {};

/** @type {!angular.$route.Route} */
angular.$route.current;

/** @type {Array.<!angular.$route.Route>} */
angular.$route.routes;

/**
 * @typedef {{
 *   $route: angular.$routeProvider.Params,
 *   locals: Object.<string, *>,
 *   params: Object.<string, string>,
 *   pathParams: Object.<string, string>,
 *   scope: Object.<string, *>
 * }}
 */
angular.$route.Route;

/** @type {angular.$routeProvider.Params} */
angular.$route.Route.$route;

/** @type {Object.<string, *>} */
angular.$route.Route.locals;

/** @type {Object.<string, string>} */
angular.$route.Route.params;

/** @type {Object.<string, string>} */
angular.$route.Route.pathParams;

/** @type {Object.<string, *>} */
angular.$route.Route.scope;

/******************************************************************************
 * $routeProvider Service
 *****************************************************************************/

/**
 * @typedef {{
 *   otherwise:
 *       function(angular.$routeProvider.Params): !angular.$routeProvider,
 *   when:
 *       function(
 *           string, angular.$routeProvider.Params): !angular.$routeProvider
 *   }}
 */
angular.$routeProvider;

/**
 * @param {angular.$routeProvider.Params} params
 * @return {!angular.$routeProvider}
 */
angular.$routeProvider.otherwise = function(params) {};

/**
 * @param {string} path
 * @param {angular.$routeProvider.Params} route
 * @return {!angular.$routeProvider}
 */
angular.$routeProvider.when = function(path, route) {};

/**
 * @typedef {{
 *   controller: (Function|Array.<string|Function>|string|undefined),
 *   template: (string|undefined),
 *   templateUrl: (string|undefined),
 *   resolve: (Object.<string, (
 *       string|Function|Array.<string|Function>|!angular.$q.Promise
 *       )>|undefined),
 *   redirectTo: (string|function()|undefined),
 *   reloadOnSearch: (boolean|undefined)
 *   }}
 */
angular.$routeProvider.Params;

/** @type {Function|Array.<string|Function>|string} */
angular.$routeProvider.Params.controller;

/** @type {string} */
angular.$routeProvider.Params.template;

/** @type {string} */
angular.$routeProvider.Params.templateUrl;

/**
 * @type {
 *   Object.<string, (
 *       string|Function|Array.<string|Function>|!angular.$q.Promise
 *       )>}
 */
angular.$routeProvider.Params.resolve;

/** @type {string|function()} */
angular.$routeProvider.Params.redirectTo;

/** @type {boolean} */
angular.$routeProvider.Params.reloadOnSearch;

/******************************************************************************
 * $timeout Service
 *****************************************************************************/

/**
 * @typedef {function(function(), number=, boolean=):!angular.$q.Promise}
 */
angular.$timeout;

/**
 * Augment the angular.$timeout type definition by reopening the type via an
 * artificial angular.$timeout instance.
 *
 * This allows us to define methods on function objects which is something
 * that can't be expressed via typical type annotations.
 *
 * @type {angular.$timeout}
 */
angular.$timeout_;

/**
 * @type {function(!angular.$q.Promise):boolean}
 */
angular.$timeout_.cancel = function(promise) {};
/**
 * @fileoverview Externs for Angular 1.
 *
 * TODO: Remaining Services:
 *     $cookieStore
 *     $httpBackend
 *     $rootElement
 *     $rootScope
 *
 * @see http://angularjs.org/
 * @externs
 */

/**
 * @typedef {(Window|Document|Element|Array<Element>|string|!angular.JQLite|
 *     NodeList|{length: number})}
 */
var JQLiteSelector;

/**
 * @const
 */
var angular = {};

/**
 * @param {T} self Specifies the object which this should point to when the
 *     function is run.
 * @param {?function(this:T, ...)} fn A function to partially apply.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @param {...*} args Additional arguments that are partially applied to the
 *     function.
 * @template T
 */
angular.bind = function(self, fn, args) {};

/** @record */
angular.BootstrapOptions = function() {};

/** @type {boolean|undefined} */
angular.BootstrapOptions.prototype.strictDi;

/**
 * @param {Element|HTMLDocument} element
 * @param {Array<string|Function>=} opt_modules
 * @param {angular.BootstrapOptions=} opt_config
 * @return {!angular.$injector}
 */
angular.bootstrap = function(element, opt_modules, opt_config) {};

/**
 * @param {T} source
 * @param {(Object|Array)=} opt_dest
 * @return {T}
 * @template T
 */
angular.copy = function(source, opt_dest) {};

/**
 * @param {(JQLiteSelector|Object)} element
 * @param {(JQLiteSelector|Object)=} opt_context
 * @return {!angular.JQLite}
 */
angular.element = function(element, opt_context) {};

/**
 * @param {*} o1
 * @param {*} o2
 * @return {boolean}
 */
angular.equals = function(o1, o2) {};

/**
 * @param {Object} dest
 * @param {...Object} srcs
 */
angular.extend = function(dest, srcs) {};

/**
 * @param {Object|Array} obj
 * @param {Function} iterator
 * @param {Object=} opt_context
 * @return {Object|Array}
 */
angular.forEach = function(obj, iterator, opt_context) {};

/**
 * @param {string|T} json
 * @return {Object|Array|Date|T}
 * @template T
 */
angular.fromJson = function(json) {};

/**
 * @param {T} arg
 * @return {T}
 * @template T
 */
angular.identity = function(arg) {};

/**
 * @param {Array<string|Function>} modules
 * @return {!angular.$injector}
 */
angular.injector = function(modules) {};

/**
 * @param {*} value
 * @return {boolean}
 */
angular.isArray = function(value) {};

/**
 * @param {*} value
 * @return {boolean}
 */
angular.isDate = function(value) {};

/**
 * @param {*} value
 * @return {boolean}
 */
angular.isDefined = function(value) {};

/**
 * @param {*} value
 * @return {boolean}
 */
angular.isElement = function(value) {};

/**
 * @param {*} value
 * @return {boolean}
 */
angular.isFunction = function(value) {};

/**
 * @param {*} value
 * @return {boolean}
 */
angular.isNumber = function(value) {};

/**
 * @param {*} value
 * @return {boolean}
 */
angular.isObject = function(value) {};

/**
 * @param {*} value
 * @return {boolean}
 */
angular.isString = function(value) {};

/**
 * @param {*} value
 * @return {boolean}
 */
angular.isUndefined = function(value) {};

/**
 * @param {string} s
 * @return {string}
 */
angular.lowercase = function(s) {};

/**
 * @param {Object} dest
 * @param {...Object} srcs
 */
angular.merge = function(dest, srcs) {};

/**
 * @param {string} name
 * @param {Array<string>=} opt_requires
 * @param {angular.Injectable=} opt_configFn
 * @return {!angular.Module}
 */
angular.module = function(name, opt_requires, opt_configFn) {};

angular.noop = function() {};

angular.reloadWithDebugInfo = function() {};

/**
 * @param {Object|Array|Date|string|number|boolean} obj
 * @param {number|boolean=} opt_pretty
 * @return {string}
 */
angular.toJson = function(obj, opt_pretty) {};

/**
 * @param {string} s
 * @return {string}
 */
angular.uppercase = function(s) {};

/**
 * Note: the methods are declared as fields rather than methods, since Angular
 *   allows users to define only a subset of the methods.
 *
 * @record
 */
angular.Animation = function() {};

/**
 * @type {(function(!angular.JQLite, !Object, !Object, !Function, !Object=):
 *            (!Function|undefined))|
 *        undefined}
 */
angular.Animation.prototype.animate;

/**
 * @type {(function(!angular.JQLite, !Function, !Object=):
 *             (!Function|undefined))|
 *        undefined}
 */
angular.Animation.prototype.enter = function(element, doneFn, opt_options) {};

/**
 * @type {(function(!angular.JQLite, !Function, !Object=):
 *           (!Function|undefined)|undefined)}
 */
angular.Animation.prototype.leave;

/**
 * @type {function(!angular.JQLite, !Function, !Object=):
 *           (!Function|undefined)|
 *       undefined}
 */
angular.Animation.prototype.move;

/**
 * @type {function(!angular.JQLite, string, !Function, !Object=):
 *           (!Function|undefined)|
 *        undefined}
 */
angular.Animation.prototype.beforeAddClass;

/**
 * @type {function(!angular.JQLite, string, !Function, !Object=):
 *           (!Function|undefined)|
 *        undefined}
 */
angular.Animation.prototype.addClass;

/**
 * @type {function(!angular.JQLite, string, !Function, !Object=):
 *           (!Function|undefined)|
 *        undefined}
 */
angular.Animation.prototype.beforeRemoveClass;

/**
 * @type {function(!angular.JQLite, string, !Function, !Object=):
 *           (!Function|undefined)|
 *        undefined}
 */
angular.Animation.prototype.removeClass;

/**
 * @type {function(!angular.JQLite, string, string, !Function, !Object=):
 *            (!Function|undefined)|
 *        undefined}
 */
angular.Animation.prototype.beforeSetClass;

/**
 * @type {function(!angular.JQLite, string, string, !Function, !Object=):
 *           (!Function|undefined)|
 *        undefined}
 */
angular.Animation.prototype.setClass;



/**
 * @interface
 */
angular.Attributes = function() {};

/**
 * @type {Object<string, string>}
 */
angular.Attributes.prototype.$attr;

/**
 * @param {string} classVal
 */
angular.Attributes.prototype.$addClass = function(classVal) {};

/**
 * @param {string} classVal
 */
angular.Attributes.prototype.$removeClass = function(classVal) {};

/**
 * @param {string} newClasses
 * @param {string} oldClasses
 */
angular.Attributes.prototype.$updateClass = function(newClasses, oldClasses) {};

/**
 * @param {string} name
 * @return {string}
 */
angular.Attributes.prototype.$normalize = function(name) {};

/**
 * @param {string} key
 * @param {function(*)} fn
 * @return {function()}
 */
angular.Attributes.prototype.$observe = function(key, fn) {};

/**
 * @param {string} key
 * @param {?(string|boolean)} value
 * @param {boolean=} opt_writeAttr
 * @param {string=} opt_attrName
 */
angular.Attributes.prototype.$set =
    function(key, value, opt_writeAttr, opt_attrName) {};

/**
 * @record
 */
angular.LinkingFunctions = function() {};

/**
 * @type {function(
 *           !angular.Scope=,
 *           !angular.JQLite=,
 *           !angular.Attributes=,
 *           (!Object|!Array<!Object>)=)|
 *       undefined}
 */
angular.LinkingFunctions.prototype.pre;

/**
 * @type {function(
 *           !angular.Scope=,
 *           !angular.JQLite=,
 *           !angular.Attributes=,
 *           (!Object|Array<!Object>)=)|
 *       undefined}
 */
angular.LinkingFunctions.prototype.post;


/**
 * @typedef {{
 *   bindToController: (boolean|!Object<string, string>|undefined),
 *   compile: (function(
 *       !angular.JQLite=, !angular.Attributes=, Function=)|undefined),
 *   controller: (angular.Injectable|string|undefined),
 *   controllerAs: (string|undefined),
 *   link: (function(
 *       !angular.Scope=, !angular.JQLite=, !angular.Attributes=,
 *       (!Object|!Array.<!Object>)=)|
 *       !angular.LinkingFunctions|
 *       undefined),
 *   name: (string|undefined),
 *   priority: (number|undefined),
 *   replace: (boolean|undefined),
 *   require: (string|Array.<string>|!Object<string, string>|undefined),
 *   restrict: (string|undefined),
 *   scope: (boolean|Object.<string, string>|undefined),
 *   template: (string|!angular.Injectable|undefined),
 *   templateNamespace: (string|undefined),
 *   templateUrl: (string|!angular.Injectable|!Object|undefined),
 *   terminal: (boolean|undefined),
 *   transclude: (boolean|string|!Object.<string, string>|undefined)
 *   }}
 */
angular.Directive;



/**
 * @interface
 * @template T
 */
angular.Change = function() {};

/** @type {T} */
angular.Change.prototype.currentValue;

/** @type {T} */
angular.Change.prototype.previousValue;

/** @return {boolean} */
angular.Change.prototype.isFirstChange = function() {};


/** @record */
angular.ComponentController = function() {};

angular.ComponentController.prototype.$onInit = function() {};

angular.ComponentController.prototype.$postLink = function() {};

/** @param {!Object<!angular.Change>} changesObj */
angular.ComponentController.prototype.$onChanges = function(changesObj) {};

angular.ComponentController.prototype.$doCheck = function() {};

angular.ComponentController.prototype.$onDestroy = function() {};



/**
 * @record
 */
angular.Component = function() {};

/** @type {!Object<string, string>|undefined} */
angular.Component.prototype.bindings;

/** @type {!angular.Injectable|string|undefined|!angular.ComponentController} */
angular.Component.prototype.controller;

/** @type {string|undefined} */
angular.Component.prototype.controllerAs;

/**
 * @type {string|!angular.Injectable|undefined}
 */
angular.Component.prototype.template;

/**
 * @type {string|!angular.Injectable|!Object|undefined}
 */
angular.Component.prototype.templateUrl;

/** @type {boolean|!Object<string, string>|undefined} */
angular.Component.prototype.transclude;

/** @type {!Object<string, string>|undefined} */
angular.Component.prototype.require;



/**
 * @typedef {(Function|Array<string|Function>)}
 */
angular.Injectable;

/**
 * @constructor
 */
angular.JQLite = function() {};

/**
 * @param {string} name
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.addClass = function(name) {};

/**
 * @param {JQLiteSelector} element
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.after = function(element) {};

/**
 * @param {JQLiteSelector} element
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.append = function(element) {};

/**
 * @param {string} name
 * @param {(string|boolean|null)=} opt_value
 * @return {!angular.JQLite|string|boolean}
 */
angular.JQLite.prototype.attr = function(name, opt_value) {};

/**
 * @param {string} type
 * @param {Function} fn
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.bind = function(type, fn) {};

/**
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.children = function() {};

/**
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.clone = function() {};

/**
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.contents = function() {};

/**
 * @param {string=} opt_name
 * @return {Object}
 */
angular.JQLite.prototype.controller = function(opt_name) {};

/**
 * @param {(string|!Object)} nameOrObject
 * @param {string=} opt_value
 * @return {!angular.JQLite|string}
 */
angular.JQLite.prototype.css = function(nameOrObject, opt_value) {};

/**
 * @param {string=} opt_key
 * @param {*=} opt_value
 * @return {*}
 */
angular.JQLite.prototype.data = function(opt_key, opt_value) {};

/**
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.detach = function() {};

/**
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.empty = function() {};

/**
 * @param {number} index
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.eq = function(index) {};

/**
 * @param {string} selector
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.find = function(selector) {};

/**
 * @param {string} name
 * @return {boolean}
 */
angular.JQLite.prototype.hasClass = function(name) {};

/**
 * @param {string=} opt_value
 * @return {!angular.JQLite|string}
 */
angular.JQLite.prototype.html = function(opt_value) {};

/**
 * @param {string=} opt_key
 * @param {*=} opt_value
 * @return {*}
 */
angular.JQLite.prototype.inheritedData = function(opt_key, opt_value) {};

/**
 * @return {!angular.$injector}
 */
angular.JQLite.prototype.injector = function() {};

/** @type {number} */
angular.JQLite.prototype.length;

/**
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.next = function() {};

/**
 * @param {string} type
 * @param {Function} fn
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.on = function(type, fn) {};

/**
 * @param {string} events
 * @param {Object|function(Event)} dataOrHandler
 * @param {function(Event)=} opt_handler
 */
angular.JQLite.prototype.one = function(events, dataOrHandler, opt_handler) {};

/**
 * @param {string=} opt_type
 * @param {Function=} opt_fn
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.off = function(opt_type, opt_fn) {};

/**
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.parent = function() {};

/**
 * @param {JQLiteSelector} element
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.prepend = function(element) {};

/**
 * @param {string} name
 * @param {*=} opt_value
 * @return {*}
 */
angular.JQLite.prototype.prop = function(name, opt_value) {};

/**
 * @param {Function} fn
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.ready = function(fn) {};

/**
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.remove = function() {};

/**
 * @param {string} name
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.removeAttr = function(name) {};

/**
 * @param {string} name
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.removeClass = function(name) {};

/**
 * @param {string=} opt_name
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.removeData = function(opt_name) {};

/**
 * @param {JQLiteSelector} element
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.replaceWith = function(element) {};

/**
 * @return {!angular.Scope}
 */
angular.JQLite.prototype.scope = function() {};

/**
 * @param {string=} opt_value
 * @return {!angular.JQLite|string}
 */
angular.JQLite.prototype.text = function(opt_value) {};

/**
 * @param {string} name
 * @param {boolean=} opt_condition
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.toggleClass = function(name, opt_condition) {};

/**
 * @param {string|!Event} typeOrEvent
 * @param {*=} opt_value
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.triggerHandler = function(typeOrEvent, opt_value) {};

/**
 * @param {string=} opt_type
 * @param {Function=} opt_fn
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.unbind = function(opt_type, opt_fn) {};

/**
 * @param {string=} opt_value
 * @return {!angular.JQLite|string}
 */
angular.JQLite.prototype.val = function(opt_value) {};

/**
 * @param {JQLiteSelector} element
 * @return {!angular.JQLite}
 */
angular.JQLite.prototype.wrap = function(element) {};



/******************************************************************************
 * $provide Service
 *****************************************************************************/

/**
 * @interface
 */
angular.$provide = function() {};


/** @record */
angular.$provide.Provider = function() {};

/** @type {(!Array<string|!Function>|!Function)} */
angular.$provide.Provider.prototype.$get;

/**
 * @param {string} name
 * @param {*} object
 * @return {Object}
 */
angular.$provide.prototype.constant = function(name, object) {};

/**
 * @param {string} name
 * @param {!angular.Injectable} decorator
 */
angular.$provide.prototype.decorator = function(name, decorator) {};

/**
 * @param {string} name
 * @param {angular.Injectable} providerFunction
 * @return {Object}
 */
angular.$provide.prototype.factory = function(name, providerFunction) {};

/**
 * @param {string} name
 * @param {angular.Injectable|angular.$provide.Provider}
 *     providerType
 * @return {Object}
 */
angular.$provide.prototype.provider = function(name, providerType) {};

/**
 * @param {string} name
 * @param {angular.Injectable} constructor
 * @return {Object}
 */
angular.$provide.prototype.service = function(name, constructor) {};

/**
 * @param {string} name
 * @param {*} object
 * @return {Object}
 */
angular.$provide.prototype.value = function(name, object) {};


/******************************************************************************
 * angular.Module
 *****************************************************************************/

/** @interface */
angular.Module = function() {};

/**
 * @param {string} name
 * @param {angular.Injectable} animationFactory
 */
angular.Module.prototype.animation = function(name, animationFactory) {};

/**
 * Intended to be called with a name string and a component definition.
 *
 * @param {string} name
 * @param {!angular.Component} componentDefinition
 * @return {!angular.Module}
 */
angular.Module.prototype.component = function(name, componentDefinition) {};

/**
 * @param {angular.Injectable} configFn
 * @return {!angular.Module}
 */
angular.Module.prototype.config = function(configFn) {};

/**
 * @param {string} name
 * @param {*} object
 * @return {!angular.Module}
 */
angular.Module.prototype.constant = function(name, object) {};

/**
 * Intended to be called with either a name string and a constructor, or an
 * Object with names as keys and constructors as values.
 *
 * @param {string|!Object<angular.Injectable>} name
 * @param {angular.Injectable=} opt_constructor
 * @return {!angular.Module}
 */
angular.Module.prototype.controller = function(name, opt_constructor) {};

/**
 * Intended to be called with either a name string and a directive factory, or
 * an Object with names as keys and directive factories as values.
 *
 * @param {string|!Object<angular.Injectable>} name
 * @param {angular.Injectable=} opt_directiveFactory
 * @return {!angular.Module}
 */
angular.Module.prototype.directive = function(name, opt_directiveFactory) {};

/**
 * @param {string} name
 * @param {angular.Injectable} providerFunction
 * @return {!angular.Module}
 */
angular.Module.prototype.factory = function(name, providerFunction) {};

/**
 * @param {string} name
 * @param {angular.Injectable} filterFactory
 * @return {!angular.Module}
 */
angular.Module.prototype.filter = function(name, filterFactory) {};

/**
 * @param {string} name
 * @param {angular.$provide.Provider|angular.Injectable} providerType
 * @return {!angular.Module}
 */
angular.Module.prototype.provider = function(name, providerType) {};

/**
 * @param {angular.Injectable} initializationFn
 * @return {!angular.Module}
 */
angular.Module.prototype.run = function(initializationFn) {};

/**
 * @param {string} name
 * @param {angular.Injectable} constructor
 * @return {!angular.Module}
 */
angular.Module.prototype.service = function(name, constructor) {};

/**
 * @param {string} name
 * @param {*} object
 * @return {!angular.Module}
 */
angular.Module.prototype.value = function(name, object) {};

/**
 * @param {string} name
 * @param {!angular.Injectable} decorator
 * @return {!angular.Module}
 */
angular.Module.prototype.decorator = function(name, decorator) {};

/**
 * @type {string}
 */
angular.Module.prototype.name;

/**
 * @type {Array<string>}
 */
angular.Module.prototype.requires;

/** @interface */
angular.Scope = function() {};

/** @type {?string} */
angular.Scope.prototype.$$phase;

/**
 * @param {(string|function(!angular.Scope))=} opt_exp
 * @return {*}
 */
angular.Scope.prototype.$apply = function(opt_exp) {};

/**
 * @param {(string|function(!angular.Scope))=} opt_exp
 */
angular.Scope.prototype.$applyAsync = function(opt_exp) {};

/**
 * @param {string} name
 * @param {...*} args
 */
angular.Scope.prototype.$broadcast = function(name, args) {};

angular.Scope.prototype.$destroy = function() {};

angular.Scope.prototype.$digest = function() {};

/**
 * @param {string} name
 * @param {...*} args
 */
angular.Scope.prototype.$emit = function(name, args) {};

/**
 * @param {(string|function(angular.Scope):?)=} opt_exp
 * @param {Object=} opt_locals
 * @return {*}
 */
angular.Scope.prototype.$eval = function(opt_exp, opt_locals) {};

/**
 * @param {(string|function(angular.Scope, ?))=} opt_exp
 * @param {!Object=} opt_locals
 */
angular.Scope.prototype.$evalAsync = function(opt_exp, opt_locals) {};

/** @type {string} */
angular.Scope.prototype.$id;

/**
 * @param {boolean=} opt_isolate
 * @param {angular.Scope=} opt_parent
 * @return {!angular.Scope}
 */
angular.Scope.prototype.$new = function(opt_isolate, opt_parent) {};

/** @type {!angular.Scope} */
angular.Scope.prototype.$parent;

/** @type {!angular.Scope} */
angular.Scope.prototype.$root;

/**
 * @param {string|!Function} exp
 * @param {(string|Function)=} opt_listener
 * @param {boolean=} opt_objectEquality
 * @return {function()}
 */
angular.Scope.prototype.$watch =
    function(exp, opt_listener, opt_objectEquality) {};

/**
 * @param {string|!Function} exp
 * @param {(string|Function)=} opt_listener
 * @return {function()}
 */
angular.Scope.prototype.$watchCollection = function(exp, opt_listener) {};

/**
 * @param {Array<string|!Function>} exps
 * @param {(string|Function)=} opt_listener
 * @return {function()}
 */
angular.Scope.prototype.$watchGroup = function(exps, opt_listener) {};

/**
 * @interface
 */
angular.Scope.Event = function() {};

/** @type {!angular.Scope} */
angular.Scope.Event.prototype.currentScope;

/** @type {boolean} */
angular.Scope.Event.prototype.defaultPrevented;

/** @type {string} */
angular.Scope.Event.prototype.name;

angular.Scope.Event.prototype.preventDefault = function() {};

angular.Scope.Event.prototype.stopPropagation = function() {};

/** @type {!angular.Scope} */
angular.Scope.Event.prototype.targetScope;


/**
 * @param {string} name
 * @param {function(!angular.Scope.Event, ...?)} listener
 * @return {function()}
 */
angular.Scope.prototype.$on = function(name, listener) {};


/**
 * @type {!Object}
 */
angular.version = {};

/**
 * @type {string}
 */
angular.version.full = '';

/**
 * @type {number}
 */
angular.version.major = 0;

/**
 * @type {number}
 */
angular.version.minor = 0;

/**
 * @type {number}
 */
angular.version.dot = 0;

/**
 * @type {string}
 */
angular.version.codeName = '';

/******************************************************************************
 * $anchorScroll Service
 *****************************************************************************/

/**
 * @typedef {function(string=)}
 */
angular.$anchorScroll;

/******************************************************************************
 * $anchorScrollProvider Service
 *****************************************************************************/

/** @interface */
angular.$anchorScrollProvider = function() {};

angular.$anchorScrollProvider.prototype.disableAutoScrolling = function() {};

/******************************************************************************
 * $animate Service
 *****************************************************************************/

/**
 * @interface
 */
angular.$animate = function() {};

/**
 * @param {JQLiteSelector} element
 * @param {Object} from
 * @param {Object} to
 * @param {string=} opt_className
 * @param {Object<string, *>=} opt_options
 * @return {!angular.$q.Promise}
 */
angular.$animate.prototype.animate = function(
    element, from, to, opt_className, opt_options) {};

/**
 * @param {string} event
 * @param {JQLiteSelector} container
 * @param {function(JQLiteSelector, string)} callback
 */
angular.$animate.prototype.on = function(event, container, callback) {};

/**
 * @param {string} event
 * @param {JQLiteSelector=} opt_container
 * @param {function(JQLiteSelector, string)=} opt_callback
 */
angular.$animate.prototype.off = function(event, opt_container, opt_callback) {
};

/**
 * @param {JQLiteSelector} element
 * @param {JQLiteSelector} parentElement
 */
angular.$animate.prototype.pin = function(element, parentElement) {};

/**
 * @param {JQLiteSelector} element
 * @param {JQLiteSelector} parentElement
 * @param {JQLiteSelector} afterElement
 * @param {Object<string, *>=} opt_options
 * @return {!angular.$q.Promise}
 */
angular.$animate.prototype.enter = function(
    element, parentElement, afterElement, opt_options) {};

/**
 * @param {JQLiteSelector} element
 * @param {Object<string, *>=} opt_options
 * @return {!angular.$q.Promise}
 */
angular.$animate.prototype.leave = function(element, opt_options) {};

/**
 * @param {JQLiteSelector} element
 * @param {JQLiteSelector} parentElement
 * @param {JQLiteSelector} afterElement
 * @param {Object<string, *>=} opt_options
 * @return {!angular.$q.Promise}
 */
angular.$animate.prototype.move = function(
    element, parentElement, afterElement, opt_options) {};

/**
 * @param {JQLiteSelector} element
 * @param {string} className
 * @param {Object<string, *>=} opt_options
 * @return {!angular.$q.Promise}
 */
angular.$animate.prototype.addClass = function(
    element, className, opt_options) {};

/**
 * @param {JQLiteSelector} element
 * @param {string} className
 * @param {Object<string, *>=} opt_options
 * @return {!angular.$q.Promise}
 */
angular.$animate.prototype.removeClass = function(
    element, className, opt_options) {};

/**
 * @param {JQLiteSelector} element
 * @param {string} add
 * @param {string} remove
 * @param {Object<string, *>=} opt_options
 * @return {!angular.$q.Promise}
 */
angular.$animate.prototype.setClass = function(
    element, add, remove, opt_options) {};

/**
 * @param {(boolean|JQLiteSelector)=} opt_elementOrValue
 * @param {boolean=} opt_value
 * @return {boolean}
 */
angular.$animate.prototype.enabled = function(opt_elementOrValue, opt_value) {};

/**
 * @param {angular.$q.Promise} animationPromise
 */
angular.$animate.prototype.cancel = function(animationPromise) {};

/******************************************************************************
 * $animateProvider Service
 *****************************************************************************/

/**
 * @interface
 */
angular.$animateProvider = function() {};

/**
 * @param {string} name
 * @param {Function} factory
 */
angular.$animateProvider.prototype.register = function(name, factory) {};

/**
 * @param {RegExp=} opt_expression
 */
angular.$animateProvider.prototype.classNameFilter = function(
    opt_expression) {};

/******************************************************************************
 * $ariaProvider Service
 *****************************************************************************/

/**
 * @interface
 */
angular.$ariaProvider = function() {};

/**
 * @param {!{
 *   ariaHidden: (boolean|undefined),
 *   ariaChecked: (boolean|undefined),
 *   ariaDisabled: (boolean|undefined),
 *   ariaRequired: (boolean|undefined),
 *   ariaInvalid: (boolean|undefined),
 *   ariaMultiline: (boolean|undefined),
 *   ariaValue: (boolean|undefined),
 *   tabindex: (boolean|undefined),
 *   bindKeypress: (boolean|undefined),
 *   bindRoleForClick: (boolean|undefined)
 * }} config
 */
angular.$ariaProvider.prototype.config = function(config) {};

/******************************************************************************
 * $compile Service
 *****************************************************************************/

/**
 * @typedef {
 *   function(
 *       (JQLiteSelector|Object),
 *       function(!angular.Scope, Function=)=, number=):
 *           function(!angular.Scope,
 *               function(!angular.JQLite, !angular.Scope=)=,
 *                   angular.compile.LinkOptions=): !angular.JQLite}
 */
angular.$compile;

/** @const */
angular.compile = {}

/**
 * @record
 */
angular.compile.LinkOptions = function() {};

/** @type {!Function|undefined} */
angular.compile.LinkOptions.prototype.parentBoundTranscludeFn;

/** @type {!Object|undefined} */
angular.compile.LinkOptions.prototype.transcludeControllers;

/** @type {!angular.JQLite|undefined} */
angular.compile.LinkOptions.prototype.futureParentElement;

// TODO(martinprobst): remaining $compileProvider methods.

/**
 * @interface
 */
angular.$compileProvider = function() {};

/**
 * @param {boolean=} opt_enabled
 * @return {boolean|!angular.$compileProvider}
 */
angular.$compileProvider.prototype.debugInfoEnabled = function(opt_enabled) {};

/**
 * @param {number} iterations
 * @return {boolean|!angular.$compileProvider}
 */
angular.$compileProvider.prototype.onChangesTtl = function(iterations) {};

/**
 * @param {!RegExp=} opt_expression
 * @return {!RegExp|!angular.$compileProvider}
 */
angular.$compileProvider.prototype.aHrefSanitizationWhitelist = function(
    opt_expression) {};

/**
 * @param {!RegExp=} opt_expression
 * @return {!RegExp|!angular.$compileProvider}
 */
angular.$compileProvider.prototype.imgSrcSanitizationWhitelist = function(
    opt_expression) {};

/**
 * @param {boolean=} opt_enabled
 * @return {boolean|!angular.$compileProvider}
 */
angular.$compileProvider.prototype.commentDirectivesEnabled = function(
    opt_enabled) {};

/**
 * @param {boolean=} opt_enabled
 * @return {boolean|!angular.$compileProvider}
 */
angular.$compileProvider.prototype.cssClassDirectivesEnabled = function(
    opt_enabled) {};

/**
 * @param {boolean=} opt_enabled
 * @return {boolean|!angular.$compileProvider}
 */
angular.$compileProvider.prototype.preAssignBindingsEnabled = function(
    opt_enabled) {};

/**
 * @param {string} name
 * @param {!angular.Component} options
 */
angular.$compileProvider.prototype.component = function(name, options) {};

/******************************************************************************
 * $cacheFactory Service
 *****************************************************************************/

/** @const */
angular.cacheFactory = {};

/** @record */
angular.cacheFactory.Options = function() {};

/** @type {number|undefined} */
angular.cacheFactory.Options.prototype.capacity;

/**
 * @template T
 * @interface
 */
angular.cacheFactory.Cache = function() {};

/**
 * @record
 */
angular.cacheFactory.Cache.Info = function() {};

/** @type {string} */
angular.cacheFactory.Cache.Info.prototype.id;

/** @type {number} */
angular.cacheFactory.Cache.Info.prototype.size;

/** @type {!angular.cacheFactory.Options} */
angular.cacheFactory.Cache.Info.prototype.options;


/**
 * @return {!angular.cacheFactory.Cache.Info}
 */
angular.cacheFactory.Cache.prototype.info = function() {};

/**
 * @param {string} key
 * @param {T} value
 */
angular.cacheFactory.Cache.prototype.put = function(key, value) {};

/**
 * @param {string} key
 * @return {T}
 */
angular.cacheFactory.Cache.prototype.get = function(key) {};

/**
 * @param {string} key
 */
angular.cacheFactory.Cache.prototype.remove = function(key) {};

angular.cacheFactory.Cache.prototype.removeAll = function() {};
angular.cacheFactory.Cache.prototype.destroy = function() {};



/**
 * @typedef {
 *   function(string, angular.cacheFactory.Options=):
 *       !angular.cacheFactory.Cache}
 */
angular.$cacheFactory;

/**
 * Augment the angular.$cacheFactory type definition by reopening the type via
 * an artificial angular.$cacheFactory instance.
 *
 * This allows us to define methods on function objects which is something
 * that can't be expressed via typical type annotations.
 *
 * @type {angular.$cacheFactory}
 */
angular.$cacheFactory_;

/**
 * @param {string} cacheId
 * @return {!angular.cacheFactory.Cache|undefined}
 */
angular.$cacheFactory_.get;


/******************************************************************************
 * $controller Service
 *****************************************************************************/

/**
 * @typedef {function((Function|string), !Object): !Object}
 */
angular.$controller;


/******************************************************************************
 * $controllerProvider Service
 *****************************************************************************/

/**
 * @record
 */
angular.$controllerProvider = function() {};

/**
 * @param {string|!Object} a
 * @param {!angular.Injectable=} b
 */
angular.$controllerProvider.prototype.register = function(a, b) {};

/**
 */
angular.$controllerProvider.prototype.allowGlobals = function() {};

/******************************************************************************
 * $cookies Service
 *****************************************************************************/

/**
 * @interface
 */
angular.$cookies = function() {};

/**
 * See:
 * https://docs.angularjs.org/api/ngCookies/provider/$cookiesProvider#defaults
 * @record
 */
angular.$cookies.Config = function() {};

/** @type {string|undefined} */
angular.$cookies.Config.prototype.path;

/** @type {string|undefined} */
angular.$cookies.Config.prototype.domain;

/** @type {string|!Date|undefined} */
angular.$cookies.Config.prototype.date;

/** @type {boolean|undefined} */
angular.$cookies.Config.prototype.secure;


/**
 * @param {string} key
 * @return {string|undefined}
 */
angular.$cookies.prototype.get = function(key) {};

/**
 * @param {string} key
 * @return {?Object|undefined}
 */
angular.$cookies.prototype.getObject = function(key) {};

/**
 * @return {!Object<string, string>}
 */
angular.$cookies.prototype.getAll = function() {};

/**
 * @param {string} key
 * @param {string} value
 * @param {!angular.$cookies.Config=} opt_options
 */
angular.$cookies.prototype.put = function(key, value, opt_options) {};

/**
 * @param {string} key
 * @param {?Object} value
 * @param {!angular.$cookies.Config=} opt_options
 */
angular.$cookies.prototype.putObject = function(key, value, opt_options) {};

/**
 * @param {string} key
 * @param {!angular.$cookies.Config=} opt_options
 */
angular.$cookies.prototype.remove = function(key, opt_options) {};


/**
 * @interface
 */
angular.$cookiesProvider = function() {};

/**
 * @type {!angular.$cookies.Config}
 */
angular.$cookiesProvider.prototype.defaults;

/******************************************************************************
 * $exceptionHandler Service
 *****************************************************************************/

/**
 * @typedef {function(!Error, string=)}
 */
angular.$exceptionHandler;

/******************************************************************************
 * $filter Service
 *****************************************************************************/

/**
 * @typedef {function(string): !Function}
 */
angular.$filter;

/**
 * Augment the angular.$filter type definition by reopening the type via
 * an artificial angular.$filter instance.
 *
 * This allows us to define methods on function objects which is something
 * that can't be expressed via typical type annotations.
 *
 * @type {angular.$filter}
 */
angular.$filter_;

/**
 * The 'orderBy' filter is available through $filterProvider and AngularJS
 * injection; but is not accessed through a documented public API of AngularJS.
 * <p>In current AngularJS version the injection is satisfied by
 * angular.orderByFunction, where the implementation is found.
 * <p>See http://docs.angularjs.org/api/ng.filter:orderBy.
 * @typedef {function(Array,
 *     (string|function(?):*|Array<(string|function(?):*)>),
 *     boolean=): Array}
 */
angular.$filter_.orderBy;

/**
 * @typedef {function(Array,
 *     (string|Object|function(?):*),
 *     (function(?):*|boolean)=): Array}
 */
angular.$filter_.filter;


/******************************************************************************
 * $filterProvider Service
 *****************************************************************************/

/**
 * @interface
 */
angular.$filterProvider = function() {};

/**
 * @param {string} name
 * @param {!angular.Injectable} fn
 */
angular.$filterProvider.prototype.register = function(name, fn) {};

/******************************************************************************
 * $http Service
 *****************************************************************************/

/** @interface */
angular.$http = function() {};

/** @record */
angular.$http.Config = function() {};


/** @type {(boolean|!angular.cacheFactory.Cache|undefined)} */
angular.$http.Config.prototype.cache

/** @type {(string|!Object|undefined)} */
angular.$http.Config.prototype.data

/** @type {(Object<?string|undefined>|undefined)} */
angular.$http.Config.prototype.headers;

/** @type {(string|undefined)} */
angular.$http.Config.prototype.jsonpCallbackParam;

/** @type {(string|undefined)} */
angular.$http.Config.prototype.method;

/** @type {(?Object<(boolean|number|string|Object)>|undefined)} */
angular.$http.Config.prototype.params;

/** @type {(string|function(Object<string,string>):string|undefined)} */
angular.$http.Config.prototype.paramSerializer;

/** @type {(string|undefined)} */
angular.$http.Config.prototype.responseType;

/** @type {(number|!angular.$q.Promise|undefined)} */
angular.$http.Config.prototype.timeout;

/** @typedef {function(string=): (?string | !Object<string>)} */
angular.$http.HeadersGetter;

/**
 * @type {
 *   (undefined|
 *    function(?, !angular.$http.HeadersGetter):?|
 *    !Array<function(?, !angular.$http.HeadersGetter):?>)
 * }
 */
angular.$http.Config.prototype.transformRequest;

/**
 * @type {
 *   (undefined|
 *    function(?, !angular.$http.HeadersGetter, number):?|
 *    !Array<function(?, !angular.$http.HeadersGetter, number):?>)
 * }
 */
angular.$http.Config.prototype.transformResponse;

/** @type {(string|undefined)} */
angular.$http.Config.prototype.url;

/** @type {(boolean|undefined)} */
angular.$http.Config.prototype.withCredentials;

/** @type {(string|undefined)} */
angular.$http.Config.prototype.xsrfCookieName;

/** @type {(string|undefined)} */
angular.$http.Config.prototype.xsrfHeaderName;



/**
 * Externs are parsed as ES5, so using 'delete'
 * should be fine, even though it is a reserved word.
 *
 * @param {angular.$http.Config=} opt_config
 * @return {!angular.$http.HttpPromise}
 */
angular.$http.prototype.delete = function(url, opt_config) {};

/**
 * @param {string} url
 * @param {angular.$http.Config=} opt_config
 * @return {!angular.$http.HttpPromise}
 */
angular.$http.prototype.get = function(url, opt_config) {};

/**
 * @param {string} url
 * @param {angular.$http.Config=} opt_config
 * @return {!angular.$http.HttpPromise}
 */
angular.$http.prototype.head = function(url, opt_config) {};

/**
 * @param {string|!Object} url
 * @param {angular.$http.Config=} opt_config
 * @return {!angular.$http.HttpPromise}
 */
angular.$http.prototype.jsonp = function(url, opt_config) {};

/**
 * @param {string} url
 * @param {*} data
 * @param {angular.$http.Config=} opt_config
 * @return {!angular.$http.HttpPromise}
 */
angular.$http.prototype.patch = function(url, data, opt_config) {};

/**
 * @param {string} url
 * @param {*} data
 * @param {angular.$http.Config=} opt_config
 * @return {!angular.$http.HttpPromise}
 */
angular.$http.prototype.post = function(url, data, opt_config) {};

/**
 * @param {string} url
 * @param {*} data
 * @param {angular.$http.Config=} opt_config
 * @return {!angular.$http.HttpPromise}
 */
angular.$http.prototype.put = function(url, data, opt_config) {};

/**
 * @type {angular.$http.Config}
 */
angular.$http.prototype.defaults;

/**
 * @type {!Array<!angular.$http.Config>}
 * @const
 */
angular.$http.prototype.pendingRequests;

/** @record */
angular.$http.Interceptor = function() {};

/** @type {undefined|(function(!angular.$http.Config))} */
angular.$http.Interceptor.prototype.request;

/** @type {(undefined|(function(Object): !angular.$q.Promise|Object))} */
angular.$http.Interceptor.prototype.requestError;

/**
 * @type {(undefined|
 *       (function(!angular.$http.Response):
 *           !angular.$http.Response|
 *           !angular.$q.Promise<!angular.$http.Response>))}
 */
angular.$http.Interceptor.prototype.response;

/**
 * @type {(undefined|(function(Object): !angular.$q.Promise|Object))} */
angular.$http.Interceptor.prototype.responseError;

/**
 * @interface
 */
angular.$HttpProvider = function() {};

/**
 * @type {angular.$http.Config}
 */
angular.$HttpProvider.prototype.defaults;

/**
 * @type {!Array<string|function(...?): !angular.$http.Interceptor>}
 */
angular.$HttpProvider.prototype.interceptors;

/**
 * @param {boolean=} opt_value
 * @return {boolean|!angular.$HttpProvider}
 */
angular.$HttpProvider.prototype.useApplyAsync = function(opt_value) {};

/**
 * @param {boolean=} opt_value
 * @return {boolean|!angular.$HttpProvider}
 */
angular.$HttpProvider.prototype.useLegacyPromiseExtensions = function(
    opt_value) {};


/** @typedef {function((string|?Object)): string} */
angular.$httpParamSerializer;

/******************************************************************************
 * $injector Service
 *****************************************************************************/

/**
 * @interface
 */
angular.$injector = function() {};

/**
 * @param {angular.Injectable} fn
 * @return {Array<string>}
 */
angular.$injector.prototype.annotate = function(fn) {};

/**
 * @param {string} name
 * @return {?}
 */
angular.$injector.prototype.get = function(name) {};

/**
 * @param {string} name
 * @return {boolean}
 */
angular.$injector.prototype.has = function(name) {};

/**
 * @param {!Function} type
 * @param {Object=} opt_locals
 * @return {Object}
 */
angular.$injector.prototype.instantiate = function(type, opt_locals) {};

/**
 * @param {angular.Injectable} fn
 * @param {Object=} opt_self
 * @param {Object=} opt_locals
 * @return {?}
 */
angular.$injector.prototype.invoke = function(fn, opt_self, opt_locals) {};

/******************************************************************************
 * $interpolateProvider Service
 *****************************************************************************/

/**
 * @interface
 */
angular.$interpolateProvider = function() {};

/** @type {function(string)} */
angular.$interpolateProvider.prototype.startSymbol;

/** @type {function(string)} */
angular.$interpolateProvider.prototype.endSymbol;

/******************************************************************************
 * $interpolate Service
 *****************************************************************************/

/**
 * @typedef {function(string, boolean=, string=, boolean=):?function(Object):*}
 */
angular.$interpolate;

/******************************************************************************
 * $interval Service
 *****************************************************************************/

/**
 * @typedef {
 *  function(function(), number=, number=, boolean=):!angular.$q.Promise
 * }
 */
angular.$interval;

/**
 * Augment the angular.$interval type definition by reopening the type via an
 * artificial angular.$interval instance.
 *
 * This allows us to define methods on function objects which is something
 * that can't be expressed via typical type annotations.
 *
 * @type {angular.$interval}
 */
angular.$interval_;

/**
 * @type {function(!angular.$q.Promise):boolean}
 */
angular.$interval_.cancel = function(promise) {};


/******************************************************************************
 * $locale Service
 *****************************************************************************/

/**
 * @interface
 */
angular.$locale = function() {};

/**
 * @type {string}
 */
angular.$locale.prototype.id;

/******************************************************************************
 * $location Service
 *****************************************************************************/

/**
 * @interface
 */
angular.$location = function() {};

/**
 * @return {string}
 */
angular.$location.prototype.absUrl = function() {};

/**
 * @param {string=} opt_hash
 * @return {string}
 */
angular.$location.prototype.hash = function(opt_hash) {};

/**
 * @return {string}
 */
angular.$location.prototype.host = function() {};

/**
 * @param {string=} opt_path
 * @return {string|!angular.$location}
 */
angular.$location.prototype.path = function(opt_path) {};

/**
 * @return {number}
 */
angular.$location.prototype.port = function() {};

/**
 * @return {string}
 */
angular.$location.prototype.protocol = function() {};

/**
 * @type {function()}
 */
angular.$location.prototype.replace = function() {};

/**
 * @param {(string|Object.<string, string>|Object.<string, Array.<string>>)=}
 *     opt_search
 * @param {?(string|Array<string>|boolean|number)=} opt_paramValue
 * @return {(!Object|!angular.$location)}
 */
angular.$location.prototype.search = function(opt_search, opt_paramValue) {};

/**
 * @param {string=} opt_url
 * @return {string}
 */
angular.$location.prototype.url = function(opt_url) {};

/******************************************************************************
 * $locationProvider Service
 *****************************************************************************/

/**
 * @interface
 */
angular.$locationProvider = function() {};

/**
 * @record
 */
angular.$locationProvider.html5ModeConfig = function() {};

/** @type {boolean|undefined} */
angular.$locationProvider.html5ModeConfig.prototype.enabled;

/** @type {boolean|undefined} */
angular.$locationProvider.html5ModeConfig.prototype.requireBase;

/**
 * @param {string=} opt_prefix
 * @return {string|!angular.$locationProvider}
 */
angular.$locationProvider.prototype.hashPrefix = function(opt_prefix) {};

/**
 * @param {(boolean|angular.$locationProvider.html5ModeConfig)=} opt_mode
 * @return {boolean|!angular.$locationProvider}
 */
angular.$locationProvider.prototype.html5Mode = function(opt_mode) {};

/******************************************************************************
 * $logProvider Service
 *****************************************************************************/

/** @interface */
angular.$logProvider = function() {};

/**
 * @param {boolean=} opt_debugEnabled
 * @return {*}
 */
angular.$logProvider.prototype.debugEnabled = function(opt_debugEnabled) {};

/******************************************************************************
 * $log Service
 *****************************************************************************/


















